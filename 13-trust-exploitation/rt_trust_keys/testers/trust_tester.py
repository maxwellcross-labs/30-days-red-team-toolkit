"""
Trust Authentication Tester
Test if authentication works across trust relationships
"""

import subprocess
import shutil
from typing import Optional, List
from dataclasses import dataclass
from enum import Enum

from ..models import TrustRelationship, TrustType


class TestResult(Enum):
    """Test result status"""
    SUCCESS = "success"
    FAILED = "failed"
    PARTIAL = "partial"
    ERROR = "error"


@dataclass
class TrustTestResult:
    """Result of a trust authentication test"""
    source_domain: str
    target_domain: str
    test_type: str
    result: TestResult
    message: str
    details: Optional[str] = None


class TrustTester:
    """
    Test trust relationship authentication
    """

    def __init__(self, verbose: bool = True):
        """
        Initialize trust tester

        Args:
            verbose: Print status messages
        """
        self.verbose = verbose
        self.timeout = 15

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def test_smb_access(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str
    ) -> TrustTestResult:
        """
        Test SMB access across trust

        Args:
            source_domain: User's domain
            target_domain: Domain to access
            username: Username
            password: Password

        Returns:
            TrustTestResult
        """
        self.log(f"Testing SMB access: {username}@{source_domain} -> {target_domain}")

        # Use smbclient to test
        cmd = f"smbclient -L //{target_domain} -U '{source_domain}\\{username}%{password}'"

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            if result.returncode == 0 or "Sharename" in result.stdout:
                self.log(f"SMB access SUCCESSFUL!", "success")
                return TrustTestResult(
                    source_domain=source_domain,
                    target_domain=target_domain,
                    test_type="SMB",
                    result=TestResult.SUCCESS,
                    message="User can enumerate shares in target domain",
                    details=result.stdout
                )
            else:
                self.log(f"SMB access FAILED", "error")
                return TrustTestResult(
                    source_domain=source_domain,
                    target_domain=target_domain,
                    test_type="SMB",
                    result=TestResult.FAILED,
                    message="Authentication failed or access denied",
                    details=result.stderr
                )

        except subprocess.TimeoutExpired:
            return TrustTestResult(
                source_domain=source_domain,
                target_domain=target_domain,
                test_type="SMB",
                result=TestResult.ERROR,
                message="Connection timeout"
            )
        except Exception as e:
            return TrustTestResult(
                source_domain=source_domain,
                target_domain=target_domain,
                test_type="SMB",
                result=TestResult.ERROR,
                message=str(e)
            )

    def test_ldap_access(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str
    ) -> TrustTestResult:
        """
        Test LDAP access across trust
        """
        self.log(f"Testing LDAP access: {username}@{source_domain} -> {target_domain}")

        # Try ldapsearch or impacket
        if shutil.which("ldapsearch"):
            cmd = f"ldapsearch -x -H ldap://{target_domain} -D '{username}@{source_domain}' -w '{password}' -b 'DC={target_domain.replace('.', ',DC=')}' '(objectClass=domain)'"
        else:
            self.log("ldapsearch not available, skipping LDAP test", "warning")
            return TrustTestResult(
                source_domain=source_domain,
                target_domain=target_domain,
                test_type="LDAP",
                result=TestResult.ERROR,
                message="ldapsearch not installed"
            )

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            if result.returncode == 0:
                self.log(f"LDAP access SUCCESSFUL!", "success")
                return TrustTestResult(
                    source_domain=source_domain,
                    target_domain=target_domain,
                    test_type="LDAP",
                    result=TestResult.SUCCESS,
                    message="User can query LDAP in target domain",
                    details=result.stdout[:500] if result.stdout else None
                )
            else:
                self.log(f"LDAP access FAILED", "error")
                return TrustTestResult(
                    source_domain=source_domain,
                    target_domain=target_domain,
                    test_type="LDAP",
                    result=TestResult.FAILED,
                    message="LDAP authentication failed",
                    details=result.stderr
                )

        except Exception as e:
            return TrustTestResult(
                source_domain=source_domain,
                target_domain=target_domain,
                test_type="LDAP",
                result=TestResult.ERROR,
                message=str(e)
            )

    def test_kerberos_auth(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str,
            target_spn: Optional[str] = None
    ) -> TrustTestResult:
        """
        Test Kerberos authentication across trust
        """
        self.log(f"Testing Kerberos auth: {username}@{source_domain} -> {target_domain}")

        if not shutil.which("getTGT.py"):
            return TrustTestResult(
                source_domain=source_domain,
                target_domain=target_domain,
                test_type="Kerberos",
                result=TestResult.ERROR,
                message="Impacket getTGT.py not installed"
            )

        # Get TGT from source domain
        cmd = f"getTGT.py {source_domain}/{username}:'{password}'"

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            if result.returncode == 0 and ".ccache" in result.stdout:
                self.log("Got TGT from source domain", "success")

                # Try to get referral to target domain
                # This tests if the trust allows Kerberos referrals
                return TrustTestResult(
                    source_domain=source_domain,
                    target_domain=target_domain,
                    test_type="Kerberos",
                    result=TestResult.SUCCESS,
                    message="Successfully obtained TGT, trust likely allows Kerberos",
                    details=result.stdout
                )
            else:
                return TrustTestResult(
                    source_domain=source_domain,
                    target_domain=target_domain,
                    test_type="Kerberos",
                    result=TestResult.FAILED,
                    message="Failed to obtain TGT",
                    details=result.stderr
                )

        except Exception as e:
            return TrustTestResult(
                source_domain=source_domain,
                target_domain=target_domain,
                test_type="Kerberos",
                result=TestResult.ERROR,
                message=str(e)
            )

    def run_all_tests(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str
    ) -> List[TrustTestResult]:
        """
        Run all authentication tests

        Returns:
            List of TrustTestResult objects
        """
        self.log(f"Running trust authentication tests...")
        self.log(f"Source: {username}@{source_domain}")
        self.log(f"Target: {target_domain}")

        results = [self.test_smb_access(source_domain, target_domain, username, password),
                   self.test_ldap_access(source_domain, target_domain, username, password),
                   self.test_kerberos_auth(source_domain, target_domain, username, password)]

        # SMB test

        # LDAP test

        # Kerberos test

        # Summary
        self._print_summary(results)

        return results

    def _print_summary(self, results: List[TrustTestResult]) -> None:
        """Print test summary"""
        print(f"\n" + "=" * 60)
        print("TRUST AUTHENTICATION TEST SUMMARY")
        print("=" * 60)

        for r in results:
            status_icon = "✓" if r.result == TestResult.SUCCESS else "✗"
            print(f"\n{status_icon} {r.test_type}: {r.result.value}")
            print(f"  {r.message}")

        # Overall assessment
        successes = sum(1 for r in results if r.result == TestResult.SUCCESS)

        print(f"\n" + "-" * 40)
        if successes == len(results):
            print(f"[+] Trust appears to be fully functional!")
        elif successes > 0:
            print(f"[*] Trust partially functional ({successes}/{len(results)} tests passed)")
        else:
            print(f"[-] Trust may not allow cross-domain authentication")