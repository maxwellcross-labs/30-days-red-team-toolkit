"""
Kerberos Utilities
Helper functions for Kerberos ticket operations
"""

import re
from typing import Optional, Tuple, List
from datetime import datetime, timedelta

# Kerberos encryption types
ENCRYPTION_TYPES = {
    1: ("DES-CBC-CRC", "des_cbc_crc"),
    3: ("DES-CBC-MD5", "des_cbc_md5"),
    17: ("AES128-CTS-HMAC-SHA1-96", "aes128"),
    18: ("AES256-CTS-HMAC-SHA1-96", "aes256"),
    23: ("RC4-HMAC", "rc4_hmac"),
    24: ("RC4-HMAC-EXP", "rc4_hmac_exp"),
}

# Default ticket lifetime
DEFAULT_TICKET_LIFETIME = timedelta(hours=10)
DEFAULT_RENEW_LIFETIME = timedelta(days=7)


def get_trust_account_name(target_domain: str) -> str:
    """
    Get trust account name from domain name

    Args:
        target_domain: Target domain FQDN

    Returns:
        Trust account name (e.g., TARGETDOMAIN$)
    """
    netbios = target_domain.split('.')[0].upper()
    return f"{netbios}$"


def get_krbtgt_spn(domain: str) -> str:
    """
    Get krbtgt service principal name

    Args:
        domain: Domain name

    Returns:
        krbtgt SPN (e.g., krbtgt/DOMAIN)
    """
    return f"krbtgt/{domain.upper()}"


def get_inter_realm_spn(target_domain: str) -> str:
    """
    Get inter-realm krbtgt SPN for trust

    Args:
        target_domain: Target domain name

    Returns:
        Inter-realm SPN
    """
    return f"krbtgt/{target_domain.upper()}"


def validate_ntlm_hash(hash_value: str) -> bool:
    """
    Validate NTLM hash format

    Args:
        hash_value: Hash string to validate

    Returns:
        True if valid NTLM hash format
    """
    if not hash_value:
        return False

    # NTLM hash is 32 hex characters
    pattern = r'^[a-fA-F0-9]{32}$'
    return bool(re.match(pattern, hash_value))


def validate_aes_key(key_value: str, key_size: int = 256) -> bool:
    """
    Validate AES key format

    Args:
        key_value: Key string to validate
        key_size: Key size in bits (128 or 256)

    Returns:
        True if valid AES key format
    """
    if not key_value:
        return False

    # AES key length in hex characters
    expected_length = key_size // 4  # 32 for AES128, 64 for AES256
    pattern = f'^[a-fA-F0-9]{{{expected_length}}}$'
    return bool(re.match(pattern, key_value))


def parse_secretsdump_output(output: str) -> dict:
    """
    Parse secretsdump.py output for trust keys

    Args:
        output: Raw secretsdump output

    Returns:
        Dictionary of account -> key info
    """
    trust_keys = {}

    # Pattern for NTLM hashes: account:rid:lmhash:nthash:::
    ntlm_pattern = r'^([^:]+)\$:(\d+):([a-fA-F0-9]{32}):([a-fA-F0-9]{32}):::'

    # Pattern for AES keys from supplemental credentials
    aes256_pattern = r'aes256-cts-hmac-sha1-96\s*:\s*([a-fA-F0-9]{64})'
    aes128_pattern = r'aes128-cts-hmac-sha1-96\s*:\s*([a-fA-F0-9]{32})'

    current_account = None

    for line in output.split('\n'):
        line = line.strip()

        # Check for NTLM hash line
        ntlm_match = re.match(ntlm_pattern, line)
        if ntlm_match:
            account = ntlm_match.group(1) + "$"
            lm_hash = ntlm_match.group(3)
            nt_hash = ntlm_match.group(4)

            current_account = account
            trust_keys[account] = {
                "account": account,
                "ntlm": nt_hash,
                "lm": lm_hash if lm_hash != "aad3b435b51404eeaad3b435b51404ee" else None,
                "aes256": None,
                "aes128": None,
            }

        # Check for AES256 key
        aes256_match = re.search(aes256_pattern, line, re.IGNORECASE)
        if aes256_match and current_account:
            trust_keys[current_account]["aes256"] = aes256_match.group(1)

        # Check for AES128 key
        aes128_match = re.search(aes128_pattern, line, re.IGNORECASE)
        if aes128_match and current_account:
            trust_keys[current_account]["aes128"] = aes128_match.group(1)

    return trust_keys


def parse_mimikatz_dcsync(output: str) -> dict:
    """
    Parse Mimikatz DCSync output for keys

    Args:
        output: Raw Mimikatz output

    Returns:
        Dictionary of extracted keys
    """
    result = {
        "account": None,
        "ntlm": None,
        "aes256": None,
        "aes128": None,
        "sid": None,
    }

    # SAM Account Name
    sam_match = re.search(r'SAM Account Name\s*:\s*(\S+)', output)
    if sam_match:
        result["account"] = sam_match.group(1)

    # Object SID
    sid_match = re.search(r'Object Security ID\s*:\s*(S-1-5-[\d-]+)', output)
    if sid_match:
        result["sid"] = sid_match.group(1)

    # NTLM hash
    ntlm_match = re.search(r'Hash NTLM:\s*([a-fA-F0-9]{32})', output)
    if ntlm_match:
        result["ntlm"] = ntlm_match.group(1)

    # AES256
    aes256_match = re.search(r'aes256_hmac\s*\(4096\)\s*:\s*([a-fA-F0-9]{64})', output)
    if aes256_match:
        result["aes256"] = aes256_match.group(1)

    # AES128
    aes128_match = re.search(r'aes128_hmac\s*\(4096\)\s*:\s*([a-fA-F0-9]{32})', output)
    if aes128_match:
        result["aes128"] = aes128_match.group(1)

    return result


def calculate_ticket_times(
        start_time: Optional[datetime] = None,
        lifetime: Optional[timedelta] = None,
        renew_lifetime: Optional[timedelta] = None
) -> Tuple[datetime, datetime, datetime]:
    """
    Calculate Kerberos ticket timestamps

    Args:
        start_time: Ticket start time (default: now)
        lifetime: Ticket lifetime (default: 10 hours)
        renew_lifetime: Renewable lifetime (default: 7 days)

    Returns:
        Tuple of (start_time, end_time, renew_until)
    """
    if start_time is None:
        start_time = datetime.now()

    if lifetime is None:
        lifetime = DEFAULT_TICKET_LIFETIME

    if renew_lifetime is None:
        renew_lifetime = DEFAULT_RENEW_LIFETIME

    end_time = start_time + lifetime
    renew_until = start_time + renew_lifetime

    return start_time, end_time, renew_until


def get_encryption_type_name(etype: int) -> str:
    """
    Get human-readable encryption type name

    Args:
        etype: Encryption type number

    Returns:
        Encryption type name
    """
    if etype in ENCRYPTION_TYPES:
        return ENCRYPTION_TYPES[etype][0]
    return f"Unknown ({etype})"


def format_ticket_info(ticket_data: dict) -> str:
    """
    Format ticket information for display

    Args:
        ticket_data: Ticket information dictionary

    Returns:
        Formatted string
    """
    lines = [
        "Ticket Information:",
        f"  Client: {ticket_data.get('client', 'N/A')}",
        f"  Server: {ticket_data.get('server', 'N/A')}",
        f"  Encryption: {ticket_data.get('encryption', 'N/A')}",
        f"  Start Time: {ticket_data.get('start_time', 'N/A')}",
        f"  End Time: {ticket_data.get('end_time', 'N/A')}",
    ]

    if ticket_data.get('renew_until'):
        lines.append(f"  Renew Until: {ticket_data['renew_until']}")

    return "\n".join(lines)