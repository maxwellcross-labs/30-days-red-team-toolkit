"""
Base Forger Class
Abstract base for all ticket forging methods
"""

from abc import ABC, abstractmethod
from typing import Optional, List
from pathlib import Path

from ..models import TrustKey, ForgedTicket, KeyType


class BaseForger(ABC):
    """
    Abstract base class for ticket forgers
    All forging methods should inherit from this
    """

    def __init__(self, output_dir: str = "trust_keys", verbose: bool = True):
        """
        Initialize forger

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose
        self.name = self.__class__.__name__

    def log(self, message: str, level: str = "info") -> None:
        """Print status message if verbose enabled"""
        if not self.verbose:
            return
        prefixes = {
            "info": "[*]",
            "success": "[+]",
            "error": "[-]",
            "warning": "[!]",
        }
        prefix = prefixes.get(level, "[*]")
        print(f"{prefix} {message}")

    @abstractmethod
    def forge_inter_realm_tgt(
            self,
            trust_key: TrustKey,
            user_to_impersonate: str,
            user_sid: Optional[str] = None,
            extra_sids: Optional[List[str]] = None
    ) -> Optional[ForgedTicket]:
        """
        Forge inter-realm TGT using trust key

        Args:
            trust_key: Extracted trust key
            user_to_impersonate: Username to forge ticket for
            user_sid: User's SID (optional)
            extra_sids: Additional SIDs for SID history

        Returns:
            ForgedTicket object or None
        """
        pass

    @abstractmethod
    def generate_commands(
            self,
            trust_key: TrustKey,
            user_to_impersonate: str,
            user_sid: Optional[str] = None,
            extra_sids: Optional[List[str]] = None
    ) -> List[str]:
        """
        Generate forging commands without executing

        Returns:
            List of command strings
        """
        pass

    @abstractmethod
    def is_available(self) -> bool:
        """
        Check if this forging method is available

        Returns:
            True if method can be used
        """
        pass

    def save_commands(
            self,
            commands: List[str],
            trust_key: TrustKey,
            user_to_impersonate: str
    ) -> Path:
        """
        Save generated commands to file
        """
        filename = f"{self.name.lower()}_{trust_key.source_domain}_to_{trust_key.target_domain}_{user_to_impersonate}.txt"
        filepath = self.output_dir / filename

        with open(filepath, 'w') as f:
            f.write(f"# Inter-realm TGT Forging Commands\n")
            f.write(f"# Source: {trust_key.source_domain}\n")
            f.write(f"# Target: {trust_key.target_domain}\n")
            f.write(f"# User: {user_to_impersonate}\n")
            f.write(f"# Method: {self.name}\n")
            f.write(f"# Generated by RT Trust Key Framework\n\n")

            for cmd in commands:
                f.write(f"{cmd}\n")

        self.log(f"Commands saved to: {filepath}", "success")

        return filepath