"""
Trust Key Data Models
Data structures for trust key extraction and exploitation
"""

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from enum import Enum
from datetime import datetime


class TrustType(Enum):
    """Types of AD trust relationships"""
    PARENT_CHILD = "parent_child"
    FOREST = "forest"
    EXTERNAL = "external"
    SHORTCUT = "shortcut"
    REALM = "realm"  # MIT Kerberos
    UNKNOWN = "unknown"


class KeyType(Enum):
    """Trust key encryption types"""
    RC4_HMAC = "rc4_hmac"  # NTLM hash
    AES128 = "aes128"
    AES256 = "aes256"
    DES_CBC = "des_cbc"  # Legacy


class ExtractionMethod(Enum):
    """Methods for extracting trust keys"""
    MIMIKATZ_DCSYNC = "mimikatz_dcsync"
    SECRETSDUMP = "secretsdump"
    NTDSUTIL = "ntdsutil"
    MANUAL = "manual"


class ExtractionStatus(Enum):
    """Status of key extraction operation"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"
    PARTIAL = "partial"  # Some keys extracted


@dataclass
class TrustKey:
    """
    Represents an extracted trust key
    """
    account_name: str  # e.g., TARGETDOMAIN$
    source_domain: str
    target_domain: str
    key_type: KeyType
    key_value: str  # The actual hash/key

    # Optional additional keys
    aes256_key: Optional[str] = None
    aes128_key: Optional[str] = None

    # Metadata
    extracted_at: Optional[datetime] = None
    extraction_method: ExtractionMethod = ExtractionMethod.MANUAL

    @property
    def is_rc4(self) -> bool:
        """Check if this is an RC4/NTLM key"""
        return self.key_type == KeyType.RC4_HMAC

    @property
    def has_aes_keys(self) -> bool:
        """Check if AES keys are available"""
        return bool(self.aes256_key or self.aes128_key)

    @property
    def best_key(self) -> tuple:
        """Get the strongest available key"""
        if self.aes256_key:
            return KeyType.AES256, self.aes256_key
        elif self.aes128_key:
            return KeyType.AES128, self.aes128_key
        else:
            return self.key_type, self.key_value

    def to_dict(self) -> Dict[str, Any]:
        return {
            "account_name": self.account_name,
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "key_type": self.key_type.value,
            "key_value": self.key_value,
            "aes256_key": self.aes256_key,
            "aes128_key": self.aes128_key,
            "extracted_at": self.extracted_at.isoformat() if self.extracted_at else None,
            "extraction_method": self.extraction_method.value,
            "has_aes_keys": self.has_aes_keys,
        }


@dataclass
class TrustRelationship:
    """
    Represents a trust relationship between domains
    """
    source_domain: str
    target_domain: str
    trust_type: TrustType

    # Direction
    is_bidirectional: bool = False
    is_transitive: bool = True

    # Security settings
    sid_filtering_enabled: bool = True
    selective_authentication: bool = False

    # Extracted keys
    trust_keys: List[TrustKey] = field(default_factory=list)

    # Domain SIDs (needed for ticket forging)
    source_domain_sid: Optional[str] = None
    target_domain_sid: Optional[str] = None

    @property
    def trust_account_name(self) -> str:
        """Get the trust account name (TARGETDOMAIN$)"""
        netbios = self.target_domain.split('.')[0].upper()
        return f"{netbios}$"

    @property
    def is_exploitable(self) -> bool:
        """Check if trust has exploitable configuration"""
        # Bidirectional + no SID filtering = highly exploitable
        if self.is_bidirectional and not self.sid_filtering_enabled:
            return True
        # Parent-child trusts are always exploitable
        if self.trust_type == TrustType.PARENT_CHILD:
            return True
        return False

    @property
    def has_keys(self) -> bool:
        """Check if trust keys have been extracted"""
        return len(self.trust_keys) > 0

    def add_key(self, key: TrustKey) -> None:
        """Add extracted trust key"""
        self.trust_keys.append(key)

    def get_best_key(self) -> Optional[TrustKey]:
        """Get the trust key with strongest encryption"""
        if not self.trust_keys:
            return None

        # Prefer AES256 > AES128 > RC4
        for key in self.trust_keys:
            if key.aes256_key:
                return key
        for key in self.trust_keys:
            if key.aes128_key:
                return key
        return self.trust_keys[0]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "trust_type": self.trust_type.value,
            "trust_account": self.trust_account_name,
            "is_bidirectional": self.is_bidirectional,
            "is_transitive": self.is_transitive,
            "sid_filtering_enabled": self.sid_filtering_enabled,
            "selective_authentication": self.selective_authentication,
            "is_exploitable": self.is_exploitable,
            "source_domain_sid": self.source_domain_sid,
            "target_domain_sid": self.target_domain_sid,
            "trust_keys": [k.to_dict() for k in self.trust_keys],
        }


@dataclass
class ForgedTicket:
    """
    Represents a forged Kerberos ticket
    """
    ticket_type: str  # TGT, TGS, inter-realm
    username: str
    source_domain: str
    target_domain: str
    target_service: str  # e.g., krbtgt/TARGETDOMAIN

    # Key used
    key_type: KeyType
    key_used: str

    # Ticket details
    ticket_file: Optional[str] = None  # .ccache or .kirbi path
    injected: bool = False

    # Optional SID history
    extra_sids: List[str] = field(default_factory=list)

    # Timestamps
    created_at: Optional[datetime] = None
    valid_until: Optional[datetime] = None

    def to_dict(self) -> Dict[str, Any]:
        return {
            "ticket_type": self.ticket_type,
            "username": self.username,
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "target_service": self.target_service,
            "key_type": self.key_type.value,
            "ticket_file": self.ticket_file,
            "injected": self.injected,
            "extra_sids": self.extra_sids,
            "created_at": self.created_at.isoformat() if self.created_at else None,
            "valid_until": self.valid_until.isoformat() if self.valid_until else None,
        }


@dataclass
class ExtractionOperation:
    """
    Represents a trust key extraction operation
    """
    source_domain: str
    target_domain: str
    method: ExtractionMethod
    status: ExtractionStatus = ExtractionStatus.PENDING

    # Credentials used
    username: Optional[str] = None
    dc_ip: Optional[str] = None

    # Results
    keys_extracted: List[TrustKey] = field(default_factory=list)
    commands_generated: List[str] = field(default_factory=list)
    output_file: Optional[str] = None

    # Timing
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None
    error_message: Optional[str] = None

    def mark_started(self) -> None:
        self.status = ExtractionStatus.IN_PROGRESS
        self.started_at = datetime.now()

    def mark_success(self, keys: List[TrustKey]) -> None:
        self.status = ExtractionStatus.SUCCESS
        self.completed_at = datetime.now()
        self.keys_extracted = keys

    def mark_failed(self, error: str) -> None:
        self.status = ExtractionStatus.FAILED
        self.completed_at = datetime.now()
        self.error_message = error

    def to_dict(self) -> Dict[str, Any]:
        return {
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "method": self.method.value,
            "status": self.status.value,
            "dc_ip": self.dc_ip,
            "keys_extracted": [k.to_dict() for k in self.keys_extracted],
            "output_file": self.output_file,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "error_message": self.error_message,
        }