"""
Exploitation Path Analyzer
Identify and prioritize exploitation paths from discovered trusts
"""

from typing import List, Optional, Dict, Any
from pathlib import Path

from ..models import (
    TrustInfo,
    TrustCategory,
    ExploitPath,
    ExploitMethod,
    ExploitPriority,
)
from ..utils import determine_parent_child


class PathAnalyzer:
    """
    Analyze discovered trusts and identify exploitation paths
    """

    def __init__(self, verbose: bool = True):
        """
        Initialize path analyzer

        Args:
            verbose: Print status messages
        """
        self.verbose = verbose

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def analyze_trusts(
            self,
            trusts: List[TrustInfo],
            current_domain: str
    ) -> List[ExploitPath]:
        """
        Analyze trusts and identify all exploitation paths

        Args:
            trusts: List of discovered trusts
            current_domain: Currently compromised domain

        Returns:
            List of ExploitPath objects sorted by priority
        """
        self.log(f"Analyzing {len(trusts)} trusts for exploitation paths...")

        paths = []

        for trust in trusts:
            trust_paths = self._analyze_single_trust(trust, current_domain)
            paths.extend(trust_paths)

        # Sort by priority (CRITICAL first)
        priority_order = {
            ExploitPriority.CRITICAL: 0,
            ExploitPriority.HIGH: 1,
            ExploitPriority.MEDIUM: 2,
            ExploitPriority.LOW: 3,
        }

        paths.sort(key=lambda p: priority_order.get(p.priority, 99))

        self.log(f"Identified {len(paths)} exploitation paths", "success")

        return paths

    def _analyze_single_trust(
            self,
            trust: TrustInfo,
            current_domain: str
    ) -> List[ExploitPath]:
        """
        Analyze a single trust relationship

        Args:
            trust: Trust to analyze
            current_domain: Current domain

        Returns:
            List of possible ExploitPaths
        """
        paths = []

        if trust.category == TrustCategory.PARENT_CHILD:
            paths.extend(self._analyze_parent_child(trust, current_domain))
        elif trust.category == TrustCategory.FOREST:
            paths.extend(self._analyze_forest_trust(trust))
        elif trust.category == TrustCategory.EXTERNAL:
            paths.extend(self._analyze_external_trust(trust))
        else:
            paths.extend(self._analyze_unknown_trust(trust))

        return paths

    def _analyze_parent_child(
            self,
            trust: TrustInfo,
            current_domain: str
    ) -> List[ExploitPath]:
        """
        Analyze parent-child trust exploitation options
        """
        paths = []

        # Determine parent and child
        child_domain, parent_domain = determine_parent_child(
            trust.source_domain,
            trust.target_domain
        )

        # If we're on child, we can escalate to parent (Enterprise Admin)
        if current_domain.lower() == child_domain.lower():
            # Primary method: raiseChild.py (automated)
            path = ExploitPath(
                source_domain=child_domain,
                target_domain=parent_domain,
                method=ExploitMethod.RAISE_CHILD,
                priority=ExploitPriority.CRITICAL,
                description=f"Automated escalation from child to parent using raiseChild.py. "
                            f"Will gain Enterprise Admin in {parent_domain}.",
                trust_info=trust,
                prerequisites=[
                    f"Domain Admin on {child_domain}",
                    "Impacket installed",
                    f"Network access to {parent_domain} DC",
                ],
                mitre_techniques=[
                    "T1134.005 - SID-History Injection",
                    "T1558.001 - Golden Ticket",
                    "T1003.006 - DCSync",
                ],
            )
            paths.append(path)

            # Alternative: Manual SID History injection
            alt_path = ExploitPath(
                source_domain=child_domain,
                target_domain=parent_domain,
                method=ExploitMethod.SID_HISTORY,
                priority=ExploitPriority.HIGH,
                description=f"Manual SID History injection to gain Enterprise Admin. "
                            f"Inject EA SID into user's SID history.",
                trust_info=trust,
                prerequisites=[
                    f"Domain Admin on {child_domain}",
                    "Mimikatz",
                    "Access to DC",
                ],
                mitre_techniques=[
                    "T1134.005 - SID-History Injection",
                ],
            )
            paths.append(alt_path)

        # If we're on parent, we have authority over children
        elif current_domain.lower() == parent_domain.lower():
            path = ExploitPath(
                source_domain=parent_domain,
                target_domain=child_domain,
                method=ExploitMethod.CREDENTIAL_REUSE,
                priority=ExploitPriority.HIGH,
                description=f"As Enterprise Admin in {parent_domain}, "
                            f"you already have full control over {child_domain}.",
                trust_info=trust,
                prerequisites=[
                    f"Enterprise Admin on {parent_domain}",
                ],
                mitre_techniques=[
                    "T1078 - Valid Accounts",
                ],
            )
            paths.append(path)

        return paths

    def _analyze_forest_trust(self, trust: TrustInfo) -> List[ExploitPath]:
        """
        Analyze forest trust exploitation options
        """
        paths = []

        # Primary: Trust key exploitation
        path = ExploitPath(
            source_domain=trust.source_domain,
            target_domain=trust.target_domain,
            method=ExploitMethod.TRUST_KEY,
            priority=ExploitPriority.MEDIUM,
            description=f"Extract trust key and forge inter-realm TGT. "
                        f"Access {trust.target_domain} as authenticated user from {trust.source_domain}. "
                        f"Note: SID filtering likely enabled.",
            trust_info=trust,
            prerequisites=[
                f"Domain Admin on {trust.source_domain}",
                "Impacket or Rubeus",
            ],
            mitre_techniques=[
                "T1558 - Steal or Forge Kerberos Tickets",
                "T1550.001 - Application Access Token",
            ],
        )
        paths.append(path)

        # If SID filtering is disabled, can escalate
        if not trust.sid_filtering_enabled:
            escalation_path = ExploitPath(
                source_domain=trust.source_domain,
                target_domain=trust.target_domain,
                method=ExploitMethod.GOLDEN_TICKET,
                priority=ExploitPriority.CRITICAL,
                description=f"SID filtering DISABLED! Can forge Golden Ticket with "
                            f"ExtraSids to gain Domain Admin in {trust.target_domain}.",
                trust_info=trust,
                prerequisites=[
                    f"Domain Admin on {trust.source_domain}",
                    f"KRBTGT hash from {trust.source_domain}",
                    "Trust key",
                ],
                mitre_techniques=[
                    "T1558.001 - Golden Ticket",
                    "T1134.005 - SID-History Injection",
                ],
            )
            paths.append(escalation_path)

        return paths

    def _analyze_external_trust(self, trust: TrustInfo) -> List[ExploitPath]:
        """
        Analyze external trust exploitation options
        """
        paths = []

        # Similar to forest trust
        path = ExploitPath(
            source_domain=trust.source_domain,
            target_domain=trust.target_domain,
            method=ExploitMethod.TRUST_KEY,
            priority=ExploitPriority.MEDIUM,
            description=f"External trust to {trust.target_domain}. "
                        f"Extract trust key and forge inter-realm tickets.",
            trust_info=trust,
            prerequisites=[
                f"Domain Admin on {trust.source_domain}",
            ],
            mitre_techniques=[
                "T1558 - Steal or Forge Kerberos Tickets",
            ],
        )
        paths.append(path)

        return paths

    def _analyze_unknown_trust(self, trust: TrustInfo) -> List[ExploitPath]:
        """
        Analyze unknown trust type
        """
        path = ExploitPath(
            source_domain=trust.source_domain,
            target_domain=trust.target_domain,
            method=ExploitMethod.TRUST_KEY,
            priority=ExploitPriority.LOW,
            description=f"Unknown trust type to {trust.target_domain}. "
                        f"Manual analysis required.",
            trust_info=trust,
            prerequisites=[
                "Manual investigation",
            ],
            mitre_techniques=[],
        )

        return [path]

    def print_analysis(self, paths: List[ExploitPath]) -> None:
        """
        Print analysis results
        """
        print(f"\n" + "=" * 60)
        print("EXPLOITATION PATH ANALYSIS")
        print("=" * 60)

        if not paths:
            print("\n[*] No exploitation paths identified")
            return

        priority_icons = {
            ExploitPriority.CRITICAL: "ðŸ”´",
            ExploitPriority.HIGH: "ðŸŸ ",
            ExploitPriority.MEDIUM: "ðŸŸ¡",
            ExploitPriority.LOW: "ðŸŸ¢",
        }

        for i, path in enumerate(paths, 1):
            icon = priority_icons.get(path.priority, "âšª")

            print(f"\n[{i}] {icon} [{path.priority.value.upper()}] {path.source_domain} -> {path.target_domain}")
            print(f"    Method: {path.method.value}")
            print(f"    {path.description}")

            if path.prerequisites:
                print(f"    Prerequisites:")
                for prereq in path.prerequisites:
                    print(f"      - {prereq}")

    def get_attack_order(self, paths: List[ExploitPath]) -> List[ExploitPath]:
        """
        Get recommended attack order

        Args:
            paths: All identified paths

        Returns:
            Paths in recommended execution order
        """
        # Prioritize:
        # 1. Parent-child escalations (critical)
        # 2. SID filtering disabled trusts (critical)
        # 3. Forest trusts with keys (medium)
        # 4. Everything else

        ordered = []

        # First: Parent-child with raiseChild
        ordered.extend([
            p for p in paths
            if p.method == ExploitMethod.RAISE_CHILD
        ])

        # Second: SID History injection
        ordered.extend([
            p for p in paths
            if p.method == ExploitMethod.SID_HISTORY and p not in ordered
        ])

        # Third: Golden ticket with ExtraSids
        ordered.extend([
            p for p in paths
            if p.method == ExploitMethod.GOLDEN_TICKET and p not in ordered
        ])

        # Fourth: Trust key exploitation
        ordered.extend([
            p for p in paths
            if p.method == ExploitMethod.TRUST_KEY and p not in ordered
        ])

        # Finally: Everything else
        ordered.extend([
            p for p in paths
            if p not in ordered
        ])

        return ordered