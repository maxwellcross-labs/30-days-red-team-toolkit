"""
Exploitation Data Models
Data structures for automated trust exploitation
"""

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from enum import Enum
from datetime import datetime


class TrustCategory(Enum):
    """Trust relationship categories"""
    PARENT_CHILD = "parent_child"
    FOREST = "forest"
    EXTERNAL = "external"
    SHORTCUT = "shortcut"
    UNKNOWN = "unknown"


class ExploitPriority(Enum):
    """Exploitation priority levels"""
    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"


class ExploitMethod(Enum):
    """Available exploitation methods"""
    SID_HISTORY = "sid_history_injection"
    RAISE_CHILD = "raise_child"
    TRUST_KEY = "trust_key_exploitation"
    GOLDEN_TICKET = "golden_ticket_extrasids"
    CREDENTIAL_REUSE = "credential_reuse"


class ExploitResult(Enum):
    """Exploitation result status"""
    SUCCESS = "success"
    PARTIAL = "partial"
    FAILED = "failed"
    KEY_EXTRACTED = "key_extracted"
    COMMANDS_GENERATED = "commands_generated"
    SKIPPED = "skipped"
    ERROR = "error"


class WorkflowPhase(Enum):
    """Workflow execution phases"""
    INITIALIZATION = "initialization"
    ENUMERATION = "enumeration"
    ANALYSIS = "analysis"
    EXPLOITATION = "exploitation"
    REPORTING = "reporting"
    COMPLETE = "complete"


@dataclass
class Credentials:
    """Credential set for authentication"""
    username: str
    password: str
    domain: str

    @property
    def full_username(self) -> str:
        """Get domain\\username format"""
        return f"{self.domain}\\{self.username}"

    def to_dict(self) -> Dict[str, Any]:
        return {
            "username": self.username,
            "domain": self.domain,
            # Don't include password in serialization
        }


@dataclass
class DomainTarget:
    """Target domain information"""
    name: str
    dc_ip: Optional[str] = None
    dc_hostname: Optional[str] = None
    domain_sid: Optional[str] = None
    is_forest_root: bool = False
    is_compromised: bool = False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "name": self.name,
            "dc_ip": self.dc_ip,
            "dc_hostname": self.dc_hostname,
            "domain_sid": self.domain_sid,
            "is_forest_root": self.is_forest_root,
            "is_compromised": self.is_compromised,
        }


@dataclass
class TrustInfo:
    """Discovered trust relationship"""
    source_domain: str
    target_domain: str
    trust_account: str
    category: TrustCategory

    # Direction and properties
    is_bidirectional: bool = False
    is_transitive: bool = True
    sid_filtering_enabled: bool = True

    # Extracted data
    trust_key: Optional[str] = None
    trust_key_type: Optional[str] = None  # rc4, aes128, aes256

    @property
    def is_exploitable(self) -> bool:
        """Check if trust has exploitable characteristics"""
        if self.category == TrustCategory.PARENT_CHILD:
            return True  # Always exploitable
        if not self.sid_filtering_enabled:
            return True
        if self.trust_key:
            return True
        return False

    def to_dict(self) -> Dict[str, Any]:
        return {
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "trust_account": self.trust_account,
            "category": self.category.value,
            "is_bidirectional": self.is_bidirectional,
            "is_transitive": self.is_transitive,
            "sid_filtering_enabled": self.sid_filtering_enabled,
            "trust_key": self.trust_key[:8] + "..." if self.trust_key else None,
            "is_exploitable": self.is_exploitable,
        }


@dataclass
class ExploitPath:
    """Identified exploitation path"""
    source_domain: str
    target_domain: str
    method: ExploitMethod
    priority: ExploitPriority
    description: str

    # Associated trust
    trust_info: Optional[TrustInfo] = None

    # Prerequisites
    prerequisites: List[str] = field(default_factory=list)

    # MITRE mapping
    mitre_techniques: List[str] = field(default_factory=list)

    def to_dict(self) -> Dict[str, Any]:
        return {
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "method": self.method.value,
            "priority": self.priority.value,
            "description": self.description,
            "prerequisites": self.prerequisites,
            "mitre_techniques": self.mitre_techniques,
        }


@dataclass
class ExploitAttempt:
    """Record of an exploitation attempt"""
    source_domain: str
    target_domain: str
    method: ExploitMethod
    result: ExploitResult

    # Timing
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    # Results
    trust_key_extracted: Optional[str] = None
    commands_generated: List[str] = field(default_factory=list)
    output_file: Optional[str] = None
    error_message: Optional[str] = None

    # What was gained
    access_gained: Optional[str] = None  # e.g., "Enterprise Admin"

    @property
    def duration(self) -> Optional[float]:
        """Get duration in seconds"""
        if self.started_at and self.completed_at:
            return (self.completed_at - self.started_at).total_seconds()
        return None

    @property
    def is_successful(self) -> bool:
        """Check if attempt was successful"""
        return self.result in [ExploitResult.SUCCESS, ExploitResult.KEY_EXTRACTED]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "method": self.method.value,
            "result": self.result.value,
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
            "duration_seconds": self.duration,
            "trust_key_extracted": bool(self.trust_key_extracted),
            "access_gained": self.access_gained,
            "error_message": self.error_message,
        }


@dataclass
class WorkflowState:
    """Current state of the exploitation workflow"""
    phase: WorkflowPhase = WorkflowPhase.INITIALIZATION

    # Initial configuration
    initial_domain: Optional[str] = None
    initial_credentials: Optional[Credentials] = None
    dc_ip: Optional[str] = None

    # Discovered data
    domains: Dict[str, DomainTarget] = field(default_factory=dict)
    trusts: List[TrustInfo] = field(default_factory=list)
    exploit_paths: List[ExploitPath] = field(default_factory=list)

    # Execution history
    attempts: List[ExploitAttempt] = field(default_factory=list)

    # Timing
    started_at: Optional[datetime] = None
    completed_at: Optional[datetime] = None

    def add_domain(self, domain: DomainTarget) -> None:
        """Add discovered domain"""
        self.domains[domain.name.lower()] = domain

    def add_trust(self, trust: TrustInfo) -> None:
        """Add discovered trust"""
        self.trusts.append(trust)

    def add_exploit_path(self, path: ExploitPath) -> None:
        """Add identified exploit path"""
        self.exploit_paths.append(path)

    def add_attempt(self, attempt: ExploitAttempt) -> None:
        """Add exploitation attempt"""
        self.attempts.append(attempt)

    @property
    def successful_attempts(self) -> List[ExploitAttempt]:
        """Get successful attempts"""
        return [a for a in self.attempts if a.is_successful]

    @property
    def failed_attempts(self) -> List[ExploitAttempt]:
        """Get failed attempts"""
        return [a for a in self.attempts if not a.is_successful]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "phase": self.phase.value,
            "initial_domain": self.initial_domain,
            "dc_ip": self.dc_ip,
            "domains_discovered": len(self.domains),
            "trusts_discovered": len(self.trusts),
            "exploit_paths_identified": len(self.exploit_paths),
            "attempts_total": len(self.attempts),
            "attempts_successful": len(self.successful_attempts),
            "started_at": self.started_at.isoformat() if self.started_at else None,
            "completed_at": self.completed_at.isoformat() if self.completed_at else None,
        }