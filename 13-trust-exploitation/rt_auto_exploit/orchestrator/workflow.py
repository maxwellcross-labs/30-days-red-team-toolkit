"""
Exploitation Workflow Orchestrator
Coordinates the complete automated trust exploitation workflow
"""

from typing import Optional, List
from pathlib import Path
from datetime import datetime

from ..models import (
    WorkflowState,
    WorkflowPhase,
    Credentials,
    DomainTarget,
    TrustInfo,
    TrustCategory,
    ExploitPath,
    ExploitAttempt,
    ExploitMethod,
    ExploitResult,
)
from ..enumerators import TrustEnumerator
from ..analyzers import PathAnalyzer
from ..exploiters import ParentChildExploiter, ForestTrustExploiter, get_exploiter_for_method
from ..reporters import ReportGenerator


class ExploitationWorkflow:
    """
    Main orchestrator for automated trust exploitation
    Coordinates all phases: enumeration, analysis, exploitation, reporting
    """

    def __init__(
            self,
            output_dir: str = "auto_trust_exploit",
            verbose: bool = True
    ):
        """
        Initialize workflow orchestrator

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose

        # Initialize components
        self.enumerator = TrustEnumerator(output_dir=output_dir, verbose=verbose)
        self.analyzer = PathAnalyzer(verbose=verbose)
        self.pc_exploiter = ParentChildExploiter(output_dir=output_dir, verbose=verbose)
        self.forest_exploiter = ForestTrustExploiter(output_dir=output_dir, verbose=verbose)
        self.reporter = ReportGenerator(output_dir=output_dir, verbose=verbose)

        # Workflow state
        self.state = WorkflowState()

        self.log("Automated Trust Exploitation Framework initialized", "success")
        self.log(f"Output directory: {self.output_dir}")

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def run_full_exploitation(
            self,
            initial_domain: str,
            username: str,
            password: str,
            dc_ip: str,
            auto_exploit: bool = True
    ) -> WorkflowState:
        """
        Run complete automated exploitation workflow

        Args:
            initial_domain: Starting domain (with DA access)
            username: Domain Admin username
            password: Password
            dc_ip: Domain controller IP
            auto_exploit: Whether to automatically exploit (vs just enumerate)

        Returns:
            WorkflowState with all results
        """
        print(f"\n" + "=" * 60)
        print("AUTOMATED TRUST EXPLOITATION")
        print("=" * 60)

        self.state.started_at = datetime.now()
        self.state.initial_domain = initial_domain
        self.state.dc_ip = dc_ip
        self.state.initial_credentials = Credentials(
            username=username,
            password=password,
            domain=initial_domain
        )

        # Register initial domain
        initial = DomainTarget(
            name=initial_domain,
            dc_ip=dc_ip,
            is_compromised=True
        )
        self.state.add_domain(initial)

        try:
            # Phase 1: Enumerate trusts
            self._run_enumeration_phase(initial_domain, username, password, dc_ip)

            # Phase 2: Analyze paths
            self._run_analysis_phase(initial_domain)

            # Phase 3: Exploitation
            if auto_exploit and self.state.exploit_paths:
                self._run_exploitation_phase(username, password, dc_ip)

            # Phase 4: Reporting
            self._run_reporting_phase()

        except Exception as e:
            self.log(f"Workflow error: {e}", "error")
            self.state.phase = WorkflowPhase.COMPLETE

        self.state.completed_at = datetime.now()
        self.state.phase = WorkflowPhase.COMPLETE

        return self.state

    def _run_enumeration_phase(
            self,
            domain: str,
            username: str,
            password: str,
            dc_ip: str
    ) -> None:
        """Execute enumeration phase"""
        print(f"\n[PHASE 1] Trust Enumeration")
        print("-" * 60)

        self.state.phase = WorkflowPhase.ENUMERATION

        trusts = self.enumerator.enumerate_all(domain, username, password, dc_ip)

        for trust in trusts:
            self.state.add_trust(trust)

            # Register target domain
            target = DomainTarget(
                name=trust.target_domain,
                is_forest_root=(trust.category == TrustCategory.PARENT_CHILD and
                                domain.endswith('.' + trust.target_domain))
            )
            self.state.add_domain(target)

        self.log(f"Enumeration complete: {len(trusts)} trusts found", "success")

    def _run_analysis_phase(self, current_domain: str) -> None:
        """Execute analysis phase"""
        print(f"\n[PHASE 2] Exploitation Path Analysis")
        print("-" * 60)

        self.state.phase = WorkflowPhase.ANALYSIS

        paths = self.analyzer.analyze_trusts(self.state.trusts, current_domain)

        for path in paths:
            self.state.add_exploit_path(path)

        # Print analysis
        self.analyzer.print_analysis(paths)

        self.log(f"Analysis complete: {len(paths)} paths identified", "success")

    def _run_exploitation_phase(
            self,
            username: str,
            password: str,
            dc_ip: str
    ) -> None:
        """Execute exploitation phase"""
        print(f"\n[PHASE 3] Exploitation")
        print("-" * 60)

        self.state.phase = WorkflowPhase.EXPLOITATION

        # Get ordered paths
        ordered_paths = self.analyzer.get_attack_order(self.state.exploit_paths)

        for path in ordered_paths:
            self.log(f"\nExploiting: {path.source_domain} -> {path.target_domain}")
            self.log(f"Method: {path.method.value}")

            attempt = self._exploit_path(path, username, password, dc_ip)
            self.state.add_attempt(attempt)

            # If we gained EA, we might want to stop or continue
            if attempt.access_gained == "Enterprise Admin":
                self.log("Enterprise Admin achieved!", "success")
                # Continue to exploit other trusts for maximum access

    def _exploit_path(
            self,
            path: ExploitPath,
            username: str,
            password: str,
            dc_ip: str
    ) -> ExploitAttempt:
        """
        Execute exploitation for a single path
        """
        if path.method in [ExploitMethod.RAISE_CHILD, ExploitMethod.SID_HISTORY]:
            return self.pc_exploiter.exploit(path, username, password, dc_ip)
        elif path.method in [ExploitMethod.TRUST_KEY, ExploitMethod.GOLDEN_TICKET]:
            return self.forest_exploiter.exploit(path, username, password, dc_ip)
        else:
            # Generate commands only
            self.log(f"Method {path.method.value} requires manual exploitation", "warning")

            return ExploitAttempt(
                source_domain=path.source_domain,
                target_domain=path.target_domain,
                method=path.method,
                result=ExploitResult.SKIPPED,
                started_at=datetime.now(),
                completed_at=datetime.now(),
                error_message="Manual exploitation required",
            )

    def _run_reporting_phase(self) -> None:
        """Execute reporting phase"""
        print(f"\n[PHASE 4] Reporting")
        print("-" * 60)

        self.state.phase = WorkflowPhase.REPORTING

        # Generate reports
        self.reporter.generate_json_report(self.state)
        self.reporter.generate_text_report(self.state)

        # Print summary
        self.reporter.print_summary(self.state)

    def enumerate_only(
            self,
            domain: str,
            username: str,
            password: str,
            dc_ip: str
    ) -> List[TrustInfo]:
        """
        Run enumeration only (no exploitation)

        Args:
            domain: Target domain
            username: Username
            password: Password
            dc_ip: DC IP

        Returns:
            List of discovered trusts
        """
        self.state.initial_domain = domain
        self.state.dc_ip = dc_ip

        self._run_enumeration_phase(domain, username, password, dc_ip)
        self._run_analysis_phase(domain)

        return self.state.trusts

    def exploit_single_trust(
            self,
            trust: TrustInfo,
            username: str,
            password: str,
            dc_ip: str
    ) -> ExploitAttempt:
        """
        Exploit a single trust relationship

        Args:
            trust: TrustInfo to exploit
            username: Username
            password: Password
            dc_ip: DC IP

        Returns:
            ExploitAttempt with results
        """
        # Analyze this specific trust
        paths = self.analyzer.analyze_trusts([trust], trust.source_domain)

        if not paths:
            return ExploitAttempt(
                source_domain=trust.source_domain,
                target_domain=trust.target_domain,
                method=ExploitMethod.TRUST_KEY,
                result=ExploitResult.SKIPPED,
                error_message="No exploitation path identified",
            )

        # Exploit first (highest priority) path
        return self._exploit_path(paths[0], username, password, dc_ip)

    def get_state(self) -> WorkflowState:
        """Get current workflow state"""
        return self.state

    def reset(self) -> None:
        """Reset workflow state"""
        self.state = WorkflowState()
        self.log("Workflow state reset", "info")