"""
Exploitation Report Generator
Generate comprehensive reports from exploitation workflow
"""

import json
from typing import Optional, List, Dict, Any
from pathlib import Path
from datetime import datetime

from ..models import (
    WorkflowState,
    TrustInfo,
    ExploitPath,
    ExploitAttempt,
    ExploitResult,
    ExploitPriority,
)


class ReportGenerator:
    """
    Generate reports from exploitation workflow results
    """

    def __init__(self, output_dir: str = "auto_trust_exploit", verbose: bool = True):
        """
        Initialize report generator

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def generate_json_report(self, state: WorkflowState) -> Path:
        """
        Generate JSON report

        Args:
            state: WorkflowState with all data

        Returns:
            Path to JSON report
        """
        report = {
            "report_type": "Trust Exploitation Report",
            "generated_at": datetime.now().isoformat(),
            "framework": "RT Auto Exploit Framework",
            "version": "1.0.0",
            "workflow_summary": state.to_dict(),
            "trusts_discovered": [t.to_dict() for t in state.trusts],
            "exploit_paths": [p.to_dict() for p in state.exploit_paths],
            "exploitation_attempts": [a.to_dict() for a in state.attempts],
            "statistics": self._calculate_statistics(state),
        }

        filepath = self.output_dir / f"exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"

        with open(filepath, 'w') as f:
            json.dump(report, f, indent=2, default=str)

        self.log(f"JSON report saved to: {filepath}", "success")

        return filepath

    def generate_text_report(self, state: WorkflowState) -> Path:
        """
        Generate human-readable text report

        Args:
            state: WorkflowState with all data

        Returns:
            Path to text report
        """
        lines = self._build_text_report(state)

        filepath = self.output_dir / f"exploitation_report_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        filepath.write_text("\n".join(lines))

        self.log(f"Text report saved to: {filepath}", "success")

        return filepath

    def _build_text_report(self, state: WorkflowState) -> List[str]:
        """Build text report lines"""
        lines = [
            "=" * 70,
            "AUTOMATED TRUST EXPLOITATION REPORT",
            "=" * 70,
            f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            f"Framework: RT Auto Exploit v1.0.0",
            "",
        ]

        # Executive Summary
        stats = self._calculate_statistics(state)

        lines.extend([
            "EXECUTIVE SUMMARY",
            "-" * 40,
            f"Initial Domain: {state.initial_domain}",
            f"Trusts Discovered: {stats['trusts_total']}",
            f"Exploitation Attempts: {stats['attempts_total']}",
            f"Successful Exploits: {stats['attempts_successful']}",
            f"Access Gained: {', '.join(stats['access_gained']) if stats['access_gained'] else 'None'}",
            "",
        ])

        # Trusts Discovered
        lines.extend([
            "TRUSTS DISCOVERED",
            "-" * 40,
        ])

        if state.trusts:
            for i, trust in enumerate(state.trusts, 1):
                lines.append(f"\n[{i}] {trust.source_domain} -> {trust.target_domain}")
                lines.append(f"    Category: {trust.category.value}")
                lines.append(f"    Bidirectional: {trust.is_bidirectional}")
                lines.append(f"    Trust Key: {'Extracted' if trust.trust_key else 'Not extracted'}")
        else:
            lines.append("  No trusts discovered")

        lines.append("")

        # Exploitation Paths
        lines.extend([
            "EXPLOITATION PATHS IDENTIFIED",
            "-" * 40,
        ])

        if state.exploit_paths:
            priority_icons = {
                ExploitPriority.CRITICAL: "[CRITICAL]",
                ExploitPriority.HIGH: "[HIGH]",
                ExploitPriority.MEDIUM: "[MEDIUM]",
                ExploitPriority.LOW: "[LOW]",
            }

            for i, path in enumerate(state.exploit_paths, 1):
                icon = priority_icons.get(path.priority, "[?]")
                lines.append(f"\n[{i}] {icon} {path.source_domain} -> {path.target_domain}")
                lines.append(f"    Method: {path.method.value}")
                lines.append(f"    {path.description}")
        else:
            lines.append("  No exploitation paths identified")

        lines.append("")

        # Exploitation Attempts
        lines.extend([
            "EXPLOITATION ATTEMPTS",
            "-" * 40,
        ])

        if state.attempts:
            for i, attempt in enumerate(state.attempts, 1):
                result_icon = "✓" if attempt.is_successful else "✗"
                lines.append(f"\n[{i}] {result_icon} {attempt.source_domain} -> {attempt.target_domain}")
                lines.append(f"    Method: {attempt.method.value}")
                lines.append(f"    Result: {attempt.result.value}")

                if attempt.access_gained:
                    lines.append(f"    Access Gained: {attempt.access_gained}")

                if attempt.trust_key_extracted:
                    lines.append(f"    Trust Key: {attempt.trust_key_extracted[:16]}...")

                if attempt.error_message:
                    lines.append(f"    Error: {attempt.error_message}")

                if attempt.duration:
                    lines.append(f"    Duration: {attempt.duration:.1f}s")
        else:
            lines.append("  No exploitation attempts")

        lines.append("")

        # Recommendations
        lines.extend([
            "RECOMMENDATIONS",
            "-" * 40,
        ])

        recommendations = self._generate_recommendations(state)
        for rec in recommendations:
            lines.append(f"  • {rec}")

        lines.extend([
            "",
            "=" * 70,
            "END OF REPORT",
            "=" * 70,
        ])

        return lines

    def _calculate_statistics(self, state: WorkflowState) -> Dict[str, Any]:
        """Calculate exploitation statistics"""
        successful = [a for a in state.attempts if a.is_successful]

        return {
            "trusts_total": len(state.trusts),
            "trusts_parent_child": len([t for t in state.trusts if t.category.value == "parent_child"]),
            "trusts_forest": len([t for t in state.trusts if t.category.value == "forest"]),
            "paths_total": len(state.exploit_paths),
            "paths_critical": len([p for p in state.exploit_paths if p.priority == ExploitPriority.CRITICAL]),
            "attempts_total": len(state.attempts),
            "attempts_successful": len(successful),
            "attempts_failed": len([a for a in state.attempts if not a.is_successful]),
            "keys_extracted": len([a for a in state.attempts if a.trust_key_extracted]),
            "access_gained": [a.access_gained for a in successful if a.access_gained],
        }

    def _generate_recommendations(self, state: WorkflowState) -> List[str]:
        """Generate recommendations based on results"""
        recommendations = []

        # Check for unexploited paths
        exploited_targets = {a.target_domain for a in state.attempts}
        unexploited = [p for p in state.exploit_paths if p.target_domain not in exploited_targets]

        if unexploited:
            recommendations.append(
                f"{len(unexploited)} exploitation path(s) remain unexplored"
            )

        # Check for failed attempts
        failed = [a for a in state.attempts if not a.is_successful]
        if failed:
            recommendations.append(
                f"Investigate {len(failed)} failed attempt(s) - may require manual exploitation"
            )

        # Check for extracted keys
        keys = [a for a in state.attempts if a.trust_key_extracted]
        if keys:
            recommendations.append(
                f"Use {len(keys)} extracted trust key(s) for inter-realm ticket forging"
            )

        # General recommendations
        if not state.attempts:
            recommendations.append("Run exploitation phase to test identified paths")

        if any(a.access_gained == "Enterprise Admin" for a in state.attempts):
            recommendations.append(
                "Enterprise Admin achieved! Proceed with domain dominance objectives"
            )

        return recommendations if recommendations else ["No specific recommendations"]

    def print_summary(self, state: WorkflowState) -> None:
        """
        Print exploitation summary to console
        """
        stats = self._calculate_statistics(state)

        print(f"\n" + "=" * 60)
        print("TRUST EXPLOITATION SUMMARY")
        print("=" * 60)

        print(f"\n[*] Trusts discovered: {stats['trusts_total']}")
        print(f"    - Parent-child: {stats['trusts_parent_child']}")
        print(f"    - Forest: {stats['trusts_forest']}")

        print(f"\n[*] Exploitation paths: {stats['paths_total']}")
        print(f"    - Critical priority: {stats['paths_critical']}")

        print(f"\n[*] Attempts: {stats['attempts_total']}")
        print(f"    - Successful: {stats['attempts_successful']}")
        print(f"    - Failed: {stats['attempts_failed']}")

        if stats['keys_extracted']:
            print(f"\n[+] Trust keys extracted: {stats['keys_extracted']}")

        if stats['access_gained']:
            print(f"\n[+] Access gained:")
            for access in stats['access_gained']:
                print(f"    - {access}")