"""
Output Parsing Utilities
Parse output from various tools used in exploitation
"""

import re
from typing import Optional, List, Dict, Any, Tuple


def parse_secretsdump_trusts(output: str) -> List[Dict[str, Any]]:
    """
    Parse secretsdump.py output for trust accounts

    Args:
        output: Raw secretsdump output

    Returns:
        List of trust account dictionaries
    """
    trusts = []

    # Pattern for trust accounts: DOMAIN$:RID:LMHASH:NTHASH:::
    # Trust accounts end with $
    pattern = r'^([A-Z0-9_-]+)\$:(\d+):([a-fA-F0-9]{32}):([a-fA-F0-9]{32}):::'

    for line in output.split('\n'):
        line = line.strip()
        match = re.match(pattern, line, re.IGNORECASE)

        if match:
            account_name = match.group(1)
            rid = match.group(2)
            lm_hash = match.group(3)
            nt_hash = match.group(4)

            trust_info = {
                "account_name": f"{account_name}$",
                "target_domain": account_name.lower(),
                "rid": int(rid),
                "lm_hash": lm_hash if lm_hash != "aad3b435b51404eeaad3b435b51404ee" else None,
                "nt_hash": nt_hash,
            }

            trusts.append(trust_info)

    return trusts


def parse_secretsdump_keys(output: str, account_name: str) -> Dict[str, Optional[str]]:
    """
    Parse secretsdump output for a specific account's keys

    Args:
        output: Raw secretsdump output
        account_name: Account to extract keys for

    Returns:
        Dictionary with ntlm, aes256, aes128 keys
    """
    keys = {
        "ntlm": None,
        "aes256": None,
        "aes128": None,
    }

    # Find NTLM hash
    ntlm_pattern = rf'{re.escape(account_name)}:\d+:[a-fA-F0-9]{{32}}:([a-fA-F0-9]{{32}}):::'
    ntlm_match = re.search(ntlm_pattern, output, re.IGNORECASE)
    if ntlm_match:
        keys["ntlm"] = ntlm_match.group(1)

    # Find AES keys (from supplemental credentials)
    aes256_pattern = r'aes256-cts-hmac-sha1-96\s*:\s*([a-fA-F0-9]{64})'
    aes256_match = re.search(aes256_pattern, output, re.IGNORECASE)
    if aes256_match:
        keys["aes256"] = aes256_match.group(1)

    aes128_pattern = r'aes128-cts-hmac-sha1-96\s*:\s*([a-fA-F0-9]{32})'
    aes128_match = re.search(aes128_pattern, output, re.IGNORECASE)
    if aes128_match:
        keys["aes128"] = aes128_match.group(1)

    return keys


def parse_raise_child_output(output: str) -> Dict[str, Any]:
    """
    Parse raiseChild.py output for results

    Args:
        output: Raw raiseChild.py output

    Returns:
        Dictionary with parsing results
    """
    result = {
        "success": False,
        "krbtgt_hash": None,
        "enterprise_admin": False,
        "target_domain": None,
        "errors": [],
    }

    # Check for success indicators
    if "Enterprise Admin" in output or "519" in output:
        result["enterprise_admin"] = True
        result["success"] = True

    # Look for KRBTGT hash
    krbtgt_pattern = r'krbtgt.*:([a-fA-F0-9]{32})'
    krbtgt_match = re.search(krbtgt_pattern, output, re.IGNORECASE)
    if krbtgt_match:
        result["krbtgt_hash"] = krbtgt_match.group(1)
        result["success"] = True

    # Look for target domain
    domain_pattern = r'Target Domain\s*:\s*(\S+)'
    domain_match = re.search(domain_pattern, output)
    if domain_match:
        result["target_domain"] = domain_match.group(1)

    # Look for errors
    error_patterns = [
        r'error[:\s]+(.+)',
        r'failed[:\s]+(.+)',
        r'exception[:\s]+(.+)',
    ]

    for pattern in error_patterns:
        for match in re.finditer(pattern, output, re.IGNORECASE):
            result["errors"].append(match.group(1).strip())

    return result


def parse_domain_sid(output: str) -> Optional[str]:
    """
    Parse domain SID from various tool outputs

    Args:
        output: Tool output containing SID

    Returns:
        Domain SID or None
    """
    # Pattern for domain SID: S-1-5-21-xxx-xxx-xxx
    sid_pattern = r'(S-1-5-21-\d+-\d+-\d+)'
    match = re.search(sid_pattern, output)

    if match:
        return match.group(1)

    return None


def categorize_trust(source_domain: str, target_domain: str) -> str:
    """
    Categorize trust relationship based on domain names

    Args:
        source_domain: Source domain FQDN
        target_domain: Target domain FQDN

    Returns:
        Trust category string
    """
    source_lower = source_domain.lower()
    target_lower = target_domain.lower()

    # Parent-child: one domain is subdomain of other
    if target_lower.endswith('.' + source_lower):
        return "parent_child"  # Source is parent
    elif source_lower.endswith('.' + target_lower):
        return "parent_child"  # Target is parent

    # Check if they share a common root (forest trust)
    source_parts = source_lower.split('.')
    target_parts = target_lower.split('.')

    # Different TLDs likely means external/forest trust
    if source_parts[-1] != target_parts[-1]:
        return "external"

    # Same TLD but different domain = forest trust
    return "forest"


def determine_parent_child(source_domain: str, target_domain: str) -> Tuple[str, str]:
    """
    Determine which domain is parent and which is child

    Args:
        source_domain: First domain
        target_domain: Second domain

    Returns:
        Tuple of (child_domain, parent_domain)
    """
    source_lower = source_domain.lower()
    target_lower = target_domain.lower()

    if target_lower.endswith('.' + source_lower):
        # Target is child of source
        return target_domain, source_domain
    elif source_lower.endswith('.' + target_lower):
        # Source is child of target
        return source_domain, target_domain
    else:
        # Can't determine - return as-is
        return source_domain, target_domain


def extract_ntlm_from_line(line: str) -> Optional[str]:
    """
    Extract NTLM hash from a secretsdump output line

    Args:
        line: Single line of output

    Returns:
        NTLM hash or None
    """
    # Pattern: account:rid:lmhash:nthash:::
    pattern = r':(\d+):([a-fA-F0-9]{32}):([a-fA-F0-9]{32}):::'
    match = re.search(pattern, line)

    if match:
        return match.group(3)  # NT hash is third group

    return None


def validate_hash(hash_value: str, expected_length: int = 32) -> bool:
    """
    Validate a hash value format

    Args:
        hash_value: Hash string to validate
        expected_length: Expected length in characters

    Returns:
        True if valid
    """
    if not hash_value:
        return False

    pattern = f'^[a-fA-F0-9]{{{expected_length}}}$'
    return bool(re.match(pattern, hash_value))