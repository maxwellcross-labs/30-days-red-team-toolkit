"""
Base Exploiter Class
Abstract base for trust exploitation methods
"""

from abc import ABC, abstractmethod
from typing import Optional, List
from pathlib import Path

from ..models import ExploitPath, ExploitAttempt, ExploitResult


class BaseExploiter(ABC):
    """
    Abstract base class for trust exploiters
    """

    def __init__(self, output_dir: str = "auto_trust_exploit", verbose: bool = True):
        """
        Initialize exploiter

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose
        self.name = self.__class__.__name__
        self.timeout = 120

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {
            "info": "[*]",
            "success": "[+]",
            "error": "[-]",
            "warning": "[!]",
        }
        prefix = prefixes.get(level, "[*]")
        print(f"{prefix} {message}")

    @abstractmethod
    def exploit(
            self,
            path: ExploitPath,
            username: str,
            password: str,
            dc_ip: str
    ) -> ExploitAttempt:
        """
        Execute exploitation

        Args:
            path: ExploitPath to execute
            username: Username for authentication
            password: Password
            dc_ip: Domain controller IP

        Returns:
            ExploitAttempt with results
        """
        pass

    @abstractmethod
    def generate_commands(
            self,
            path: ExploitPath,
            username: str,
            dc_ip: str
    ) -> List[str]:
        """
        Generate exploitation commands without executing

        Args:
            path: ExploitPath
            username: Username
            dc_ip: Domain controller IP

        Returns:
            List of command strings
        """
        pass

    @abstractmethod
    def is_available(self) -> bool:
        """
        Check if required tools are available

        Returns:
            True if exploiter can run
        """
        pass

    def save_commands(
            self,
            commands: List[str],
            path: ExploitPath
    ) -> Path:
        """
        Save generated commands to file
        """
        filename = f"{self.name.lower()}_{path.source_domain}_to_{path.target_domain}.txt"
        filepath = self.output_dir / filename

        with open(filepath, 'w') as f:
            f.write(f"# {self.name} Exploitation Commands\n")
            f.write(f"# Source: {path.source_domain}\n")
            f.write(f"# Target: {path.target_domain}\n")
            f.write(f"# Method: {path.method.value}\n")
            f.write(f"# Generated by RT Auto Exploit Framework\n\n")

            for cmd in commands:
                f.write(f"{cmd}\n")

        self.log(f"Commands saved to: {filepath}", "success")

        return filepath