"""
Trust Enumeration Framework
Main orchestrator for AD trust enumeration operations
"""

from pathlib import Path
from typing import Optional, List, Dict, Any

from .models.trust import TrustCollection
from .enumerators import (
    PowerViewEnumerator,
    LDAPEnumerator,
    ImpacketEnumerator,
    get_available_enumerators
)
from .analysis.attack_paths import AttackPathAnalyzer, AttackPath
from .analysis.visualizer import TrustVisualizer
from .reporters.json_reporter import JSONReporter


class TrustEnumerationFramework:
    """
    Main framework for AD trust enumeration
    Coordinates enumerators, analysis, and reporting
    """

    def __init__(
            self,
            output_dir: str = "trust_enum",
            verbose: bool = True
    ):
        """
        Initialize trust enumeration framework

        Args:
            output_dir: Directory for output files
            verbose: Print status messages
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)
        self.verbose = verbose

        # Initialize collection
        self.collection = TrustCollection()

        # Initialize components
        self.visualizer = TrustVisualizer(verbose=verbose)
        self.analyzer = AttackPathAnalyzer(verbose=verbose)
        self.reporter = JSONReporter(output_dir=output_dir)

        # Attack paths (populated after analysis)
        self.attack_paths: List[AttackPath] = []

        self.log("Trust Enumeration Framework initialized", "success")
        self.log(f"Output directory: {self.output_dir}")

    def log(self, message: str, level: str = "info") -> None:
        """Print status message"""
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def enumerate_trusts_powerview(
            self,
            domain: str,
            username: Optional[str] = None,
            password: Optional[str] = None,
            dc: Optional[str] = None
    ) -> int:
        """
        Enumerate trusts using PowerView

        Args:
            domain: Target domain
            username: Username
            password: Password
            dc: Domain controller

        Returns:
            Number of trusts found
        """
        enumerator = PowerViewEnumerator(verbose=self.verbose)

        if not enumerator.is_available():
            self.log("PowerShell not available", "error")
            return 0

        return enumerator.enumerate_to_collection(
            self.collection, domain, username, password, dc
        )

    def enumerate_trusts_ldap(
            self,
            domain: str,
            username: Optional[str] = None,
            password: Optional[str] = None,
            dc: Optional[str] = None
    ) -> int:
        """
        Enumerate trusts via LDAP

        Args:
            domain: Target domain
            username: Username
            password: Password
            dc: Domain controller

        Returns:
            Number of trusts found
        """
        enumerator = LDAPEnumerator(verbose=self.verbose)

        if not enumerator.is_available():
            self.log("ldap3 library not available", "error")
            return 0

        return enumerator.enumerate_to_collection(
            self.collection, domain, username, password, dc
        )

    def enumerate_trusts_impacket(
            self,
            domain: str,
            username: str,
            password: str,
            dc: Optional[str] = None
    ) -> int:
        """
        Enumerate trusts using Impacket

        Args:
            domain: Target domain
            username: Username (required)
            password: Password (required)
            dc: Domain controller

        Returns:
            Number of trusts found
        """
        enumerator = ImpacketEnumerator(verbose=self.verbose)

        if not enumerator.is_available():
            self.log("Impacket wmiexec not available", "error")
            return 0

        return enumerator.enumerate_to_collection(
            self.collection, domain, username, password, dc
        )

    def enumerate_all(
            self,
            domain: str,
            username: Optional[str] = None,
            password: Optional[str] = None,
            dc: Optional[str] = None
    ) -> int:
        """
        Run all available enumeration methods

        Args:
            domain: Target domain
            username: Username
            password: Password
            dc: Domain controller

        Returns:
            Total trusts found
        """
        self.log(f"Running all available enumeration methods for {domain}...")

        available = get_available_enumerators()
        self.log(f"Available methods: {', '.join(available.keys())}")

        total = 0

        if "powerview" in available:
            total += self.enumerate_trusts_powerview(domain, username, password, dc)

        if "ldap" in available:
            total += self.enumerate_trusts_ldap(domain, username, password, dc)

        if "impacket" in available and username and password:
            total += self.enumerate_trusts_impacket(domain, username, password, dc)

        return total

    def enumerate_child_domains(
            self,
            domain: str,
            username: Optional[str] = None,
            password: Optional[str] = None
    ) -> List[str]:
        """
        Enumerate child domains in forest

        Args:
            domain: Parent domain
            username: Username
            password: Password

        Returns:
            List of domain names
        """
        enumerator = PowerViewEnumerator(verbose=self.verbose)

        if enumerator.is_available():
            domains = enumerator.enumerate_forest_domains(domain, username, password)

            # Add to collection tracking
            for d in domains:
                if d not in self.collection.domains_found:
                    self.collection.domains_found.append(d)

            return domains

        return []

    def visualize_trust_relationships(self) -> None:
        """Print visual trust map"""
        self.visualizer.print_trust_map(self.collection)

    def identify_attack_paths(self) -> List[AttackPath]:
        """
        Analyze trusts for attack paths

        Returns:
            List of AttackPath objects
        """
        self.attack_paths = self.analyzer.analyze(self.collection)
        return self.attack_paths

    def print_attack_paths(self) -> None:
        """Print attack path analysis"""
        if not self.attack_paths:
            self.identify_attack_paths()

        self.analyzer.print_attack_paths()

    def generate_report(
            self,
            metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Generate and save comprehensive report

        Args:
            metadata: Additional metadata to include

        Returns:
            Report dictionary
        """
        # Ensure attack paths are analyzed
        if not self.attack_paths:
            self.identify_attack_paths()

        # Generate report
        report = self.reporter.generate_report(
            self.collection,
            self.attack_paths,
            metadata
        )

        # Save JSON report
        self.reporter.save_report(report)

        # Save executive summary
        self.reporter.save_executive_summary(
            self.collection,
            self.attack_paths
        )

        # Save visualizations
        self.visualizer.save_visualization(
            self.collection,
            self.output_dir
        )

        return report

    @property
    def trusts(self) -> TrustCollection:
        """Get trust collection"""
        return self.collection

    @property
    def domains_found(self) -> List[str]:
        """Get list of discovered domains"""
        return self.collection.domains_found