"""
Trust Relationship Visualizer
Create visual representations of trust maps
"""

from typing import Optional
from pathlib import Path

from ..models.trust import Trust, TrustCollection, TrustCategory
from ..utils.converters import get_direction_symbol


class TrustVisualizer:
    """
    Visualize trust relationships in various formats
    """

    def __init__(self, verbose: bool = True):
        self.verbose = verbose

    def log(self, message: str) -> None:
        if self.verbose:
            print(f"[*] {message}")

    def print_trust_map(self, collection: TrustCollection) -> None:
        """
        Print ASCII trust relationship map

        Args:
            collection: TrustCollection to visualize
        """
        print("\n" + "=" * 70)
        print("TRUST RELATIONSHIP MAP")
        print("=" * 70)

        if not collection.trusts:
            print("\n[*] No trusts found")
            return

        print(f"\n[*] Total trusts found: {collection.count}")
        print(f"[*] Domains discovered: {len(collection.domains_found)}")

        # Print domains
        print(f"\n  Domains:")
        for domain in collection.domains_found:
            print(f"    • {domain}")

        # Parent-Child Trusts
        if collection.parent_child:
            self._print_trust_section(
                "PARENT-CHILD TRUSTS (Within Forest)",
                collection.parent_child
            )

        # Forest Trusts
        if collection.forest:
            self._print_trust_section(
                "FOREST TRUSTS (Between Forests)",
                collection.forest
            )

        # External Trusts
        if collection.external:
            self._print_trust_section(
                "EXTERNAL/SHORTCUT TRUSTS",
                collection.external
            )

    def _print_trust_section(self, title: str, trusts: list) -> None:
        """Print a section of trusts"""
        print(f"\n" + "=" * 70)
        print(title)
        print("=" * 70)

        for trust in trusts:
            symbol = get_direction_symbol(trust.trust_direction)

            print(f"\n  {trust.source_domain} {symbol} {trust.target_domain}")
            print(f"  Type: {trust.trust_type}")
            print(f"  Direction: {trust.trust_direction}")

            if trust.sid_filtering_enabled:
                print(f"  SID Filtering: Enabled")
            else:
                print(f"  SID Filtering: DISABLED - EXPLOITABLE!")

            if trust.is_exploitable:
                print(f"  ⚠️  HIGH VALUE TARGET")

    def generate_mermaid(self, collection: TrustCollection) -> str:
        """
        Generate Mermaid diagram markup

        Args:
            collection: TrustCollection to visualize

        Returns:
            Mermaid diagram string
        """
        lines = ["graph LR"]

        # Add styling
        lines.append("    classDef exploitable fill:#ff6b6b,stroke:#c0392b,stroke-width:2px")
        lines.append("    classDef normal fill:#74b9ff,stroke:#2980b9")
        lines.append("    classDef forest fill:#55efc4,stroke:#00b894")

        for i, trust in enumerate(collection.trusts):
            source = trust.source_domain.replace(".", "_")
            target = trust.target_domain.replace(".", "_")

            # Determine arrow type
            if "Bidirectional" in trust.trust_direction:
                arrow = "<-->"
            elif "Inbound" in trust.trust_direction:
                arrow = "<--"
            else:
                arrow = "-->"

            # Add edge with label
            label = trust.category.value.replace("_", " ").title()
            lines.append(f"    {source}[{trust.source_domain}] {arrow}|{label}| {target}[{trust.target_domain}]")

            # Style exploitable trusts
            if trust.is_exploitable:
                lines.append(f"    class {source},{target} exploitable")
            elif trust.category == TrustCategory.FOREST:
                lines.append(f"    class {source},{target} forest")

        return "\n".join(lines)

    def generate_graphviz(self, collection: TrustCollection) -> str:
        """
        Generate Graphviz DOT format

        Args:
            collection: TrustCollection to visualize

        Returns:
            DOT format string
        """
        lines = [
            "digraph TrustMap {",
            "    rankdir=LR;",
            "    node [shape=box, style=filled];",
            '    edge [fontsize=10];',
            "",
        ]

        # Add domain nodes
        for domain in collection.domains_found:
            safe_name = domain.replace(".", "_")
            lines.append(f'    {safe_name} [label="{domain}", fillcolor=lightblue];')

        lines.append("")

        # Add trust edges
        for trust in collection.trusts:
            source = trust.source_domain.replace(".", "_")
            target = trust.target_domain.replace(".", "_")

            # Edge attributes
            attrs = [f'label="{trust.category.value}"']

            if "Bidirectional" in trust.trust_direction:
                attrs.append("dir=both")
            elif "Inbound" in trust.trust_direction:
                attrs.append("dir=back")

            if trust.is_exploitable:
                attrs.append("color=red")
                attrs.append("penwidth=2")

            attr_str = ", ".join(attrs)
            lines.append(f"    {source} -> {target} [{attr_str}];")

        lines.append("}")

        return "\n".join(lines)

    def save_visualization(
            self,
            collection: TrustCollection,
            output_dir: Path,
            formats: Optional[list] = None
    ) -> None:
        """
        Save visualizations to files

        Args:
            collection: TrustCollection to visualize
            output_dir: Output directory
            formats: List of formats (mermaid, graphviz, ascii)
        """
        if formats is None:
            formats = ["mermaid", "graphviz", "ascii"]

        output_dir = Path(output_dir)
        output_dir.mkdir(exist_ok=True)

        if "mermaid" in formats:
            mermaid = self.generate_mermaid(collection)
            (output_dir / "trust_map.mmd").write_text(mermaid)
            self.log(f"Saved Mermaid diagram to {output_dir / 'trust_map.mmd'}")

        if "graphviz" in formats:
            dot = self.generate_graphviz(collection)
            (output_dir / "trust_map.dot").write_text(dot)
            self.log(f"Saved Graphviz DOT to {output_dir / 'trust_map.dot'}")

        if "ascii" in formats:
            # Capture ASCII output
            import io
            import sys

            old_stdout = sys.stdout
            sys.stdout = io.StringIO()

            self.print_trust_map(collection)

            ascii_output = sys.stdout.getvalue()
            sys.stdout = old_stdout

            (output_dir / "trust_map.txt").write_text(ascii_output)
            self.log(f"Saved ASCII map to {output_dir / 'trust_map.txt'}")