"""
Attack Path Analyzer
Identify potential attack paths through trust relationships
"""

from typing import List, Dict, Any
from dataclasses import dataclass
from enum import Enum

from ..models.trust import Trust, TrustCollection, TrustCategory


class AttackPriority(Enum):
    """Attack path priority levels"""
    CRITICAL = "CRITICAL"
    HIGH = "HIGH"
    MEDIUM = "MEDIUM"
    LOW = "LOW"


@dataclass
class AttackPath:
    """Represents a potential attack path through trusts"""
    source_domain: str
    target_domain: str
    attack_type: str
    description: str
    priority: AttackPriority
    prerequisites: List[str]
    techniques: List[str]
    mitre_ids: List[str]

    def to_dict(self) -> Dict[str, Any]:
        return {
            "source": self.source_domain,
            "target": self.target_domain,
            "attack_type": self.attack_type,
            "description": self.description,
            "priority": self.priority.value,
            "prerequisites": self.prerequisites,
            "techniques": self.techniques,
            "mitre_ids": self.mitre_ids,
        }


class AttackPathAnalyzer:
    """
    Analyze trust relationships for attack opportunities
    """

    def __init__(self, verbose: bool = True):
        self.verbose = verbose
        self.attack_paths: List[AttackPath] = []

    def log(self, message: str, level: str = "info") -> None:
        if not self.verbose:
            return
        prefixes = {"info": "[*]", "success": "[+]", "error": "[-]", "warning": "[!]"}
        print(f"{prefixes.get(level, '[*]')} {message}")

    def analyze(self, collection: TrustCollection) -> List[AttackPath]:
        """
        Analyze trust collection for attack paths

        Args:
            collection: TrustCollection to analyze

        Returns:
            List of AttackPath objects
        """
        self.attack_paths = []

        self.log("Analyzing trust relationships for attack paths...")

        # Analyze parent-child trusts
        self._analyze_parent_child(collection.parent_child)

        # Analyze forest trusts
        self._analyze_forest(collection.forest)

        # Analyze external trusts
        self._analyze_external(collection.external)

        # Sort by priority
        priority_order = {
            AttackPriority.CRITICAL: 0,
            AttackPriority.HIGH: 1,
            AttackPriority.MEDIUM: 2,
            AttackPriority.LOW: 3,
        }
        self.attack_paths.sort(key=lambda x: priority_order[x.priority])

        self.log(f"Identified {len(self.attack_paths)} potential attack path(s)", "success")

        return self.attack_paths

    def _analyze_parent_child(self, trusts: List[Trust]) -> None:
        """
        Analyze parent-child trust attack paths
        These are HIGH VALUE - SID History injection to Enterprise Admin
        """
        for trust in trusts:
            if trust.is_bidirectional:
                # Determine parent/child
                if trust.target_domain.endswith('.' + trust.source_domain):
                    parent = trust.source_domain
                    child = trust.target_domain
                else:
                    parent = trust.target_domain
                    child = trust.source_domain

                path = AttackPath(
                    source_domain=child,
                    target_domain=parent,
                    attack_type="SID History Injection",
                    description=(
                        f"Compromise child domain {child} → Create Golden Ticket "
                        f"with Enterprise Admins SID → Full control of {parent}"
                    ),
                    priority=AttackPriority.CRITICAL,
                    prerequisites=[
                        f"Domain Admin on {child}",
                        "krbtgt hash from child domain",
                        "Enterprise Admins SID from parent",
                    ],
                    techniques=[
                        "Dump krbtgt hash with DCSync",
                        "Create Golden Ticket with SID History",
                        "Access parent domain as Enterprise Admin",
                    ],
                    mitre_ids=["T1550.001", "T1134.005", "T1558.001"]
                )
                self.attack_paths.append(path)

                # ExtraSids attack
                path2 = AttackPath(
                    source_domain=child,
                    target_domain=parent,
                    attack_type="ExtraSids Attack",
                    description=(
                        f"Forge inter-realm TGT from {child} to {parent} "
                        f"with arbitrary SIDs in PAC"
                    ),
                    priority=AttackPriority.CRITICAL,
                    prerequisites=[
                        f"Domain Admin on {child}",
                        "Trust key between domains",
                    ],
                    techniques=[
                        "Extract trust key with Mimikatz",
                        "Forge inter-realm TGT with ExtraSids",
                        "Request TGS for parent domain services",
                    ],
                    mitre_ids=["T1550.001", "T1558.003"]
                )
                self.attack_paths.append(path2)

    def _analyze_forest(self, trusts: List[Trust]) -> None:
        """
        Analyze forest trust attack paths
        SID Filtering usually enabled but check
        """
        for trust in trusts:
            if trust.is_bidirectional:
                # With SID Filtering disabled
                if not trust.sid_filtering_enabled:
                    path = AttackPath(
                        source_domain=trust.source_domain,
                        target_domain=trust.target_domain,
                        attack_type="Forest Trust + SID History",
                        description=(
                            f"SID Filtering DISABLED on forest trust! "
                            f"Can inject arbitrary SIDs across forest boundary."
                        ),
                        priority=AttackPriority.CRITICAL,
                        prerequisites=[
                            f"Domain Admin on {trust.source_domain}",
                            "Trust key between forests",
                        ],
                        techniques=[
                            "Extract forest trust key",
                            "Forge TGT with target forest SIDs",
                            "Access target forest with elevated privileges",
                        ],
                        mitre_ids=["T1550.001", "T1134.005"]
                    )
                    self.attack_paths.append(path)

                # Standard forest trust attack (SID filtering enabled)
                else:
                    path = AttackPath(
                        source_domain=trust.source_domain,
                        target_domain=trust.target_domain,
                        attack_type="Forest Trust Key Extraction",
                        description=(
                            f"Extract trust key → forge inter-realm TGT → "
                            f"access resources in {trust.target_domain} as trusted user"
                        ),
                        priority=AttackPriority.MEDIUM,
                        prerequisites=[
                            f"Domain Admin on {trust.source_domain}",
                            "Knowledge of users/groups in target forest",
                        ],
                        techniques=[
                            "Extract trust key with DCSync",
                            "Forge inter-realm TGT",
                            "Access shared resources in target forest",
                        ],
                        mitre_ids=["T1550.001", "T1558.003"]
                    )
                    self.attack_paths.append(path)

    def _analyze_external(self, trusts: List[Trust]) -> None:
        """
        Analyze external trust attack paths
        """
        for trust in trusts:
            if 'Outbound' in trust.trust_direction or 'Bidirectional' in trust.trust_direction:
                path = AttackPath(
                    source_domain=trust.source_domain,
                    target_domain=trust.target_domain,
                    attack_type="External Trust Exploitation",
                    description=(
                        f"External trust to {trust.target_domain} allows "
                        f"authentication with forged tickets"
                    ),
                    priority=AttackPriority.MEDIUM,
                    prerequisites=[
                        f"Domain Admin on {trust.source_domain}",
                        "Trust key",
                    ],
                    techniques=[
                        "Extract trust key",
                        "Enumerate target domain users/resources",
                        "Forge TGT for cross-domain access",
                    ],
                    mitre_ids=["T1550.001"]
                )
                self.attack_paths.append(path)

    def print_attack_paths(self) -> None:
        """Print attack paths in formatted output"""
        if not self.attack_paths:
            print("\n[*] No attack paths identified")
            return

        print("\n" + "=" * 70)
        print("POTENTIAL ATTACK PATHS")
        print("=" * 70)

        current_priority = None

        for path in self.attack_paths:
            if path.priority != current_priority:
                current_priority = path.priority
                print(f"\n[{current_priority.value}] Priority Attacks:")
                print("-" * 40)

            print(f"\n  Attack: {path.attack_type}")
            print(f"  Path: {path.source_domain} --> {path.target_domain}")
            print(f"  Description: {path.description}")

            print(f"\n  Prerequisites:")
            for prereq in path.prerequisites:
                print(f"    • {prereq}")

            print(f"\n  Techniques:")
            for i, technique in enumerate(path.techniques, 1):
                print(f"    {i}. {technique}")

            print(f"\n  MITRE ATT&CK: {', '.join(path.mitre_ids)}")