"""
LDAP Trust Enumerator
Enumerate AD trusts via LDAP queries - works from Linux
"""

from typing import Optional, List

from .base import BaseEnumerator
from ..models.trust import Trust

# Optional import - graceful fallback
try:
    import ldap3

    LDAP3_AVAILABLE = True
except ImportError:
    import ldap3
    LDAP3_AVAILABLE = False


class LDAPEnumerator(BaseEnumerator):
    """
    Enumerate trusts via LDAP queries
    Best for: Cross-platform, works from Linux/Mac
    """

    def __init__(self, verbose: bool = True, use_ssl: bool = False):
        """
        Initialize LDAP enumerator

        Args:
            verbose: Print status messages
            use_ssl: Use LDAPS (port 636)
        """
        super().__init__(verbose)
        self.use_ssl = use_ssl
        self.port = 636 if use_ssl else 389

    def is_available(self) -> bool:
        """Check if ldap3 library is available"""
        return LDAP3_AVAILABLE

    def enumerate(
            self,
            domain: str,
            username: Optional[str] = None,
            password: Optional[str] = None,
            dc: Optional[str] = None
    ) -> List[Trust]:
        """
        Enumerate trusts via LDAP trustedDomain objects

        Args:
            domain: Target domain
            username: Username for authentication
            password: Password for authentication
            dc: Domain controller IP/hostname

        Returns:
            List of Trust objects
        """
        if not LDAP3_AVAILABLE:
            self.log("ldap3 library not installed. Run: pip install ldap3", "error")
            return []

        self.log(f"Enumerating trusts for {domain} via LDAP...")

        trusts = []

        try:
            # Connect to DC
            target_dc = dc if dc else domain
            conn = self._connect(target_dc, domain, username, password)

            if not conn:
                return []

            # Search for trustedDomain objects
            base_dn = self._domain_to_dn(domain, prefix="CN=System,")
            search_filter = "(objectClass=trustedDomain)"
            attributes = [
                "trustPartner",
                "trustDirection",
                "trustType",
                "trustAttributes",
                "flatName"
            ]

            conn.search(base_dn, search_filter, attributes=attributes)

            if conn.entries:
                self.log(f"Found {len(conn.entries)} trust(s) via LDAP", "success")

                for entry in conn.entries:
                    trust = self._parse_entry(entry, domain)
                    if trust:
                        trusts.append(trust)
                        self._log_trust(trust)
            else:
                self.log("No trusts found via LDAP", "info")

            conn.unbind()

        except Exception as e:
            self.log(f"LDAP enumeration failed: {e}", "error")

        return trusts

    def _connect(
            self,
            dc: str,
            domain: str,
            username: Optional[str],
            password: Optional[str]
    ):
        """
        Establish LDAP connection

        Args:
            dc: Domain controller
            domain: Domain name
            username: Username
            password: Password

        Returns:
            ldap3 Connection or None
        """
        try:
            server = ldap3.Server(
                dc,
                port=self.port,
                use_ssl=self.use_ssl,
                get_info=ldap3.ALL
            )

            if username and password:
                user_dn = f"{username}@{domain}"
                conn = ldap3.Connection(
                    server,
                    user=user_dn,
                    password=password,
                    auto_bind=True
                )
            else:
                # Anonymous bind
                conn = ldap3.Connection(server, auto_bind=True)

            self.log(f"Connected to {dc}", "success")
            return conn

        except Exception as e:
            self.log(f"LDAP connection failed: {e}", "error")
            return None

    def _domain_to_dn(self, domain: str, prefix: str = "") -> str:
        """
        Convert domain name to DN format

        Args:
            domain: Domain name (e.g., corp.local)
            prefix: Optional prefix (e.g., CN=System,)

        Returns:
            DN string (e.g., CN=System,DC=corp,DC=local)
        """
        parts = domain.split('.')
        dc_parts = ','.join([f"DC={p}" for p in parts])
        return f"{prefix}{dc_parts}"

    def _parse_entry(self, entry, source_domain: str) -> Optional[Trust]:
        """
        Parse LDAP entry into Trust object

        Args:
            entry: ldap3 Entry object
            source_domain: Source domain name

        Returns:
            Trust object or None
        """
        try:
            target = str(entry.trustPartner) if entry.trustPartner else ""
            trust_type = int(entry.trustType) if entry.trustType else 0
            trust_dir = int(entry.trustDirection) if entry.trustDirection else 0
            trust_attr = int(entry.trustAttributes) if entry.trustAttributes else 0

            if not target:
                return None

            return Trust.from_raw(
                source_domain=source_domain,
                target_domain=target,
                raw_type=trust_type,
                raw_direction=trust_dir,
                trust_attributes=trust_attr
            )

        except Exception as e:
            self.log(f"Error parsing LDAP entry: {e}", "error")
            return None

    def _log_trust(self, trust: Trust) -> None:
        """Log trust details"""
        self.log(f"Trust found:", "success")
        self.log(f"    Source: {trust.source_domain}")
        self.log(f"    Target: {trust.target_domain}")
        self.log(f"    Type: {trust.trust_type}")
        self.log(f"    Direction: {trust.trust_direction}")

        if trust.sid_filtering_enabled:
            self.log(f"    SID Filtering: Enabled (Quarantine)", "warning")
        else:
            self.log(f"    SID Filtering: DISABLED (Exploitable!)", "success")

    def enumerate_domain_controllers(
            self,
            domain: str,
            username: Optional[str] = None,
            password: Optional[str] = None,
            dc: Optional[str] = None
    ) -> List[str]:
        """
        Enumerate domain controllers via LDAP

        Args:
            domain: Target domain
            username: Username
            password: Password
            dc: Known DC to query

        Returns:
            List of DC hostnames
        """
        if not LDAP3_AVAILABLE:
            return []

        self.log(f"Enumerating domain controllers for {domain}...")

        dcs = []

        try:
            target_dc = dc if dc else domain
            conn = self._connect(target_dc, domain, username, password)

            if not conn:
                return []

            base_dn = self._domain_to_dn(domain)
            search_filter = "(&(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=8192))"

            conn.search(base_dn, search_filter, attributes=["dNSHostName", "name"])

            for entry in conn.entries:
                hostname = str(entry.dNSHostName) if entry.dNSHostName else str(entry.name)
                dcs.append(hostname)
                self.log(f"    DC: {hostname}")

            conn.unbind()
            self.log(f"Found {len(dcs)} domain controller(s)", "success")

        except Exception as e:
            self.log(f"DC enumeration failed: {e}", "error")

        return dcs