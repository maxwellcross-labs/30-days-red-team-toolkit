"""
Impacket Trust Enumerator
Enumerate AD trusts using Impacket tools (wmiexec, nltest)
"""

import subprocess
import shutil
import re
from typing import Optional, List

from .base import BaseEnumerator
from ..models.trust import Trust


class ImpacketEnumerator(BaseEnumerator):
    """
    Enumerate trusts using Impacket toolkit
    Best for: Remote enumeration from Linux using domain creds
    """

    def __init__(self, verbose: bool = True):
        """
        Initialize Impacket enumerator

        Args:
            verbose: Print status messages
        """
        super().__init__(verbose)
        self.timeout = 30

    def is_available(self) -> bool:
        """Check if Impacket wmiexec is available"""
        return shutil.which("wmiexec.py") is not None

    def enumerate(
            self,
            domain: str,
            username: Optional[str] = None,
            password: Optional[str] = None,
            dc: Optional[str] = None
    ) -> List[Trust]:
        """
        Enumerate trusts using nltest via wmiexec

        Args:
            domain: Target domain
            username: Username (required for Impacket)
            password: Password (required for Impacket)
            dc: Domain controller IP/hostname

        Returns:
            List of Trust objects
        """
        if not username or not password:
            self.log("Impacket requires username and password", "error")
            return []

        self.log(f"Enumerating trusts for {domain} using Impacket...")

        trusts = []
        target_dc = dc if dc else domain

        # Use nltest to enumerate trusts
        nltest_cmd = "nltest /domain_trusts /all_trusts"

        impacket_cmd = f"wmiexec.py {domain}/{username}:'{password}'@{target_dc} '{nltest_cmd}'"

        try:
            result = subprocess.run(
                impacket_cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            if result.returncode == 0 and result.stdout:
                self.log("Trust enumeration via Impacket/WMI successful", "success")
                trusts = self._parse_nltest_output(result.stdout, domain)
            else:
                self.log(f"Impacket enumeration failed: {result.stderr}", "error")

        except subprocess.TimeoutExpired:
            self.log("Impacket timeout", "error")
        except Exception as e:
            self.log(f"Impacket error: {e}", "error")

        return trusts

    def _parse_nltest_output(self, output: str, source_domain: str) -> List[Trust]:
        """
        Parse nltest /domain_trusts output

        Example output:
        List of domain trusts:
            0: CORP corp.local (NT 5) (Forest Tree Root) (Primary Domain) (Native)
            1: CHILD child.corp.local (NT 5) (Direct Outbound) (Direct Inbound)

        Args:
            output: nltest output string
            source_domain: Source domain name

        Returns:
            List of Trust objects
        """
        trusts = []

        # Regex to parse nltest output lines
        # Format: INDEX: NETBIOS FQDN (attributes...)
        pattern = r'^\s*\d+:\s+(\S+)\s+(\S+)\s+\((.*)\)'

        for line in output.split('\n'):
            match = re.match(pattern, line)
            if match:
                netbios_name = match.group(1)
                fqdn = match.group(2)
                attributes = match.group(3).lower()

                # Skip if this is the source domain
                if fqdn.lower() == source_domain.lower():
                    continue

                # Determine trust direction from attributes
                direction = self._parse_direction(attributes)

                # Determine trust type
                trust_type = 2  # Uplevel (AD) by default
                if 'nt 4' in attributes:
                    trust_type = 1  # Downlevel

                trust = Trust.from_raw(
                    source_domain=source_domain,
                    target_domain=fqdn,
                    raw_type=trust_type,
                    raw_direction=direction,
                    trust_attributes=0
                )

                trusts.append(trust)
                self._log_trust(trust, attributes)

        return trusts

    def _parse_direction(self, attributes: str) -> int:
        """
        Parse trust direction from nltest attributes

        Args:
            attributes: Attribute string from nltest

        Returns:
            Direction integer (0-3)
        """
        has_outbound = 'direct outbound' in attributes or 'outbound' in attributes
        has_inbound = 'direct inbound' in attributes or 'inbound' in attributes

        if has_outbound and has_inbound:
            return 3  # Bidirectional
        elif has_inbound:
            return 1  # Inbound
        elif has_outbound:
            return 2  # Outbound
        else:
            return 0  # Disabled/Unknown

    def _log_trust(self, trust: Trust, attributes: str) -> None:
        """Log trust details"""
        self.log(f"Trust found:", "success")
        self.log(f"    Target: {trust.target_domain}")
        self.log(f"    Direction: {trust.trust_direction}")
        self.log(f"    Attributes: {attributes}")

    def run_remote_command(
            self,
            domain: str,
            username: str,
            password: str,
            dc: str,
            command: str
    ) -> Optional[str]:
        """
        Run arbitrary command via wmiexec

        Args:
            domain: Domain name
            username: Username
            password: Password
            dc: Target DC
            command: Command to run

        Returns:
            Command output or None
        """
        impacket_cmd = f"wmiexec.py {domain}/{username}:'{password}'@{dc} '{command}'"

        try:
            result = subprocess.run(
                impacket_cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=self.timeout
            )

            if result.returncode == 0:
                return result.stdout
            else:
                self.log(f"Command failed: {result.stderr}", "error")
                return None

        except Exception as e:
            self.log(f"Remote command error: {e}", "error")
            return None

    def enumerate_with_secretsdump(
            self,
            domain: str,
            username: str,
            password: str,
            dc: str
    ) -> Optional[str]:
        """
        Extract trust keys using secretsdump
        Requires DA/enterprise admin privs

        Args:
            domain: Domain name
            username: Privileged username
            password: Password
            dc: Target DC

        Returns:
            Secretsdump output or None
        """
        if not shutil.which("secretsdump.py"):
            self.log("secretsdump.py not found", "error")
            return None

        self.log(f"Running secretsdump against {dc}...")

        cmd = f"secretsdump.py {domain}/{username}:'{password}'@{dc}"

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=120  # Longer timeout for secretsdump
            )

            if result.returncode == 0:
                self.log("Secretsdump successful", "success")
                return result.stdout
            else:
                self.log(f"Secretsdump failed: {result.stderr}", "error")
                return None

        except Exception as e:
            self.log(f"Secretsdump error: {e}", "error")
            return None