"""
JSON Report Generator
Generate comprehensive JSON reports of trust enumeration results
"""

import json
from datetime import datetime
from pathlib import Path
from typing import Optional, Dict, Any, List

from ..models.trust import TrustCollection
from ..analysis.attack_paths import AttackPath


class JSONReporter:
    """
    Generate JSON reports from trust enumeration results
    """

    def __init__(self, output_dir: str = "trust_enum"):
        """
        Initialize reporter

        Args:
            output_dir: Directory for output files
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)

    def generate_report(
            self,
            collection: TrustCollection,
            attack_paths: Optional[List[AttackPath]] = None,
            metadata: Optional[Dict[str, Any]] = None
    ) -> Dict[str, Any]:
        """
        Generate comprehensive report

        Args:
            collection: Trust collection
            attack_paths: List of attack paths
            metadata: Additional metadata

        Returns:
            Report dictionary
        """
        report = {
            "report_metadata": {
                "generated_at": datetime.now().isoformat(),
                "tool": "RT Trust Enumeration Framework",
                "version": "1.0.0",
            },
            "summary": {
                "total_trusts": collection.count,
                "total_domains": len(collection.domains_found),
                "parent_child_trusts": len(collection.parent_child),
                "forest_trusts": len(collection.forest),
                "external_trusts": len(collection.external),
                "exploitable_trusts": len(collection.exploitable),
            },
            "domains": collection.domains_found,
            "trusts": collection.to_dict(),
        }

        # Add attack paths if provided
        if attack_paths:
            report["attack_paths"] = {
                "total": len(attack_paths),
                "critical": len([p for p in attack_paths if p.priority.value == "CRITICAL"]),
                "high": len([p for p in attack_paths if p.priority.value == "HIGH"]),
                "medium": len([p for p in attack_paths if p.priority.value == "MEDIUM"]),
                "low": len([p for p in attack_paths if p.priority.value == "LOW"]),
                "paths": [p.to_dict() for p in attack_paths],
            }

        # Add custom metadata
        if metadata:
            report["custom_metadata"] = metadata

        return report

    def save_report(
            self,
            report: Dict[str, Any],
            filename: str = "trust_report.json"
    ) -> Path:
        """
        Save report to JSON file

        Args:
            report: Report dictionary
            filename: Output filename

        Returns:
            Path to saved file
        """
        output_path = self.output_dir / filename

        with open(output_path, 'w') as f:
            json.dump(report, f, indent=2, default=str)

        print(f"[+] Report saved to: {output_path}")

        return output_path

    def generate_executive_summary(
            self,
            collection: TrustCollection,
            attack_paths: Optional[List[AttackPath]] = None
    ) -> str:
        """
        Generate executive summary text

        Args:
            collection: Trust collection
            attack_paths: List of attack paths

        Returns:
            Summary text
        """
        lines = [
            "=" * 70,
            "TRUST ENUMERATION EXECUTIVE SUMMARY",
            "=" * 70,
            f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}",
            "",
            "FINDINGS:",
            f"  • Domains Discovered: {len(collection.domains_found)}",
            f"  • Total Trust Relationships: {collection.count}",
            f"  • Parent-Child Trusts: {len(collection.parent_child)}",
            f"  • Forest Trusts: {len(collection.forest)}",
            f"  • External Trusts: {len(collection.external)}",
            "",
        ]

        # Highlight exploitable trusts
        if collection.exploitable:
            lines.extend([
                "⚠️  EXPLOITABLE TRUSTS FOUND:",
                f"  • {len(collection.exploitable)} trust(s) with SID filtering disabled",
                "",
            ])
            for trust in collection.exploitable:
                lines.append(f"    - {trust.source_domain} <-> {trust.target_domain}")
            lines.append("")

        # Attack path summary
        if attack_paths:
            critical = [p for p in attack_paths if p.priority.value == "CRITICAL"]
            high = [p for p in attack_paths if p.priority.value == "HIGH"]

            lines.extend([
                "ATTACK PATH ANALYSIS:",
                f"  • Total Attack Paths: {len(attack_paths)}",
                f"  • Critical Priority: {len(critical)}",
                f"  • High Priority: {len(high)}",
                "",
            ])

            if critical:
                lines.append("CRITICAL ATTACK PATHS:")
                for path in critical:
                    lines.append(f"  • {path.attack_type}: {path.source_domain} → {path.target_domain}")
                lines.append("")

        lines.extend([
            "RECOMMENDATIONS:",
            "  1. Review trusts with SID filtering disabled",
            "  2. Audit parent-child trust configurations",
            "  3. Implement selective authentication where possible",
            "  4. Monitor for trust key extraction attempts",
            "=" * 70,
        ])

        return "\n".join(lines)

    def save_executive_summary(
            self,
            collection: TrustCollection,
            attack_paths: Optional[List[AttackPath]] = None,
            filename: str = "executive_summary.txt"
    ) -> Path:
        """
        Save executive summary to file

        Args:
            collection: Trust collection
            attack_paths: Attack paths
            filename: Output filename

        Returns:
            Path to saved file
        """
        summary = self.generate_executive_summary(collection, attack_paths)

        output_path = self.output_dir / filename
        output_path.write_text(summary)

        print(f"[+] Executive summary saved to: {output_path}")

        return output_path