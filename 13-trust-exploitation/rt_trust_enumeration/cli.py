"""
Trust Enumeration CLI
Command-line interface for the trust enumeration framework
"""

import argparse
import sys

from .framework import TrustEnumerationFramework
from .enumerators import get_available_enumerators


def main():
    """Main CLI entry point"""
    parser = argparse.ArgumentParser(
        description="AD Trust Enumeration Framework - Map trust relationships across domains",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Enumerate trusts for a domain using all methods
  python -m rt_trust_enumeration --domain corp.local --username admin --password P@ssw0rd

  # Use only LDAP enumeration (works from Linux)
  python -m rt_trust_enumeration --domain corp.local --method ldap -u admin -p P@ssw0rd

  # Enumerate with specific DC
  python -m rt_trust_enumeration --domain corp.local --dc 192.168.1.10 -u admin -p P@ssw0rd

  # Output to custom directory
  python -m rt_trust_enumeration --domain corp.local --output ./results
        """
    )

    # Required arguments
    parser.add_argument(
        '--domain', '-d',
        type=str,
        required=True,
        help='Target domain to enumerate (e.g., corp.local)'
    )

    # Authentication
    parser.add_argument(
        '--username', '-u',
        type=str,
        help='Username for authentication (domain\\user or user@domain)'
    )

    parser.add_argument(
        '--password', '-p',
        type=str,
        help='Password for authentication'
    )

    parser.add_argument(
        '--dc',
        type=str,
        help='Domain controller IP or hostname'
    )

    # Enumeration options
    parser.add_argument(
        '--method', '-m',
        type=str,
        choices=['powerview', 'ldap', 'impacket', 'all'],
        default='all',
        help='Enumeration method (default: all)'
    )

    # Output options
    parser.add_argument(
        '--output', '-o',
        type=str,
        default='trust_enum',
        help='Output directory (default: trust_enum)'
    )

    parser.add_argument(
        '--quiet', '-q',
        action='store_true',
        help='Suppress status messages'
    )

    # Analysis options
    parser.add_argument(
        '--no-analysis',
        action='store_true',
        help='Skip attack path analysis'
    )

    parser.add_argument(
        '--no-visualization',
        action='store_true',
        help='Skip visualization output'
    )

    # Parse arguments
    args = parser.parse_args()

    # Check available methods
    available = get_available_enumerators()
    if not args.quiet:
        print(f"\n[*] Available enumeration methods: {', '.join(available.keys()) or 'None'}")

    # Initialize framework
    framework = TrustEnumerationFramework(
        output_dir=args.output,
        verbose=not args.quiet
    )

    # Run enumeration based on method
    if args.method == 'all':
        framework.enumerate_all(
            args.domain,
            args.username,
            args.password,
            args.dc
        )
    elif args.method == 'powerview':
        framework.enumerate_trusts_powerview(
            args.domain,
            args.username,
            args.password,
            args.dc
        )
    elif args.method == 'ldap':
        framework.enumerate_trusts_ldap(
            args.domain,
            args.username,
            args.password,
            args.dc
        )
    elif args.method == 'impacket':
        if not args.username or not args.password:
            print("[-] Impacket method requires username and password")
            sys.exit(1)
        framework.enumerate_trusts_impacket(
            args.domain,
            args.username,
            args.password,
            args.dc
        )

    # Enumerate child domains
    framework.enumerate_child_domains(
        args.domain,
        args.username,
        args.password
    )

    # Display results
    if not args.no_visualization:
        framework.visualize_trust_relationships()

    # Analyze attack paths
    if not args.no_analysis:
        framework.identify_attack_paths()
        framework.print_attack_paths()

    # Generate report
    framework.generate_report(
        metadata={
            "target_domain": args.domain,
            "method": args.method,
            "dc": args.dc,
        }
    )

    print(f"\n[+] Enumeration complete. Results saved to: {args.output}/")


if __name__ == "__main__":
    main()