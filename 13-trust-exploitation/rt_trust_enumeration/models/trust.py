"""
Trust Data Models
Data structures for representing AD trust relationships
"""

from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any
from enum import Enum

from ..utils.converters import (
    get_trust_type,
    get_trust_direction,
    is_sid_filtering_enabled,
    parse_trust_attributes,
)


class TrustCategory(Enum):
    """Trust relationship categories"""
    PARENT_CHILD = "parent_child"
    FOREST = "forest"
    EXTERNAL = "external"
    SHORTCUT = "shortcut"
    UNKNOWN = "unknown"


@dataclass
class Trust:
    """
    Represents a single AD trust relationship
    """
    source_domain: str
    target_domain: str
    trust_type: str
    trust_direction: str
    trust_attributes: int = 0
    category: TrustCategory = TrustCategory.UNKNOWN
    raw_type: int = 0
    raw_direction: int = 0

    @classmethod
    def from_raw(
            cls,
            source_domain: str,
            target_domain: str,
            raw_type: int,
            raw_direction: int,
            trust_attributes: int = 0
    ) -> "Trust":
        """
        Create Trust from raw AD attribute values

        Args:
            source_domain: Source domain name
            target_domain: Target domain name
            raw_type: Raw trust type integer
            raw_direction: Raw trust direction integer
            trust_attributes: Trust attributes bitmask

        Returns:
            Trust instance
        """
        trust = cls(
            source_domain=source_domain,
            target_domain=target_domain,
            trust_type=get_trust_type(raw_type),
            trust_direction=get_trust_direction(raw_direction),
            trust_attributes=trust_attributes,
            raw_type=raw_type,
            raw_direction=raw_direction,
        )
        trust.category = trust._determine_category()
        return trust

    def _determine_category(self) -> TrustCategory:
        """
        Determine trust category based on domain names

        Returns:
            TrustCategory enum value
        """
        target = self.target_domain.lower()
        source = self.source_domain.lower()

        # Parent-child: one is subdomain of the other
        if target.endswith('.' + source) or source.endswith('.' + target):
            return TrustCategory.PARENT_CHILD

        # Forest: different top-level domains (simplified check)
        source_tld = source.split('.')[-1] if '.' in source else source
        target_tld = target.split('.')[-1] if '.' in target else target

        if source_tld != target_tld:
            return TrustCategory.FOREST

        # Default to external
        return TrustCategory.EXTERNAL

    @property
    def sid_filtering_enabled(self) -> bool:
        """Check if SID filtering is enabled"""
        return is_sid_filtering_enabled(self.trust_attributes)

    @property
    def is_bidirectional(self) -> bool:
        """Check if trust is bidirectional"""
        return "Bidirectional" in self.trust_direction

    @property
    def is_exploitable(self) -> bool:
        """
        Check if trust has exploitable configurations
        Bidirectional + No SID Filtering = High Value Target
        """
        return self.is_bidirectional and not self.sid_filtering_enabled

    @property
    def attribute_flags(self) -> List[str]:
        """Get list of enabled trust attribute flags"""
        return parse_trust_attributes(self.trust_attributes)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "source_domain": self.source_domain,
            "target_domain": self.target_domain,
            "trust_type": self.trust_type,
            "trust_direction": self.trust_direction,
            "trust_attributes": self.trust_attributes,
            "category": self.category.value,
            "sid_filtering": self.sid_filtering_enabled,
            "is_exploitable": self.is_exploitable,
            "attribute_flags": self.attribute_flags,
        }

    def __eq__(self, other) -> bool:
        if not isinstance(other, Trust):
            return False
        return (
                self.source_domain.lower() == other.source_domain.lower() and
                self.target_domain.lower() == other.target_domain.lower()
        )

    def __hash__(self) -> int:
        return hash((self.source_domain.lower(), self.target_domain.lower()))


@dataclass
class TrustCollection:
    """
    Collection of trust relationships with categorization
    """
    trusts: List[Trust] = field(default_factory=list)
    domains_found: List[str] = field(default_factory=list)

    def add(self, trust: Trust) -> bool:
        """
        Add trust to collection if not duplicate

        Args:
            trust: Trust to add

        Returns:
            True if added, False if duplicate
        """
        if trust in self.trusts:
            return False

        self.trusts.append(trust)

        # Track domains
        for domain in [trust.source_domain, trust.target_domain]:
            if domain.lower() not in [d.lower() for d in self.domains_found]:
                self.domains_found.append(domain)

        return True

    @property
    def parent_child(self) -> List[Trust]:
        """Get parent-child trusts"""
        return [t for t in self.trusts if t.category == TrustCategory.PARENT_CHILD]

    @property
    def forest(self) -> List[Trust]:
        """Get forest trusts"""
        return [t for t in self.trusts if t.category == TrustCategory.FOREST]

    @property
    def external(self) -> List[Trust]:
        """Get external trusts"""
        return [t for t in self.trusts if t.category == TrustCategory.EXTERNAL]

    @property
    def exploitable(self) -> List[Trust]:
        """Get trusts with exploitable configurations"""
        return [t for t in self.trusts if t.is_exploitable]

    @property
    def count(self) -> int:
        """Total number of trusts"""
        return len(self.trusts)

    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for serialization"""
        return {
            "total_trusts": self.count,
            "domains_found": self.domains_found,
            "parent_child": [t.to_dict() for t in self.parent_child],
            "forest": [t.to_dict() for t in self.forest],
            "external": [t.to_dict() for t in self.external],
            "all_trusts": [t.to_dict() for t in self.trusts],
        }