import os
import sys
import shutil
import ctypes
import subprocess
from pathlib import Path
from typing import Optional, Tuple


def check_admin() -> bool:
    """
    Check if the current process has administrator privileges.

    Returns:
        True if running as admin, False otherwise
    """
    try:
        return ctypes.windll.shell32.IsUserAnAdmin() != 0
    except AttributeError:
        # Not on Windows
        return os.geteuid() == 0


def get_current_user() -> str:
    """
    Get the current Windows username.

    Returns:
        Current username string
    """
    return os.environ.get('USERNAME', os.environ.get('USER', 'unknown'))


def get_hostname() -> str:
    """
    Get the current computer hostname.

    Returns:
        Hostname string
    """
    return os.environ.get('COMPUTERNAME', os.environ.get('HOSTNAME', 'unknown'))


def check_tool_available(tool_name: str) -> bool:
    """
    Check if an external tool is available on the system.

    Args:
        tool_name: Name of the tool to check

    Returns:
        True if available, False otherwise
    """
    result = subprocess.run(
        f"where {tool_name}" if sys.platform == 'win32' else f"which {tool_name}",
        shell=True,
        capture_output=True
    )
    return result.returncode == 0


def safe_copy(src: str, dst: str, backup: bool = True) -> Tuple[bool, Optional[str]]:
    """
    Safely copy a file with optional backup.

    Args:
        src: Source file path
        dst: Destination file path
        backup: Whether to backup existing destination

    Returns:
        Tuple of (success, backup_path or error_message)
    """
    try:
        backup_path = None

        if backup and os.path.exists(dst):
            backup_path = dst + '.bak'
            shutil.copy2(dst, backup_path)

        shutil.copy2(src, dst)
        return True, backup_path

    except PermissionError:
        return False, "Permission denied"
    except FileNotFoundError:
        return False, "Source file not found"
    except Exception as e:
        return False, str(e)


def format_size(size_bytes: int) -> str:
    """
    Format byte size to human readable string.

    Args:
        size_bytes: Size in bytes

    Returns:
        Formatted size string (e.g., "1.5 MB")
    """
    for unit in ['B', 'KB', 'MB', 'GB']:
        if size_bytes < 1024:
            return f"{size_bytes:.1f} {unit}"
        size_bytes /= 1024
    return f"{size_bytes:.1f} TB"


def is_64bit_windows() -> bool:
    """
    Check if running on 64-bit Windows.

    Returns:
        True if 64-bit, False otherwise
    """
    return sys.platform == 'win32' and os.environ.get('PROCESSOR_ARCHITECTURE') == 'AMD64'


def get_system_info() -> dict:
    """
    Gather basic system information.

    Returns:
        Dictionary with system information
    """
    return {
        'hostname': get_hostname(),
        'username': get_current_user(),
        'is_admin': check_admin(),
        'is_64bit': is_64bit_windows(),
        'platform': sys.platform,
        'python_version': sys.version
    }


def print_banner():
    """Print the framework banner."""
    banner = """
╔═══════════════════════════════════════════════════════════╗
║     Service Exploitation Framework v1.0                   ║
║     Windows Privilege Escalation Toolkit                  ║
╠═══════════════════════════════════════════════════════════╣
║  Modules:                                                 ║
║    • Unquoted Service Path Exploitation                   ║
║    • Weak Service Permission Exploitation                 ║
║    • Malicious Payload Generation                         ║
╚═══════════════════════════════════════════════════════════╝
"""
    print(banner)


def print_status():
    """Print current system status."""
    info = get_system_info()

    print(f"\n[*] System Information:")
    print(f"    Hostname: {info['hostname']}")
    print(f"    Username: {info['username']}")
    print(f"    Admin: {'Yes' if info['is_admin'] else 'No'}")
    print(f"    Architecture: {'64-bit' if info['is_64bit'] else '32-bit'}")