#!/usr/bin/env python3
"""
Group-Based Privilege Escalation Framework - CLI
================================================

Command-line interface for group-based privilege escalation.

Part of the 30 Days of Red Team toolkit.

Usage:
    python -m rt_group_exploiter                      # Auto scan & exploit
    python -m rt_group_exploiter --scan               # Scan only
    python -m rt_group_exploiter --exploit docker     # Exploit specific group
    python -m rt_group_exploiter --list               # List dangerous groups
"""

import os
import sys
import argparse
from pathlib import Path

from .core.exploiter import GroupExploiter


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="Group-Based Privilege Escalation Framework - 30 Days of Red Team",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                              Auto-scan and exploit group memberships
  %(prog)s --scan                       Scan only, no exploitation
  %(prog)s --exploit docker             Exploit specific group
  %(prog)s --exploit docker --method suid_bash
  %(prog)s --list                       List all known dangerous groups

Groups:
  docker    - CRITICAL: Mount host filesystem in container
  lxd/lxc   - CRITICAL: Privileged container with host access
  disk      - HIGH: Direct disk access via debugfs
  video     - MEDIUM: Framebuffer capture
  sudo      - HIGH: Check sudo -l permissions
  shadow    - HIGH: Read /etc/shadow directly
  adm       - LOW: Read system logs

For authorized security testing only.
        """
    )

    # Mode selection
    mode = parser.add_mutually_exclusive_group()

    mode.add_argument(
        '--scan',
        action='store_true',
        help='Scan for dangerous group memberships without exploiting'
    )

    mode.add_argument(
        '--exploit',
        type=str,
        metavar='GROUP',
        help='Exploit specific group (docker, lxd, disk, video)'
    )

    mode.add_argument(
        '--list',
        action='store_true',
        help='List all known dangerous groups'
    )

    # Options
    parser.add_argument(
        '--method',
        type=str,
        help='Specific exploitation method to use'
    )

    parser.add_argument(
        '-i', '--interactive',
        action='store_true',
        help='Allow interactive shell spawning'
    )

    parser.add_argument(
        '-o', '--output',
        type=str,
        default='/tmp/group_exploit',
        help='Output directory for reports (default: /tmp/group_exploit)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )

    parser.add_argument(
        '--continue',
        dest='continue_on_success',
        action='store_true',
        help='Continue exploitation after first success'
    )

    return parser.parse_args()


def main():
    """Main entry point"""
    # Check if running on Linux
    if os.name != 'posix':
        print("[-] This tool only works on Linux systems")
        return 1

    # Check if already root
    if os.getuid() == 0:
        print("[!] Already running as root")
        print("[!] Group exploitation not needed")
        return 0

    args = parse_args()

    # Initialize exploiter
    exploiter = GroupExploiter(
        output_dir=args.output,
        verbose=args.verbose
    )

    # List mode
    if args.list:
        exploiter.list_groups()
        return 0

    # Exploit specific group
    if args.exploit:
        result = exploiter.exploit_specific(
            group_name=args.exploit,
            method=args.method,
            interactive=args.interactive
        )

        if result.got_root:
            print(f"\n[+] SUCCESS! Root access achieved.")
            return 0
        elif result.status.value == 'manual':
            print(f"\n[*] Manual exploitation required.")
            return 0
        else:
            print(f"\n[-] Exploitation failed: {result.error or result.status.value}")
            return 1

    # Scan only mode
    if args.scan:
        result = exploiter.scan()
        exploiter.save_report(result)
        exploiter.generate_exploit_guide(result)

        if result.findings:
            return 0
        return 1

    # Default: Full auto scan and exploit
    try:
        result = exploiter.scan_and_exploit(
            interactive=args.interactive,
            stop_on_success=not args.continue_on_success
        )

        exploiter.save_report(result)
        exploiter.generate_exploit_guide(result)

        if result.successful_exploits:
            print(f"\n[+] {len(result.successful_exploits)} successful exploit(s)!")
            return 0
        elif result.findings:
            print(f"\n[*] {len(result.findings)} dangerous group(s) found.")
            print(f"[*] Check exploit_guide.txt for manual exploitation.")
            return 0
        else:
            print(f"\n[-] No dangerous group memberships found.")
            return 1

    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        return 130
    except Exception as e:
        print(f"\n[-] Fatal error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())