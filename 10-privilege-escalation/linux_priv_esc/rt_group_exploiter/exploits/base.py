"""
Base Exploit Class
==================

Abstract base class for group exploitation modules.
"""

import os
import subprocess
from abc import ABC, abstractmethod
from typing import Optional, List, Tuple

from ..core.groups import GroupFinding, ExploitResult, ExploitStatus


class BaseGroupExploit(ABC):
    """
    Abstract base class for group exploitation.

    All group exploit modules should inherit from this class
    and implement the required methods.
    """

    def __init__(self, finding: GroupFinding, verbose: bool = False):
        """
        Initialize exploit module.

        Args:
            finding: The GroupFinding to exploit
            verbose: Enable verbose output
        """
        self.finding = finding
        self.verbose = verbose

    def log(self, message: str, level: str = "info") -> None:
        """Log messages"""
        prefixes = {
            "info": "[*]",
            "success": "[+]",
            "warning": "[!]",
            "error": "[-]"
        }
        prefix = prefixes.get(level, "[*]")
        print(f"{prefix} {message}")

    def run_command(
            self,
            command: str,
            shell: bool = True,
            timeout: int = 30
    ) -> Tuple[int, str, str]:
        """
        Run a shell command.

        Args:
            command: Command to run
            shell: Use shell execution
            timeout: Command timeout

        Returns:
            Tuple of (return_code, stdout, stderr)
        """
        try:
            if shell:
                result = subprocess.run(
                    command,
                    shell=True,
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )
            else:
                result = subprocess.run(
                    command.split(),
                    capture_output=True,
                    text=True,
                    timeout=timeout
                )

            return result.returncode, result.stdout, result.stderr

        except subprocess.TimeoutExpired:
            return -1, "", "Command timed out"
        except Exception as e:
            return -1, "", str(e)

    def check_binary_exists(self, binary: str) -> bool:
        """Check if a binary exists in PATH"""
        returncode, _, _ = self.run_command(f"which {binary}")
        return returncode == 0

    def check_service_running(self, service: str) -> bool:
        """Check if a service is running"""
        returncode, _, _ = self.run_command(f"systemctl is-active {service}")
        return returncode == 0

    @abstractmethod
    def check_available(self) -> bool:
        """
        Check if exploitation is possible.

        Returns:
            True if exploitation can proceed
        """
        pass

    @abstractmethod
    def get_methods(self) -> List[dict]:
        """
        Get available exploitation methods.

        Returns:
            List of method dictionaries with:
            - name: Method name
            - description: What it does
            - command: Command to execute
            - interactive: Whether it needs interactive shell
        """
        pass

    @abstractmethod
    def exploit(self, method: Optional[str] = None, interactive: bool = False) -> ExploitResult:
        """
        Execute exploitation.

        Args:
            method: Specific method to use (None = auto)
            interactive: Allow interactive shell spawning

        Returns:
            ExploitResult
        """
        pass

    def print_methods(self) -> None:
        """Print available exploitation methods"""
        methods = self.get_methods()

        print(f"\n{'=' * 60}")
        print(f"EXPLOITATION METHODS: {self.finding.group.name.upper()}")
        print(f"{'=' * 60}")

        for i, method in enumerate(methods, 1):
            print(f"\nMethod {i}: {method['name']}")
            print(f"{'-' * 60}")
            print(f"Description: {method['description']}")
            print(f"Command: {method['command']}")

            if method.get('interactive'):
                print(f"âš  Requires interactive terminal")