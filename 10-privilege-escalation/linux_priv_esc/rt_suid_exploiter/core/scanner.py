"""
SUID Binary Scanner
===================

Discovers SUID binaries on the system.
"""

import os
import pwd
import stat
import subprocess
from typing import List, Optional, Tuple
from pathlib import Path

from .binary import SUIDFinding
from .gtfobins import GTFOBinsDB


class SUIDScanner:
    """
    Scans the filesystem for SUID binaries.

    Categorizes findings as:
    - Exploitable: Known GTFOBins binaries
    - Unusual: Non-standard binaries worth investigating
    - Standard: Common system SUID binaries
    """

    # Standard SUID binaries that are typically not exploitable
    STANDARD_BINARIES = {
        'sudo', 'su', 'passwd', 'mount', 'umount', 'ping', 'ping6',
        'pkexec', 'polkit-agent-helper-1', 'fusermount', 'fusermount3',
        'newgrp', 'chsh', 'chfn', 'gpasswd', 'unix_chkpwd',
        'at', 'crontab', 'ssh-keysign', 'pam_timestamp_check',
        'traceroute', 'traceroute6', 'wall', 'write',
        'chage', 'expiry', 'sg', 'mount.cifs', 'umount.cifs',
        'snap-confine', 'chrome-sandbox', 'Xorg.wrap'
    }

    def __init__(self, gtfobins_db: Optional[GTFOBinsDB] = None):
        """
        Initialize scanner.

        Args:
            gtfobins_db: GTFOBins database (created if not provided)
        """
        self.gtfobins = gtfobins_db or GTFOBinsDB()

    def scan(
            self,
            search_paths: Optional[List[str]] = None,
            timeout: int = 120
    ) -> Tuple[List[SUIDFinding], List[SUIDFinding], List[SUIDFinding]]:
        """
        Scan for SUID binaries.

        Args:
            search_paths: Paths to search (default: entire filesystem)
            timeout: Search timeout in seconds

        Returns:
            Tuple of (exploitable, unusual, standard) findings
        """
        print(f"[*] Scanning for SUID binaries...")

        # Find all SUID binaries
        suid_paths = self._find_suid_binaries(search_paths, timeout)

        print(f"[+] Found {len(suid_paths)} SUID binaries")

        # Categorize each binary
        exploitable: List[SUIDFinding] = []
        unusual: List[SUIDFinding] = []
        standard: List[SUIDFinding] = []

        for binary_path in suid_paths:
            finding = self._analyze_binary(binary_path)

            if finding.is_exploitable:
                exploitable.append(finding)
                print(f"[+] EXPLOITABLE: {finding.path}")
            elif finding.is_unusual:
                unusual.append(finding)
                print(f"[!] UNUSUAL: {finding.path}")
            else:
                standard.append(finding)

        return exploitable, unusual, standard

    def _find_suid_binaries(
            self,
            search_paths: Optional[List[str]] = None,
            timeout: int = 120
    ) -> List[str]:
        """Find all SUID binaries on the system"""
        if search_paths:
            paths_str = ' '.join(search_paths)
        else:
            paths_str = '/'

        cmd = f"find {paths_str} -type f -perm -4000 2>/dev/null"

        try:
            result = subprocess.run(
                cmd,
                shell=True,
                capture_output=True,
                text=True,
                timeout=timeout
            )

            return [
                line.strip()
                for line in result.stdout.split('\n')
                if line.strip()
            ]
        except subprocess.TimeoutExpired:
            print(f"[-] SUID search timed out after {timeout}s")
            return []
        except Exception as e:
            print(f"[-] Error searching for SUID binaries: {e}")
            return []

    def _analyze_binary(self, path: str) -> SUIDFinding:
        """Analyze a single SUID binary"""
        name = os.path.basename(path)

        # Get file info
        owner_uid = 0
        owner_name = "root"
        permissions = ""

        try:
            stat_info = os.stat(path)
            owner_uid = stat_info.st_uid

            try:
                owner_name = pwd.getpwuid(owner_uid).pw_name
            except KeyError:
                owner_name = str(owner_uid)

            # Get permission string
            mode = stat_info.st_mode
            permissions = stat.filemode(mode)
        except Exception:
            pass

        # Get file type
        file_type = self._get_file_type(path)

        # Determine category
        is_exploitable = self.gtfobins.has(name)
        is_unusual = not is_exploitable and name not in self.STANDARD_BINARIES

        return SUIDFinding(
            path=path,
            name=name,
            owner_uid=owner_uid,
            owner_name=owner_name,
            is_exploitable=is_exploitable,
            is_unusual=is_unusual,
            permissions=permissions,
            file_type=file_type
        )

    def _get_file_type(self, path: str) -> str:
        """Get file type using 'file' command"""
        try:
            result = subprocess.run(
                ['file', path],
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0 and ':' in result.stdout:
                return result.stdout.split(':', 1)[1].strip()
        except:
            pass

        return "unknown"

    def quick_check(self, binary_name: str) -> Optional[SUIDFinding]:
        """
        Quick check if a specific binary is SUID.

        Args:
            binary_name: Name of the binary to check

        Returns:
            SUIDFinding if found and SUID, None otherwise
        """
        # Find the binary
        try:
            result = subprocess.run(
                f"which {binary_name}",
                shell=True,
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode != 0:
                return None

            path = result.stdout.strip()

            # Check if SUID
            stat_info = os.stat(path)

            if not (stat_info.st_mode & stat.S_ISUID):
                return None

            return self._analyze_binary(path)

        except Exception:
            return None