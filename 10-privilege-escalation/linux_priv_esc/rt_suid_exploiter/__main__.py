#!/usr/bin/env python3
"""
SUID Binary Exploitation Framework - CLI
========================================

Command-line interface for SUID binary discovery and exploitation.

Part of the 30 Days of Red Team toolkit.

Usage:
    python -m rt_suid_exploiter                    # Auto scan & exploit
    python -m rt_suid_exploiter --scan             # Scan only (no exploit)
    python -m rt_suid_exploiter --exploit find     # Exploit specific binary
    python -m rt_suid_exploiter --list vim         # List techniques for binary
"""

import argparse
import sys
from pathlib import Path

from .core.exploiter import SUIDExploiter


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="SUID Binary Exploitation Framework - 30 Days of Red Team",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                       Auto-scan and exploit SUID binaries
  %(prog)s --scan                Scan only, no exploitation
  %(prog)s --exploit find        Exploit specific binary
  %(prog)s --exploit vim --path /usr/bin/vim   Exploit with specific path
  %(prog)s --list python         Show all techniques for binary
  %(prog)s --all-binaries        List all known GTFOBins binaries

⚠️  For authorized security testing only.
        """
    )

    # Mode selection
    mode = parser.add_mutually_exclusive_group()

    mode.add_argument(
        '--scan',
        action='store_true',
        help='Scan for SUID binaries without exploiting'
    )

    mode.add_argument(
        '--exploit',
        type=str,
        metavar='BINARY',
        help='Exploit a specific binary (e.g., find, vim, python)'
    )

    mode.add_argument(
        '--list',
        type=str,
        metavar='BINARY',
        help='List exploitation techniques for a binary'
    )

    mode.add_argument(
        '--all-binaries',
        action='store_true',
        help='List all known GTFOBins binaries'
    )

    # Options
    parser.add_argument(
        '--path',
        type=str,
        help='Full path to binary (for --exploit)'
    )

    parser.add_argument(
        '-o', '--output',
        type=str,
        default='/tmp/suid_exploit',
        help='Output directory for reports (default: /tmp/suid_exploit)'
    )

    parser.add_argument(
        '--no-test',
        action='store_true',
        help='Spawn actual shell instead of running test command'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )

    parser.add_argument(
        '--continue',
        dest='continue_on_success',
        action='store_true',
        help='Continue exploitation after first success'
    )

    return parser.parse_args()


def main():
    """Main entry point"""
    args = parse_args()

    # Initialize exploiter
    exploiter = SUIDExploiter(
        output_dir=args.output,
        verbose=args.verbose
    )

    # List all binaries mode
    if args.all_binaries:
        print(f"\n[*] Known GTFOBins SUID binaries ({len(exploiter.gtfobins)}):")
        print("-" * 60)

        binaries = sorted(exploiter.gtfobins.all_binaries())

        for i, binary in enumerate(binaries, 1):
            print(f"  {binary:<20}", end='')
            if i % 4 == 0:
                print()

        print()
        return 0

    # List techniques mode
    if args.list:
        exploiter.list_techniques(args.list)
        return 0

    # Exploit specific binary mode
    if args.exploit:
        result = exploiter.exploit_specific(
            binary_name=args.exploit,
            binary_path=args.path,
            test_only=not args.no_test
        )

        if result.got_root:
            print(f"\n[+] SUCCESS! Root access achieved.")
            return 0
        elif result.status.value == 'interactive':
            print(f"\n[*] Interactive exploitation required.")
            print(f"[*] Run the listed command manually.")
            return 0
        else:
            print(f"\n[-] Exploitation failed: {result.status.value}")
            return 1

    # Scan only mode
    if args.scan:
        result = exploiter.scan()
        exploiter.save_report(result)
        exploiter.generate_exploit_guide(result)

        if result.exploitable:
            return 0
        return 1

    # Default: Full auto scan and exploit
    try:
        result = exploiter.scan_and_exploit(
            test_only=not args.no_test,
            stop_on_success=not args.continue_on_success
        )

        exploiter.save_report(result)
        exploiter.generate_exploit_guide(result)

        if result.successful_exploits:
            print(f"\n[+] {len(result.successful_exploits)} successful exploit(s)!")
            return 0
        elif result.exploitable:
            print(f"\n[*] {len(result.exploitable)} exploitable binary(ies) found.")
            print(f"[*] Check exploit_guide.txt for manual exploitation.")
            return 0
        else:
            print(f"\n[-] No exploitable SUID binaries found.")
            return 1

    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        return 130
    except Exception as e:
        print(f"\n[-] Fatal error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())