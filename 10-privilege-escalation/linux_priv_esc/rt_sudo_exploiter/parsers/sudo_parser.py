"""
Sudo Output Parser
==================

Parses output from 'sudo -l' to extract permissions.
"""

import os
import re
import subprocess
from typing import List, Optional, Tuple, Any

from ..core.permissions import SudoPermission, SudoCommand
from ..core.gtfobins import GTFOBinsSudo


class SudoParser:
    """
    Parses sudo -l output to extract permission entries.

    Handles various sudo output formats:
    - (root) NOPASSWD: /usr/bin/vim
    - (ALL : ALL) ALL
    - (root) /usr/bin/find *
    """

    # Regex patterns for parsing sudo output
    PERMISSION_PATTERN = re.compile(
        r'\(([^)]+)\)\s*(NOPASSWD:|PASSWD:|SETENV:|NOSETENV:|)*\s*(.+)'
    )

    def __init__(self, gtfobins: Optional[GTFOBinsSudo] = None):
        """
        Initialize parser.

        Args:
            gtfobins: GTFOBins database for checking exploitability
        """
        self.gtfobins = gtfobins or GTFOBinsSudo()

    @staticmethod
    def get_sudo_output() -> Tuple[Optional[str], Optional[str]]:
        """
        Execute sudo -l and return output.

        Returns:
            Tuple of (output, error_message)
        """
        try:
            # Try with -n first (non-interactive)
            result = subprocess.run(
                "sudo -n -l 2>/dev/null || sudo -l 2>/dev/null",
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0 and result.stdout:
                return result.stdout, None

            if "password" in result.stderr.lower():
                return None, "Password required for sudo -l"

            if "not allowed" in result.stderr.lower():
                return None, "User not in sudoers"

            return None, f"sudo -l failed: {result.stderr}"

        except subprocess.TimeoutExpired:
            return None, "sudo -l timed out"
        except Exception as e:
            return None, f"Error running sudo -l: {e}"

    @staticmethod
    def get_sudo_version() -> Optional[str]:
        """Get sudo version for vulnerability checking"""
        try:
            result = subprocess.run(
                "sudo --version 2>/dev/null | head -1",
                shell=True,
                capture_output=True,
                text=True,
                timeout=5
            )

            if result.returncode == 0:
                return result.stdout.strip()

            return None
        except:
            return None

    def parse(self, sudo_output: str) -> List[SudoPermission]:
        """
        Parse sudo -l output into permission objects.

        Args:
            sudo_output: Raw output from sudo -l

        Returns:
            List of SudoPermission objects
        """
        permissions = []

        lines = sudo_output.split('\n')

        for line in lines:
            line = line.strip()

            # Skip empty lines, comments, and headers
            if not line or line.startswith('#'):
                continue

            if 'may run the following' in line.lower():
                continue

            if 'user' in line.lower() and 'on' in line.lower() and ':' not in line:
                continue

            # Try to parse as permission line
            permission = self._parse_permission_line(line)

            if permission and permission.commands:
                permissions.append(permission)

        return permissions

    def _parse_permission_line(self, line: str) -> Optional[SudoPermission]:
        """Parse a single permission line"""

        # Check for the (user) pattern
        if '(' not in line or ')' not in line:
            return None

        # Extract run_as from parentheses
        run_as_match = re.search(r'\(([^)]+)\)', line)

        if not run_as_match:
            return None

        run_as_full = run_as_match.group(1)

        # Parse run_as (format: user or user : group or ALL : ALL)
        run_as_user = "root"
        run_as_group = None

        if ':' in run_as_full:
            parts = run_as_full.split(':')
            run_as_user = parts[0].strip()
            run_as_group = parts[1].strip() if len(parts) > 1 else None
        else:
            run_as_user = run_as_full.strip()

        # Check for NOPASSWD
        nopasswd = 'NOPASSWD' in line.upper()

        # Extract tags
        tags = []
        if 'SETENV' in line:
            tags.append('SETENV')
        if 'NOSETENV' in line:
            tags.append('NOSETENV')

        # Extract commands (everything after the last colon, or after the parentheses)
        commands_str = ""

        if ':' in line:
            # Find the last colon and extract commands
            after_paren = line[line.rindex(')') + 1:]

            if ':' in after_paren:
                commands_str = after_paren.split(':', 1)[1].strip()
            else:
                commands_str = after_paren.strip()

        # Parse individual commands
        commands = self._parse_commands(commands_str)

        return SudoPermission(
            raw_line=line,
            run_as_user=run_as_user,
            run_as_group=run_as_group,
            nopasswd=nopasswd,
            commands=commands,
            tags=tags
        )

    def _parse_commands(self, commands_str: str) -> List[SudoCommand]:
        """Parse command string into individual commands"""
        commands = []

        if not commands_str:
            return commands

        # Split on comma (but not commas in quotes)
        # Simple split for now - most sudo configs don't have complex quoting
        command_parts = [c.strip() for c in commands_str.split(',')]

        for cmd_str in command_parts:
            if not cmd_str:
                continue

            cmd = self._parse_single_command(cmd_str)

            if cmd:
                commands.append(cmd)

        return commands

    @staticmethod
    def _parse_single_command(cmd_str: str) -> Optional[SudoCommand]:
        """Parse a single command specification"""
        cmd_str = cmd_str.strip()

        if not cmd_str:
            return None

        # Check for ALL
        if cmd_str.upper() == 'ALL':
            return SudoCommand(
                full_path='ALL',
                name='ALL',
                is_all=True
            )

        # Split into path and arguments
        parts = cmd_str.split(None, 1)
        full_path = parts[0]
        args = parts[1] if len(parts) > 1 else ""

        # Handle wildcards in path
        if '*' in full_path and '/' in full_path:
            # This is a path pattern, not a specific binary
            # Still try to extract the binary name
            pass

        # Extract binary name
        name = os.path.basename(full_path)

        # Handle cases like /usr/bin/vim*
        if name.endswith('*'):
            name = name[:-1]

        return SudoCommand(
            full_path=full_path,
            name=name,
            args=args
        )

    def is_exploitable(self, command: SudoCommand) -> bool:
        """Check if a command is exploitable via GTFOBins"""
        if command.is_all:
            return True

        return self.gtfobins.has(command.name)

    def get_exploits(self, command: SudoCommand) -> list[SudoCommand] | list[Any] | list[str]:
        """Get exploitation commands for a sudo command"""
        if command.is_all:
            return ["sudo su -", "sudo /bin/bash", "sudo sh"]

        binary_exploits = self.gtfobins.get(command.name)

        if not binary_exploits:
            return []

        return [tech.command for tech in binary_exploits.techniques]