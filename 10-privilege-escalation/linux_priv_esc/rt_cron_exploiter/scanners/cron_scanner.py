"""
Cron Job Scanner
================

Scans the system for cron jobs and identifies vulnerabilities.
"""

import os
import stat
from pathlib import Path
from typing import List, Optional, Tuple

from ..core.cronjob import (
    CronJob, CronSchedule, CronVulnerability,
    VulnerabilityType
)


class CronScanner:
    """
    Scans for cron jobs and identifies vulnerabilities.

    Checks:
    - /etc/crontab
    - /etc/cron.d/*
    - /etc/cron.{hourly,daily,weekly,monthly}
    - /var/spool/cron/crontabs/*
    - systemd timers
    """

    # Standard cron locations
    CRON_LOCATIONS = [
        '/etc/crontab',
        '/etc/cron.d',
        '/etc/cron.hourly',
        '/etc/cron.daily',
        '/etc/cron.weekly',
        '/etc/cron.monthly',
        '/var/spool/cron/crontabs',
        '/var/spool/cron'
    ]

    # Binaries vulnerable to wildcard injection
    WILDCARD_VULNERABLE = ['tar', 'rsync', 'chown', 'chmod', 'find']

    def __init__(self):
        pass

    def scan_all(self) -> Tuple[List[CronJob], List[CronVulnerability]]:
        """
        Scan all cron locations.

        Returns:
            Tuple of (all_jobs, vulnerabilities)
        """
        all_jobs: List[CronJob] = []
        vulnerabilities: List[CronVulnerability] = []

        # Scan /etc/crontab
        print(f"\n[*] Scanning /etc/crontab...")
        jobs = self._scan_crontab('/etc/crontab')
        all_jobs.extend(jobs)

        # Scan /etc/cron.d/
        print(f"[*] Scanning /etc/cron.d/...")
        jobs = self._scan_cron_directory('/etc/cron.d')
        all_jobs.extend(jobs)

        # Scan periodic directories
        for period in ['hourly', 'daily', 'weekly', 'monthly']:
            path = f'/etc/cron.{period}'
            print(f"[*] Scanning {path}...")
            jobs = self._scan_run_parts_directory(path, period)
            all_jobs.extend(jobs)

        # Scan user crontabs
        print(f"[*] Scanning user crontabs...")
        jobs = self._scan_user_crontabs()
        all_jobs.extend(jobs)

        # Scan systemd timers
        print(f"[*] Scanning systemd timers...")
        jobs = self._scan_systemd_timers()
        all_jobs.extend(jobs)

        # Find root jobs
        root_jobs = [j for j in all_jobs if j.runs_as_root]
        print(f"\n[+] Found {len(all_jobs)} total cron jobs")
        print(f"[+] Found {len(root_jobs)} jobs running as root")

        # Analyze for vulnerabilities
        print(f"\n[*] Analyzing for vulnerabilities...")
        vulnerabilities = self._analyze_vulnerabilities(root_jobs)

        return all_jobs, vulnerabilities

    def _scan_crontab(self, path: str) -> List[CronJob]:
        """Parse /etc/crontab format"""
        jobs = []

        if not os.path.exists(path):
            return jobs

        try:
            with open(path, 'r') as f:
                content = f.read()

            for line in content.split('\n'):
                line = line.strip()

                # Skip empty lines and comments
                if not line or line.startswith('#'):
                    continue

                # Skip environment variables
                if '=' in line and not line[0].isdigit() and line[0] != '*':
                    continue

                # Parse crontab format: min hour day month weekday user command
                parts = line.split()

                if len(parts) >= 7:
                    schedule_str = ' '.join(parts[:5])
                    user = parts[5]
                    command = ' '.join(parts[6:])

                    jobs.append(CronJob(
                        source=path,
                        user=user,
                        command=command,
                        schedule=CronSchedule(schedule_str),
                        raw_line=line
                    ))
        except PermissionError:
            print(f"[-] Cannot read {path} (permission denied)")
        except Exception as e:
            print(f"[-] Error reading {path}: {e}")

        return jobs

    def _scan_cron_directory(self, path: str) -> List[CronJob]:
        """Scan /etc/cron.d/ style directory"""
        jobs = []

        if not os.path.exists(path) or not os.path.isdir(path):
            return jobs

        try:
            for entry in os.listdir(path):
                file_path = os.path.join(path, entry)

                if os.path.isfile(file_path):
                    # Parse like crontab
                    file_jobs = self._scan_crontab(file_path)
                    jobs.extend(file_jobs)
        except PermissionError:
            print(f"[-] Cannot access {path} (permission denied)")
        except Exception as e:
            print(f"[-] Error scanning {path}: {e}")

        return jobs

    def _scan_run_parts_directory(self, path: str, period: str) -> List[CronJob]:
        """Scan cron.{hourly,daily,weekly,monthly} directories"""
        jobs = []

        if not os.path.exists(path) or not os.path.isdir(path):
            return jobs

        # These run as root via run-parts
        schedule_map = {
            'hourly': '0 * * * *',
            'daily': '0 0 * * *',
            'weekly': '0 0 * * 0',
            'monthly': '0 0 1 * *'
        }

        schedule_str = schedule_map.get(period, '* * * * *')

        try:
            for entry in os.listdir(path):
                file_path = os.path.join(path, entry)

                if os.path.isfile(file_path) and os.access(file_path, os.X_OK):
                    jobs.append(CronJob(
                        source=path,
                        user='root',
                        command=file_path,
                        schedule=CronSchedule(schedule_str),
                        raw_line=f"# {period}: {file_path}"
                    ))
        except PermissionError:
            print(f"[-] Cannot access {path} (permission denied)")

        return jobs

    def _scan_user_crontabs(self) -> List[CronJob]:
        """Scan /var/spool/cron/crontabs/"""
        jobs = []

        crontab_dirs = ['/var/spool/cron/crontabs', '/var/spool/cron']

        for crontab_dir in crontab_dirs:
            if not os.path.exists(crontab_dir):
                continue

            try:
                for entry in os.listdir(crontab_dir):
                    file_path = os.path.join(crontab_dir, entry)

                    if os.path.isfile(file_path):
                        user = entry  # Username is the filename

                        try:
                            with open(file_path, 'r') as f:
                                content = f.read()

                            for line in content.split('\n'):
                                line = line.strip()

                                if not line or line.startswith('#'):
                                    continue

                                if '=' in line and not line[0].isdigit() and line[0] != '*':
                                    continue

                                parts = line.split()

                                if len(parts) >= 6:
                                    schedule_str = ' '.join(parts[:5])
                                    command = ' '.join(parts[5:])

                                    jobs.append(CronJob(
                                        source=file_path,
                                        user=user,
                                        command=command,
                                        schedule=CronSchedule(schedule_str),
                                        raw_line=line
                                    ))
                        except PermissionError:
                            print(f"[-] Cannot read {file_path}")
            except PermissionError:
                print(f"[-] Cannot access {crontab_dir}")

        return jobs

    def _scan_systemd_timers(self) -> List[CronJob]:
        """Scan systemd timers"""
        jobs = []

        try:
            import subprocess

            result = subprocess.run(
                "systemctl list-timers --all --no-pager 2>/dev/null",
                shell=True,
                capture_output=True,
                text=True,
                timeout=10
            )

            if result.returncode == 0 and result.stdout:
                lines = result.stdout.split('\n')

                for line in lines:
                    if '.timer' in line and '.service' in line:
                        # Extract timer name
                        parts = line.split()

                        for part in parts:
                            if '.timer' in part:
                                jobs.append(CronJob(
                                    source='systemd',
                                    user='root',  # Assume root for system timers
                                    command=f"systemd timer: {part}",
                                    schedule=CronSchedule('* * * * *'),  # Unknown
                                    raw_line=line
                                ))
                                break
        except:
            pass

        return jobs

    def _analyze_vulnerabilities(self, root_jobs: List[CronJob]) -> List[CronVulnerability]:
        """Analyze root cron jobs for vulnerabilities"""
        vulnerabilities = []

        for job in root_jobs:
            # Check for writable scripts
            vuln = self._check_writable_script(job)
            if vuln:
                vulnerabilities.append(vuln)

            # Check for writable directories
            vuln = self._check_writable_directory(job)
            if vuln:
                vulnerabilities.append(vuln)

            # Check for missing scripts
            vuln = self._check_missing_script(job)
            if vuln:
                vulnerabilities.append(vuln)

            # Check for wildcard injection
            vuln = self._check_wildcard_injection(job)
            if vuln:
                vulnerabilities.append(vuln)

            # Check for PATH hijacking
            vuln = self._check_path_hijack(job)
            if vuln:
                vulnerabilities.append(vuln)

        return vulnerabilities

    def _check_writable_script(self, job: CronJob) -> Optional[CronVulnerability]:
        """Check if cron script is writable"""
        script_path = job.script_path

        if not script_path or not os.path.exists(script_path):
            return None

        if os.access(script_path, os.W_OK):
            # Check if world-writable
            try:
                mode = os.stat(script_path).st_mode
                is_world_writable = bool(mode & stat.S_IWOTH)
            except:
                is_world_writable = False

            severity = "CRITICAL" if is_world_writable else "HIGH"
            vuln_type = VulnerabilityType.WORLD_WRITABLE if is_world_writable else VulnerabilityType.WRITABLE_SCRIPT

            return CronVulnerability(
                cron_job=job,
                vuln_type=vuln_type,
                target_path=script_path,
                description=f"Cron script is writable: {script_path}",
                exploitation=f"Modify {script_path} with malicious payload",
                severity=severity
            )

        return None

    def _check_writable_directory(self, job: CronJob) -> Optional[CronVulnerability]:
        """Check if script's directory is writable"""
        script_path = job.script_path

        if not script_path:
            return None

        script_dir = os.path.dirname(script_path)

        if script_dir and os.path.exists(script_dir) and os.access(script_dir, os.W_OK):
            return CronVulnerability(
                cron_job=job,
                vuln_type=VulnerabilityType.WRITABLE_DIRECTORY,
                target_path=script_dir,
                description=f"Cron script directory is writable: {script_dir}",
                exploitation=f"Replace or modify script in {script_dir}",
                severity="HIGH"
            )

        return None

    def _check_missing_script(self, job: CronJob) -> Optional[CronVulnerability]:
        """Check if cron script doesn't exist but directory is writable"""
        script_path = job.script_path

        if not script_path:
            return None

        if not os.path.exists(script_path):
            script_dir = os.path.dirname(script_path)

            if script_dir and os.path.exists(script_dir) and os.access(script_dir, os.W_OK):
                return CronVulnerability(
                    cron_job=job,
                    vuln_type=VulnerabilityType.MISSING_SCRIPT,
                    target_path=script_path,
                    description=f"Cron references missing script: {script_path}",
                    exploitation=f"Create {script_path} with malicious payload",
                    severity="CRITICAL"
                )

        return None

    def _check_wildcard_injection(self, job: CronJob) -> Optional[CronVulnerability]:
        """Check for wildcard injection vulnerabilities"""
        if not job.has_wildcards:
            return None

        command = job.command.lower()

        for binary in self.WILDCARD_VULNERABLE:
            if binary in command:
                # Determine exploitation technique
                if binary == 'tar':
                    exploitation = "Create --checkpoint and --checkpoint-action files"
                elif binary == 'rsync':
                    exploitation = "Create -e file with shell command"
                elif binary in ('chown', 'chmod'):
                    exploitation = "Create --reference file pointing to controlled file"
                else:
                    exploitation = f"Wildcard injection via {binary}"

                return CronVulnerability(
                    cron_job=job,
                    vuln_type=VulnerabilityType.WILDCARD_INJECTION,
                    target_path=job.script_path or "N/A",
                    description=f"Wildcard injection possible in {binary} command",
                    exploitation=exploitation,
                    severity="HIGH"
                )

        return None

    def _check_path_hijack(self, job: CronJob) -> Optional[CronVulnerability]:
        """Check for PATH hijacking opportunities"""
        # Check if command uses relative path
        parts = job.command.split()

        if parts and not parts[0].startswith('/'):
            binary = parts[0]

            # Skip shell built-ins
            if binary in ('cd', 'echo', 'export', 'test', '[', '[['):
                return None

            return CronVulnerability(
                cron_job=job,
                vuln_type=VulnerabilityType.RELATIVE_PATH,
                target_path=binary,
                description=f"Cron uses relative path: {binary}",
                exploitation=f"Create malicious {binary} in PATH",
                severity="MEDIUM"
            )

        return None