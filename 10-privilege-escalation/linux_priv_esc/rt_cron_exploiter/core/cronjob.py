"""
Cron Job Data Structures
========================

Data structures for representing cron jobs and vulnerabilities.
"""

from dataclasses import dataclass, field
from typing import List, Optional, Dict, Any
from datetime import datetime
from enum import Enum
from pathlib import Path


class VulnerabilityType(Enum):
    """Type of cron vulnerability"""
    WRITABLE_SCRIPT = "writable_script"  # Script file is writable
    WRITABLE_DIRECTORY = "writable_directory"  # Script directory is writable
    MISSING_SCRIPT = "missing_script"  # Script doesn't exist, directory writable
    WILDCARD_INJECTION = "wildcard_injection"  # Wildcard in command (tar, rsync)
    PATH_HIJACK = "path_hijack"  # PATH variable manipulation
    RELATIVE_PATH = "relative_path"  # Relative path in command
    WORLD_WRITABLE = "world_writable"  # World-writable script


class CronSchedule:
    """
    Parses and represents a cron schedule.

    Format: minute hour day month weekday
    """

    def __init__(self, schedule_str: str):
        self.raw = schedule_str
        self.parts = schedule_str.split()

        if len(self.parts) >= 5:
            self.minute = self.parts[0]
            self.hour = self.parts[1]
            self.day = self.parts[2]
            self.month = self.parts[3]
            self.weekday = self.parts[4]
        else:
            self.minute = self.hour = self.day = self.month = self.weekday = "*"

    @property
    def is_frequent(self) -> bool:
        """Check if job runs frequently (every minute or every 5 minutes)"""
        return self.minute in ('*', '*/1', '*/5')

    @property
    def estimated_wait_minutes(self) -> int:
        """Estimate maximum wait time for execution"""
        if self.minute == '*':
            return 1
        elif self.minute.startswith('*/'):
            try:
                return int(self.minute[2:])
            except:
                return 60
        else:
            return 60  # Worst case

    def __str__(self) -> str:
        return self.raw


@dataclass
class CronJob:
    """
    Represents a single cron job entry.

    Attributes:
        source: Where the cron job was found (file path)
        user: User the job runs as
        command: The command/script being executed
        schedule: Cron schedule (5 fields)
        raw_line: Original line from cron file
    """
    source: str
    user: str
    command: str
    schedule: CronSchedule
    raw_line: str = ""

    @property
    def runs_as_root(self) -> bool:
        return self.user.lower() == 'root'

    @property
    def script_path(self) -> Optional[str]:
        """Extract the script path from the command"""
        return self._extract_script_path()

    def _extract_script_path(self) -> Optional[str]:
        """Parse command to find script path"""
        parts = self.command.split()

        for part in parts:
            # Skip shell binaries
            if part in ('/bin/bash', '/bin/sh', '/usr/bin/bash',
                        '/usr/bin/sh', 'bash', 'sh', '/usr/bin/env'):
                continue

            # Skip common flags
            if part.startswith('-'):
                continue

            # Look for absolute paths
            if part.startswith('/'):
                # Clean up path (remove redirects, pipes, etc.)
                clean_path = part.split('&')[0].split(';')[0].split('|')[0].split('>')[0].strip()
                return clean_path

        return None

    @property
    def has_wildcards(self) -> bool:
        """Check if command uses wildcards (potential injection)"""
        return '*' in self.command

    @property
    def uses_tar(self) -> bool:
        """Check if command uses tar (checkpoint injection)"""
        return 'tar ' in self.command or self.command.startswith('tar')

    @property
    def uses_rsync(self) -> bool:
        """Check if command uses rsync (wildcard injection)"""
        return 'rsync ' in self.command or self.command.startswith('rsync')

    def to_dict(self) -> Dict[str, Any]:
        return {
            'source': self.source,
            'user': self.user,
            'command': self.command,
            'schedule': str(self.schedule),
            'script_path': self.script_path,
            'runs_as_root': self.runs_as_root,
            'has_wildcards': self.has_wildcards
        }

    def __str__(self) -> str:
        return f"[{self.user}] {self.schedule} {self.command}"


@dataclass
class CronVulnerability:
    """
    Represents a vulnerability in a cron configuration.

    Attributes:
        cron_job: The vulnerable cron job
        vuln_type: Type of vulnerability
        target_path: Path that can be exploited
        description: Human-readable description
        exploitation: How to exploit this vulnerability
    """
    cron_job: CronJob
    vuln_type: VulnerabilityType
    target_path: str
    description: str
    exploitation: str
    severity: str = "HIGH"

    def to_dict(self) -> Dict[str, Any]:
        return {
            'cron_job': self.cron_job.to_dict(),
            'vulnerability_type': self.vuln_type.value,
            'target_path': self.target_path,
            'description': self.description,
            'exploitation': self.exploitation,
            'severity': self.severity
        }

    def __str__(self) -> str:
        return f"[{self.severity}] {self.vuln_type.value}: {self.target_path}"


@dataclass
class ExploitResult:
    """Result of an exploitation attempt"""
    vulnerability: CronVulnerability
    payload_type: str
    payload_written: bool
    backup_path: Optional[str] = None
    execution_confirmed: bool = False
    error: Optional[str] = None
    timestamp: datetime = field(default_factory=datetime.now)

    def to_dict(self) -> Dict[str, Any]:
        return {
            'target': self.vulnerability.target_path,
            'payload_type': self.payload_type,
            'payload_written': self.payload_written,
            'backup_path': self.backup_path,
            'execution_confirmed': self.execution_confirmed,
            'error': self.error,
            'timestamp': self.timestamp.isoformat()
        }


@dataclass
class CronScanResult:
    """Complete results of a cron scan"""
    cron_jobs: List[CronJob] = field(default_factory=list)
    root_jobs: List[CronJob] = field(default_factory=list)
    vulnerabilities: List[CronVulnerability] = field(default_factory=list)
    exploit_results: List[ExploitResult] = field(default_factory=list)
    scan_time: datetime = field(default_factory=datetime.now)

    @property
    def total_jobs(self) -> int:
        return len(self.cron_jobs)

    @property
    def root_job_count(self) -> int:
        return len(self.root_jobs)

    @property
    def vuln_count(self) -> int:
        return len(self.vulnerabilities)

    @property
    def critical_vulns(self) -> List[CronVulnerability]:
        return [v for v in self.vulnerabilities if v.severity == "CRITICAL"]

    @property
    def successful_exploits(self) -> List[ExploitResult]:
        return [r for r in self.exploit_results if r.execution_confirmed]

    def to_dict(self) -> Dict[str, Any]:
        return {
            'scan_time': self.scan_time.isoformat(),
            'summary': {
                'total_cron_jobs': self.total_jobs,
                'root_cron_jobs': self.root_job_count,
                'vulnerabilities': self.vuln_count,
                'critical': len(self.critical_vulns)
            },
            'root_jobs': [j.to_dict() for j in self.root_jobs],
            'vulnerabilities': [v.to_dict() for v in self.vulnerabilities],
            'exploit_results': [r.to_dict() for r in self.exploit_results]
        }

    def print_summary(self) -> None:
        """Print scan summary"""
        print(f"\n{'=' * 60}")
        print(f"CRON SCAN SUMMARY")
        print(f"{'=' * 60}")
        print(f"Total cron jobs found: {self.total_jobs}")
        print(f"  Running as root: {self.root_job_count}")
        print(f"Vulnerabilities found: {self.vuln_count}")

        if self.critical_vulns:
            print(f"  CRITICAL: {len(self.critical_vulns)}")

        if self.exploit_results:
            print(f"\nExploitation attempts: {len(self.exploit_results)}")
            print(f"  Successful: {len(self.successful_exploits)}")