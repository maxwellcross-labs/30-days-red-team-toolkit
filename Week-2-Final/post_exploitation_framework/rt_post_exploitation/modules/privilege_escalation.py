#!/usr/bin/env python3
"""
Privilege Escalation Module
Automated identification of escalation paths
"""

from typing import Dict, List
from dataclasses import dataclass


@dataclass
class PrivEscCheck:
    """Represents a privilege escalation check"""
    name: str
    description: str
    category: str
    severity: str  # 'high', 'medium', 'low'
    command: str
    mitigation: str = ""


class PrivilegeEscalator:
    """
    Automated privilege escalation path identification
    Discovers misconfigurations and weak permissions
    """
    
    def __init__(self):
        """Initialize privilege escalation checker"""
        self.checks = self._initialize_checks()
    
    def _initialize_checks(self) -> List[PrivEscCheck]:
        """Initialize privilege escalation checks"""
        return [
            # Service Misconfigurations
            PrivEscCheck(
                name="unquoted_service_paths",
                description="Services with unquoted paths containing spaces",
                category="Services",
                severity="high",
                command="""
Write-Host "[*] Checking for unquoted service paths..."

$vulnerableServices = Get-WmiObject win32_service | 
    Where-Object {
        $_.PathName -notmatch '"' -and 
        $_.PathName -match ' ' -and
        $_.StartMode -eq 'Auto'
    } |
    Select-Object Name, PathName, StartName, State, StartMode

if ($vulnerableServices) {
    Write-Host "[!] VULNERABLE: Unquoted service paths found"
    $vulnerableServices | ForEach-Object {
        Write-Host "    Service: $($_.Name)"
        Write-Host "    Path: $($_.PathName)"
        Write-Host "    Runs as: $($_.StartName)"
        Write-Host "    State: $($_.State)"
        Write-Host ""
    }
} else {
    Write-Host "[+] No unquoted service paths found"
}
""",
                mitigation="Place binary in unquoted path location with higher privilege"
            ),
            
            PrivEscCheck(
                name="weak_service_permissions",
                description="Services with weak file permissions",
                category="Services",
                severity="high",
                command="""
Write-Host "[*] Checking service binary permissions..."

Get-WmiObject win32_service | 
    Where-Object {$_.PathName -match '^\\"?([^\\"]+)'} |
    ForEach-Object {
        $path = $matches[1]
        if (Test-Path $path) {
            $acl = Get-Acl $path
            
            $weakPerms = $acl.Access | Where-Object {
                ($_.IdentityReference -match "Users|Everyone|Authenticated Users") -and
                ($_.FileSystemRights -match "FullControl|Modify|Write")
            }
            
            if ($weakPerms) {
                Write-Host "[!] VULNERABLE: $($_.Name)"
                Write-Host "    Path: $path"
                Write-Host "    Weak permissions for: $($weakPerms.IdentityReference -join ', ')"
                Write-Host ""
            }
        }
    }
"""
            ),
            
            PrivEscCheck(
                name="service_registry_permissions",
                description="Services with weak registry permissions",
                category="Services",
                severity="medium",
                command="""
Write-Host "[*] Checking service registry permissions..."

Get-Service | ForEach-Object {
    $regPath = "HKLM:\\SYSTEM\\CurrentControlSet\\Services\\$($_.Name)"
    
    if (Test-Path $regPath) {
        $acl = Get-Acl $regPath -ErrorAction SilentlyContinue
        
        if ($acl) {
            $weakPerms = $acl.Access | Where-Object {
                ($_.IdentityReference -match "Users|Everyone") -and 
                ($_.RegistryRights -match "FullControl|WriteKey|SetValue")
            }
            
            if ($weakPerms) {
                Write-Host "[!] VULNERABLE: $($_.Name)"
                Write-Host "    Registry: $regPath"
                Write-Host "    Weak permissions for: $($weakPerms.IdentityReference -join ', ')"
                Write-Host ""
            }
        }
    }
}
"""
            ),
            
            # Registry Exploits
            PrivEscCheck(
                name="always_install_elevated",
                description="AlwaysInstallElevated registry setting",
                category="Registry",
                severity="high",
                command="""
Write-Host "[*] Checking AlwaysInstallElevated..."

$hklm = Get-ItemProperty "HKLM:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
$hkcu = Get-ItemProperty "HKCU:\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue

if ($hklm.AlwaysInstallElevated -eq 1 -and $hkcu.AlwaysInstallElevated -eq 1) {
    Write-Host "[!] VULNERABLE: AlwaysInstallElevated is enabled"
    Write-Host "    Any MSI package will install with SYSTEM privileges"
} else {
    Write-Host "[+] AlwaysInstallElevated not enabled"
}
""",
                mitigation="Create and install malicious MSI package"
            ),
            
            PrivEscCheck(
                name="autologon_credentials",
                description="AutoLogon credentials in registry",
                category="Registry",
                severity="high",
                command="""
Write-Host "[*] Checking for AutoLogon credentials..."

$autologon = Get-ItemProperty 'HKLM:\\SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Winlogon' -ErrorAction SilentlyContinue

if ($autologon.DefaultUserName -or $autologon.DefaultPassword) {
    Write-Host "[!] VULNERABLE: AutoLogon credentials found"
    Write-Host "    Username: $($autologon.DefaultUserName)"
    Write-Host "    Password: $($autologon.DefaultPassword)"
} else {
    Write-Host "[+] No AutoLogon credentials found"
}
"""
            ),
            
            # Stored Credentials
            PrivEscCheck(
                name="stored_credentials",
                description="Windows stored credentials",
                category="Credentials",
                severity="medium",
                command="""
Write-Host "[*] Checking for stored credentials..."

$storedCreds = cmdkey /list

if ($storedCreds -match 'Target:') {
    Write-Host "[!] Stored credentials found:"
    $storedCreds | Where-Object {$_ -match 'Target:'} | ForEach-Object {
        Write-Host "    $_"
    }
} else {
    Write-Host "[+] No stored credentials found"
}
"""
            ),
            
            # Scheduled Tasks
            PrivEscCheck(
                name="scheduled_task_permissions",
                description="Scheduled tasks with weak permissions",
                category="Tasks",
                severity="medium",
                command="""
Write-Host "[*] Checking scheduled task permissions..."

$tasks = Get-ScheduledTask | Where-Object {$_.State -eq 'Ready'}

foreach ($task in $tasks) {
    $taskPath = "C:\\Windows\\System32\\Tasks\\$($task.TaskPath)$($task.TaskName)"
    
    if (Test-Path $taskPath) {
        $acl = Get-Acl $taskPath -ErrorAction SilentlyContinue
        
        $weakPerms = $acl.Access | Where-Object {
            ($_.IdentityReference -match "Users|Everyone") -and
            ($_.FileSystemRights -match "FullControl|Modify|Write")
        }
        
        if ($weakPerms) {
            Write-Host "[!] VULNERABLE: $($task.TaskName)"
            Write-Host "    Path: $taskPath"
            Write-Host "    Runs as: $($task.Principal.UserId)"
            Write-Host ""
        }
    }
}
"""
            ),
            
            # DLL Hijacking
            PrivEscCheck(
                name="writable_system_path",
                description="Writable directories in system PATH",
                category="DLL Hijacking",
                severity="medium",
                command="""
Write-Host "[*] Checking for writable PATH directories..."

$pathDirs = $env:PATH -split ';'

foreach ($dir in $pathDirs) {
    if (Test-Path $dir) {
        $acl = Get-Acl $dir -ErrorAction SilentlyContinue
        
        $writePerm = $acl.Access | Where-Object {
            ($_.IdentityReference -match "Users|Everyone|$env:USERNAME") -and
            ($_.FileSystemRights -match "FullControl|Modify|Write")
        }
        
        if ($writePerm) {
            Write-Host "[!] VULNERABLE: $dir"
            Write-Host "    Writable by: $($writePerm.IdentityReference -join ', ')"
            Write-Host ""
        }
    }
}
"""
            ),
            
            # Startup Folders
            PrivEscCheck(
                name="startup_folder_permissions",
                description="Weak permissions on startup folders",
                category="Startup",
                severity="low",
                command="""
Write-Host "[*] Checking startup folder permissions..."

$startupFolders = @(
    "$env:APPDATA\\Microsoft\\Windows\\Start Menu\\Programs\\Startup",
    "C:\\ProgramData\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"
)

foreach ($folder in $startupFolders) {
    if (Test-Path $folder) {
        $acl = Get-Acl $folder
        
        $weakPerms = $acl.Access | Where-Object {
            ($_.IdentityReference -match "Users|Everyone") -and
            ($_.FileSystemRights -match "FullControl|Modify|Write")
        }
        
        if ($weakPerms) {
            Write-Host "[!] VULNERABLE: $folder"
            Write-Host "    Writable by: $($weakPerms.IdentityReference -join ', ')"
            Write-Host ""
        }
    }
}
"""
            ),
            
            # Token Privileges
            PrivEscCheck(
                name="current_privileges",
                description="Current user token privileges",
                category="Tokens",
                severity="low",
                command="""
Write-Host "[*] Checking current user privileges..."

$privs = whoami /priv | Select-String "SeImpersonatePrivilege|SeAssignPrimaryTokenPrivilege|SeBackupPrivilege|SeRestorePrivilege|SeDebugPrivilege|SeTakeOwnershipPrivilege"

if ($privs) {
    Write-Host "[!] Interesting privileges found:"
    $privs | ForEach-Object { Write-Host "    $_" }
} else {
    Write-Host "[+] No interesting privileges"
}
"""
            ),
            
            # Group Memberships
            PrivEscCheck(
                name="group_memberships",
                description="Current user group memberships",
                category="Groups",
                severity="low",
                command="""
Write-Host "[*] Checking group memberships..."

$groups = whoami /groups | Select-String "Administrators|BUILTIN|Domain Admins|Enterprise Admins"

if ($groups) {
    Write-Host "[+] Privileged group memberships:"
    $groups | ForEach-Object { Write-Host "    $_" }
}
"""
            )
        ]
    
    def get_high_severity_checks(self) -> List[PrivEscCheck]:
        """Get high severity checks"""
        return [check for check in self.checks if check.severity == 'high']
    
    def get_checks_by_category(self, category: str) -> List[PrivEscCheck]:
        """Get checks for specific category"""
        return [check for check in self.checks if check.category.lower() == category.lower()]
    
    def get_all_checks(self) -> List[PrivEscCheck]:
        """Get all privilege escalation checks"""
        return sorted(self.checks, key=lambda x: {'high': 0, 'medium': 1, 'low': 2}[x.severity])
    
    def generate_escalation_script(self) -> str:
        """
        Generate complete privilege escalation check script
        
        Returns:
            PowerShell script for privilege escalation checks
        """
        script = """# Privilege Escalation Check Script
# Automated identification of escalation paths

Write-Host "[*] Starting privilege escalation checks..."

# Create output file
$outputFile = "$env:TEMP\\privesc_$(Get-Date -Format 'yyyyMMdd_HHmmss').txt"
Start-Transcript -Path $outputFile

# Check if running as admin
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

if ($isAdmin) {
    Write-Host "[*] Running with administrator privileges"
} else {
    Write-Host "[*] Running with user privileges"
}

"""
        
        for check in self.get_all_checks():
            script += f"""
# {check.description}
Write-Host "`n{'='*60}"
Write-Host "[*] CHECK: {check.name.upper()}"
Write-Host "    Category: {check.category}"
Write-Host "    Severity: {check.severity.upper()}"
Write-Host "{'='*60}"

{check.command}

"""
            
            if check.mitigation:
                script += f"""
# Exploitation: {check.mitigation}

"""
        
        script += """
Write-Host "`n[+] Privilege escalation checks complete"
Write-Host "[*] Results saved to: $outputFile"

Stop-Transcript
"""
        
        return script
    
    def get_escalation_summary(self) -> Dict:
        """Get summary of escalation checks"""
        categories = {}
        for check in self.checks:
            if check.category not in categories:
                categories[check.category] = {
                    'total': 0,
                    'high': 0,
                    'medium': 0,
                    'low': 0
                }
            categories[check.category]['total'] += 1
            categories[check.category][check.severity] += 1
        
        return {
            'total_checks': len(self.checks),
            'by_severity': {
                'high': len([c for c in self.checks if c.severity == 'high']),
                'medium': len([c for c in self.checks if c.severity == 'medium']),
                'low': len([c for c in self.checks if c.severity == 'low'])
            },
            'categories': categories
        }
